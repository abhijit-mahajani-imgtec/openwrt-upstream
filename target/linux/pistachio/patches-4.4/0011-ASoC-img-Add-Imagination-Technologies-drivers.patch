From 931067e2971eb5981563c50cec28b50403a685cc Mon Sep 17 00:00:00 2001
From: Damien Horsley <Damien.Horsley@imgtec.com>
Date: Mon, 2 Feb 2015 02:22:43 +0000
Subject: ASoC: img: Add Imagination Technologies drivers

This commit addds following drivers and their binding documents

1. I2S input driver
2. I2S output driver
3. Parallel output driver
4. Spdif input driver
5. Spdif output driver
6. pcm3060 driver
7. pcm3168a driver
9. Event timer driver

Also add ALSA StartAt and its support for cpu drivers

- Implement START_AT ioctl
- Implement start_at for system (posix) clocks using hi-res timers
- Implement start_at for audio clocks by forwarding to new fields in
	* snd_pcm_ops
	* snd_soc_ops
	* snd_soc_dai_ops
	* snd_soc_platform_driver

SNDRV_PCM_AUDIO_TSTAMP_* is taken from Pierre Louis Boussart's "Audio
Timestamping Evolutions" patchset, which has been accepted upstream.

Change-Id: Ic113ae7052609ad496b9a078d90ce3e801c15e2a
Signed-off-by: Damien.Horsley <Damien.Horsley@imgtec.com>
Signed-off-by: Tim Cussins <tim.cussins@linn.co.uk>
---
 .../devicetree/bindings/sound/img,i2s-in.txt       |  45 ++
 .../devicetree/bindings/sound/img,i2s-out.txt      |  49 ++
 .../devicetree/bindings/sound/img,parallel-out.txt |  44 +
 .../bindings/sound/img,pistachio-event-timer.txt   |  51 ++
 .../devicetree/bindings/sound/img,spdif-in.txt     |  41 +
 .../devicetree/bindings/sound/img,spdif-out.txt    |  44 +
 .../devicetree/bindings/sound/ti,pcm3060.txt       |  38 +
 .../devicetree/bindings/sound/ti,pcm3168a.txt      |  48 ++
 include/sound/dmaengine_pcm.h                      |   6 +
 include/sound/pcm.h                                |  24 +
 include/sound/soc-dai.h                            |   5 +
 include/sound/soc.h                                |   3 +
 include/uapi/sound/asound.h                        |  15 +
 sound/core/pcm.c                                   |   4 +-
 sound/core/pcm_compat.c                            |  22 +
 sound/core/pcm_dmaengine.c                         |   3 +-
 sound/core/pcm_lib.c                               |   2 +
 sound/core/pcm_native.c                            | 239 +++++-
 sound/soc/Kconfig                                  |   1 +
 sound/soc/Makefile                                 |   1 +
 sound/soc/codecs/Kconfig                           |  26 +
 sound/soc/codecs/Makefile                          |  12 +
 sound/soc/codecs/pcm3060-i2c.c                     |  66 ++
 sound/soc/codecs/pcm3060-spi.c                     |  65 ++
 sound/soc/codecs/pcm3060.c                         | 636 +++++++++++++++
 sound/soc/codecs/pcm3060.h                         |  86 ++
 sound/soc/codecs/pcm3168a-i2c.c                    |  66 ++
 sound/soc/codecs/pcm3168a-spi.c                    |  65 ++
 sound/soc/codecs/pcm3168a.c                        | 764 ++++++++++++++++++
 sound/soc/codecs/pcm3168a.h                        | 111 +++
 sound/soc/img/Kconfig                              |  50 ++
 sound/soc/img/Makefile                             |   7 +
 sound/soc/img/img-i2s-in.c                         | 508 ++++++++++++
 sound/soc/img/img-i2s-out.c                        | 585 ++++++++++++++
 sound/soc/img/img-parallel-out.c                   | 404 ++++++++++
 sound/soc/img/img-spdif-in.c                       | 799 +++++++++++++++++++
 sound/soc/img/img-spdif-out.c                      | 449 +++++++++++
 sound/soc/img/pistachio-event-timer.c              | 887 +++++++++++++++++++++
 sound/soc/img/pistachio-event-timer.h              |  54 ++
 sound/soc/soc-generic-dmaengine-pcm.c              |  79 +-
 sound/soc/soc-pcm.c                                |  89 +++
 41 files changed, 6479 insertions(+), 14 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/sound/img,i2s-in.txt
 create mode 100644 Documentation/devicetree/bindings/sound/img,i2s-out.txt
 create mode 100644 Documentation/devicetree/bindings/sound/img,parallel-out.txt
 create mode 100644 Documentation/devicetree/bindings/sound/img,pistachio-event-timer.txt
 create mode 100644 Documentation/devicetree/bindings/sound/img,spdif-in.txt
 create mode 100644 Documentation/devicetree/bindings/sound/img,spdif-out.txt
 create mode 100644 Documentation/devicetree/bindings/sound/ti,pcm3060.txt
 create mode 100644 Documentation/devicetree/bindings/sound/ti,pcm3168a.txt
 create mode 100644 sound/soc/codecs/pcm3060-i2c.c
 create mode 100644 sound/soc/codecs/pcm3060-spi.c
 create mode 100644 sound/soc/codecs/pcm3060.c
 create mode 100644 sound/soc/codecs/pcm3060.h
 create mode 100644 sound/soc/codecs/pcm3168a-i2c.c
 create mode 100644 sound/soc/codecs/pcm3168a-spi.c
 create mode 100644 sound/soc/codecs/pcm3168a.c
 create mode 100644 sound/soc/codecs/pcm3168a.h
 create mode 100644 sound/soc/img/Kconfig
 create mode 100644 sound/soc/img/Makefile
 create mode 100644 sound/soc/img/img-i2s-in.c
 create mode 100644 sound/soc/img/img-i2s-out.c
 create mode 100644 sound/soc/img/img-parallel-out.c
 create mode 100644 sound/soc/img/img-spdif-in.c
 create mode 100644 sound/soc/img/img-spdif-out.c
 create mode 100644 sound/soc/img/pistachio-event-timer.c
 create mode 100644 sound/soc/img/pistachio-event-timer.h

diff --git a/Documentation/devicetree/bindings/sound/img,i2s-in.txt b/Documentation/devicetree/bindings/sound/img,i2s-in.txt
new file mode 100644
index 0000000..a9e3c86
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/img,i2s-in.txt
@@ -0,0 +1,45 @@
+Imagination Technologies I2S Input Controller
+
+Required Properties:
+
+  - compatible : Compatible list, must contain "img,i2s-in"
+
+  - #sound-dai-cells : Must be equal to 0
+
+  - reg : Offset and length of the register set for the device
+
+  - clocks : Contains an entry for each entry in clock-names
+
+  - clock-names : Must include the following entry:
+	"sys"	The system clock
+
+  - dmas: Contains an entry for each entry in dma-names.
+
+  - dma-names: Must include the following entry:
+	"rx"	Single DMA channel used by all active I2S channels
+
+  - img,i2s-channels : Number of I2S channels instantiated in the I2S in block
+
+Optional Properties:
+
+  - interrupts : Contains the I2S in interrupts. Depending on
+	the configuration, there may be no interrupts, one interrupt,
+	or an interrupt per I2S channel
+
+  - resets: Contains a phandle to the I2S in reset signal
+
+  - reset-names: Contains the reset signal name "rst"
+
+Example:
+
+i2s_in: i2s-in@18100800 {
+	compatible = "img,i2s-in";
+	reg = <0x18100800 0x200>;
+	interrupts = <GIC_SHARED 7 IRQ_TYPE_LEVEL_HIGH>;
+	dmas = <&mdc 30 0xffffffff 0>;
+	dma-names = "rx";
+	clocks = <&cr_periph SYS_CLK_I2S_IN>;
+	clock-names = "sys";
+	img,i2s-channels = <6>;
+	#sound-dai-cells = <0>;
+};
diff --git a/Documentation/devicetree/bindings/sound/img,i2s-out.txt b/Documentation/devicetree/bindings/sound/img,i2s-out.txt
new file mode 100644
index 0000000..dc110ce
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/img,i2s-out.txt
@@ -0,0 +1,49 @@
+Imagination Technologies I2S Output Controller
+
+Required Properties:
+
+  - compatible : Compatible list, must contain "img,i2s-out"
+
+  - #sound-dai-cells : Must be equal to 0
+
+  - reg : Offset and length of the register set for the device
+
+  - clocks : Contains an entry for each entry in clock-names
+
+  - clock-names : Must include the following entries:
+	"sys"	The system clock
+	"ref"	The reference clock
+
+  - dmas: Contains an entry for each entry in dma-names.
+
+  - dma-names: Must include the following entry:
+	"tx"	Single DMA channel used by all active I2S channels
+
+  - img,i2s-channels : Number of I2S channels instantiated in the I2S out block
+
+  - resets: Contains a phandle to the I2S out reset signal
+
+  - reset-names: Contains the reset signal name "rst"
+
+Optional Properties:
+
+  - interrupts : Contains the I2S out interrupts. Depending on
+	the configuration, there may be no interrupts, one interrupt,
+	or an interrupt per I2S channel
+
+Example:
+
+i2s_out: i2s-out@18100A00 {
+	compatible = "img,i2s-out";
+	reg = <0x18100A00 0x200>;
+	interrupts = <GIC_SHARED 13 IRQ_TYPE_LEVEL_HIGH>;
+	dmas = <&mdc 23 0xffffffff 0>;
+	dma-names = "tx";
+	clocks = <&cr_periph SYS_CLK_I2S_OUT>,
+		 <&clk_core CLK_I2S>;
+	clock-names = "sys", "ref";
+	img,i2s-channels = <6>;
+	resets = <&pistachio_reset PISTACHIO_RESET_I2S_OUT>;
+	reset-names = "rst";
+	#sound-dai-cells = <0>;
+};
diff --git a/Documentation/devicetree/bindings/sound/img,parallel-out.txt b/Documentation/devicetree/bindings/sound/img,parallel-out.txt
new file mode 100644
index 0000000..a3015d2
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/img,parallel-out.txt
@@ -0,0 +1,44 @@
+Imagination Technologies Parallel Output Controller
+
+Required Properties:
+
+  - compatible : Compatible list, must contain "img,parallel-out".
+
+  - #sound-dai-cells : Must be equal to 0
+
+  - reg : Offset and length of the register set for the device.
+
+  - dmas: Contains an entry for each entry in dma-names.
+
+  - dma-names: Must include the following entry:
+	"tx"
+
+  - clocks : Contains an entry for each entry in clock-names.
+
+  - clock-names : Includes the following entries:
+	"sys"	The system clock
+	"ref"	The reference clock
+
+  - resets: Contains a phandle to the parallel out reset signal
+
+  - reset-names: Contains the reset signal name "rst"
+
+Optional Properties:
+
+  - interrupts : Contains the parallel out interrupt, if present
+
+Example:
+
+parallel_out: parallel-out@18100C00 {
+	compatible = "img,parallel-out";
+	reg = <0x18100C00 0x100>;
+	interrupts = <GIC_SHARED 19 IRQ_TYPE_LEVEL_HIGH>;
+	dmas = <&mdc 16 0xffffffff 0>;
+	dma-names = "tx";
+	clocks = <&cr_periph SYS_CLK_PAUD_OUT>,
+		 <&clk_core CLK_AUDIO_DAC>;
+	clock-names = "sys", "ref";
+	resets = <&pistachio_reset PISTACHIO_RESET_PRL_OUT>;
+	reset-names = "rst";
+	#sound-dai-cells = <0>;
+};
diff --git a/Documentation/devicetree/bindings/sound/img,pistachio-event-timer.txt b/Documentation/devicetree/bindings/sound/img,pistachio-event-timer.txt
new file mode 100644
index 0000000..252bcd9
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/img,pistachio-event-timer.txt
@@ -0,0 +1,51 @@
+Imagination Technologies Pistachio Event Timer
+
+Required properties:
+
+  - compatible : Compatible list, must contain "img,pistachio-event-timer"
+
+  - reg : Offset and length of the register set for the device
+
+  - interrupts : Must contain an entry for each of the three interrupts below.
+		 Order must also match the below:
+
+		 Internal interrupt 1
+		 Internal interrupt 2
+		 Internal interrupt 3
+		 Event trigger 0
+		 Event trigger 1
+
+  - #clock-cells : Must be 0
+
+  - clocks : Must contain an entry for each entry in clock-names
+	See ../clock/clock-bindings.txt for details
+
+  - clock-names : Must include the following entries:
+	"sys"	The system clock
+	"ref0"	Reference clock 0
+	"ref1"	Reference clock 1
+
+  - img,clk-select : Reference select
+
+Optional properties:
+
+  - img,clk-rate : Internal clock rate
+
+Example:
+
+event_timer: event_timer@18102300 {
+	compatible = "img,pistachio-event-timer";
+	reg = <0x18102300 0x400>;
+	assigned-clocks = <&clk_core CLK_EVENT_TIMER_MUX>;
+	assigned-clock-parents = <&clk_core CLK_AUDIO_PLL_MUX>;
+	interrupts = <GIC_SHARED 53 IRQ_TYPE_LEVEL_HIGH>,
+		     <GIC_SHARED 54 IRQ_TYPE_LEVEL_HIGH>,
+		     <GIC_SHARED 55 IRQ_TYPE_LEVEL_HIGH>,
+		     <GIC_SHARED 56 IRQ_TYPE_LEVEL_HIGH>,
+		     <GIC_SHARED 57 IRQ_TYPE_LEVEL_HIGH>;
+	#clock-cells = <0>;
+	clocks = <&clk_core SYS_CLK_EVENT_TIMER &clk_core CLK_AUDIO &clk_core CLK_EVENT_TIMER>;
+	clock-names = "sys","ref0","ref1";
+	img,clk-select = <1>;
+	img,clk-rate = <12288000>;
+};
diff --git a/Documentation/devicetree/bindings/sound/img,spdif-in.txt b/Documentation/devicetree/bindings/sound/img,spdif-in.txt
new file mode 100644
index 0000000..aab9a81
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/img,spdif-in.txt
@@ -0,0 +1,41 @@
+Imagination Technologies SPDIF Input Controller
+
+Required Properties:
+
+  - compatible : Compatible list, must contain "img,spdif-in"
+
+  - #sound-dai-cells : Must be equal to 0
+
+  - reg : Offset and length of the register set for the device
+
+  - dmas: Contains an entry for each entry in dma-names.
+
+  - dma-names: Must include the following entry:
+	"rx"
+
+  - clocks : Contains an entry for each entry in clock-names
+
+  - clock-names : Includes the following entries:
+	"sys"	The system clock
+
+Optional Properties:
+
+  - resets: Should contain a phandle to the spdif in reset signal, if any
+
+  - reset-names: Should contain the reset signal name "rst", if a
+	reset phandle is given
+
+  - interrupts : Contains the spdif in interrupt, if present
+
+Example:
+
+spdif_in: spdif-in@18100E00 {
+	compatible = "img,spdif-in";
+	reg = <0x18100E00 0x100>;
+	interrupts = <GIC_SHARED 20 IRQ_TYPE_LEVEL_HIGH>;
+	dmas = <&mdc 15 0xffffffff 0>;
+	dma-names = "rx";
+	clocks = <&cr_periph SYS_CLK_SPDIF_IN>;
+	clock-names = "sys";
+	#sound-dai-cells = <0>;
+};
diff --git a/Documentation/devicetree/bindings/sound/img,spdif-out.txt b/Documentation/devicetree/bindings/sound/img,spdif-out.txt
new file mode 100644
index 0000000..470a519
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/img,spdif-out.txt
@@ -0,0 +1,44 @@
+Imagination Technologies SPDIF Output Controller
+
+Required Properties:
+
+  - compatible : Compatible list, must contain "img,spdif-out"
+
+  - #sound-dai-cells : Must be equal to 0
+
+  - reg : Offset and length of the register set for the device
+
+  - dmas: Contains an entry for each entry in dma-names.
+
+  - dma-names: Must include the following entry:
+	"tx"
+
+  - clocks : Contains an entry for each entry in clock-names.
+
+  - clock-names : Includes the following entries:
+	"sys"	The system clock
+	"ref"	The reference clock
+
+  - resets: Contains a phandle to the spdif out reset signal
+
+  - reset-names: Contains the reset signal name "rst"
+
+Optional Properties:
+
+  - interrupts : Contains the parallel out interrupt, if present
+
+Example:
+
+spdif_out: spdif-out@18100D00 {
+	compatible = "img,spdif-out";
+	reg = <0x18100D00 0x100>;
+	interrupts = <GIC_SHARED 21 IRQ_TYPE_LEVEL_HIGH>;
+	dmas = <&mdc 14 0xffffffff 0>;
+	dma-names = "tx";
+	clocks = <&cr_periph SYS_CLK_SPDIF_OUT>,
+		 <&clk_core CLK_SPDIF>;
+	clock-names = "sys", "ref";
+	resets = <&pistachio_reset PISTACHIO_RESET_SPDIF_OUT>;
+	reset-names = "rst";
+	#sound-dai-cells = <0>;
+};
diff --git a/Documentation/devicetree/bindings/sound/ti,pcm3060.txt b/Documentation/devicetree/bindings/sound/ti,pcm3060.txt
new file mode 100644
index 0000000..d0a0b13
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/ti,pcm3060.txt
@@ -0,0 +1,38 @@
+Texas Instruments pcm3060 DT bindings
+
+This driver supports both SPI and I2C bus access for this codec
+
+Required properties:
+
+  - compatible: "ti,pcm3060"
+
+  - clocks : Contains an entry for each entry in clock-names
+
+  - clock-names : Includes the following entries:
+	"sckid"	The DAC system clock
+	"sckia"	The ADC system clock
+
+  - VDD-supply : Digital power supply regulator (+3.3V)
+
+  - VCC-supply : Analogue power supply regulator (+5V)
+
+For required properties on SPI/I2C, consult SPI/I2C device tree documentation
+
+Examples:
+
+i2c0: i2c0@0 {
+
+	...
+
+	pcm3060: audio-codec@46 {
+		compatible = "ti,pcm3060";
+		reg = <0x46>;
+		clocks = <&clk_core CLK_I2S>,
+			 <&clk_core CLK_I2S>;
+		clock-names = "sckid", "sckia";
+		VCC-supply = <&supply5v0>;
+		VDD-supply = <&supply3v3>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2s_mclk_pin>;
+	};
+};
diff --git a/Documentation/devicetree/bindings/sound/ti,pcm3168a.txt b/Documentation/devicetree/bindings/sound/ti,pcm3168a.txt
new file mode 100644
index 0000000..5d9cb84
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/ti,pcm3168a.txt
@@ -0,0 +1,48 @@
+Texas Instruments pcm3168a DT bindings
+
+This driver supports both SPI and I2C bus access for this codec
+
+Required properties:
+
+  - compatible: "ti,pcm3168a"
+
+  - clocks : Contains an entry for each entry in clock-names
+
+  - clock-names : Includes the following entries:
+	"scki"	The system clock
+
+  - VDD1-supply : Digital power supply regulator 1 (+3.3V)
+
+  - VDD2-supply : Digital power supply regulator 2 (+3.3V)
+
+  - VCCAD1-supply : ADC power supply regulator 1 (+5V)
+
+  - VCCAD2-supply : ADC power supply regulator 2 (+5V)
+
+  - VCCDA1-supply : DAC power supply regulator 1 (+5V)
+
+  - VCCDA2-supply : DAC power supply regulator 2 (+5V)
+
+For required properties on SPI/I2C, consult SPI/I2C device tree documentation
+
+Examples:
+
+i2c0: i2c0@0 {
+
+	...
+
+	pcm3168a: audio-codec@44 {
+		compatible = "ti,pcm3168a";
+		reg = <0x44>;
+		clocks = <&clk_core CLK_AUDIO>;
+		clock-names = "scki";
+		VDD1-supply = <&supply3v3>;
+		VDD2-supply = <&supply3v3>;
+		VCCAD1-supply = <&supply5v0>;
+		VCCAD2-supply = <&supply5v0>;
+		VCCDA1-supply = <&supply5v0>;
+		VCCDA2-supply = <&supply5v0>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&dac_clk_pin>;
+	};
+};
diff --git a/include/sound/dmaengine_pcm.h b/include/sound/dmaengine_pcm.h
index f86ef5e..5c6ec33 100644
--- a/include/sound/dmaengine_pcm.h
+++ b/include/sound/dmaengine_pcm.h
@@ -35,6 +35,7 @@ snd_pcm_substream_to_dma_direction(const struct snd_pcm_substream *substream)
 
 int snd_hwparams_to_dma_slave_config(const struct snd_pcm_substream *substream,
 	const struct snd_pcm_hw_params *params, struct dma_slave_config *slave_config);
+int dmaengine_pcm_prepare_and_submit(struct snd_pcm_substream *substream);
 int snd_dmaengine_pcm_trigger(struct snd_pcm_substream *substream, int cmd);
 snd_pcm_uframes_t snd_dmaengine_pcm_pointer(struct snd_pcm_substream *substream);
 snd_pcm_uframes_t snd_dmaengine_pcm_pointer_no_residue(struct snd_pcm_substream *substream);
@@ -99,6 +100,11 @@ void snd_dmaengine_pcm_set_config_from_dai_data(
  * The PCM streams have custom channel names specified.
  */
 #define SND_DMAENGINE_PCM_FLAG_CUSTOM_CHANNEL_NAME BIT(4)
+/*
+ * DMA needs to be started early when start_at is used (eg to allow pre-loading
+ * of internal fifos before assertion of an enable signal)
+ */
+#define SND_DMAENGINE_PCM_FLAG_EARLY_START BIT(5)
 
 /**
  * struct snd_dmaengine_pcm_config - Configuration data for dmaengine based PCM
diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index b0be092..7962ed0 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -30,6 +30,9 @@
 #include <linux/mm.h>
 #include <linux/bitops.h>
 #include <linux/pm_qos.h>
+#if defined(CONFIG_HIGH_RES_TIMERS)
+#include <linux/hrtimer.h>
+#endif
 
 #define snd_pcm_substream_chip(substream) ((substream)->private_data)
 #define snd_pcm_chip(pcm) ((pcm)->private_data)
@@ -73,6 +76,9 @@ struct snd_pcm_ops {
 	int (*hw_free)(struct snd_pcm_substream *substream);
 	int (*prepare)(struct snd_pcm_substream *substream);
 	int (*trigger)(struct snd_pcm_substream *substream, int cmd);
+	int (*start_at)(struct snd_pcm_substream *substream,
+		int audio_clock_type, const struct timespec *ts);
+	int (*start_at_abort)(struct snd_pcm_substream *substream);
 	snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *substream);
 	int (*get_time_info)(struct snd_pcm_substream *substream,
 			struct timespec *system_ts, struct timespec *audio_ts,
@@ -422,6 +428,7 @@ struct snd_pcm_runtime {
 	/* -- OSS things -- */
 	struct snd_pcm_oss_runtime oss;
 #endif
+
 };
 
 struct snd_pcm_group {		/* keep linked substreams */
@@ -482,6 +489,16 @@ struct snd_pcm_substream {
 #endif /* CONFIG_SND_VERBOSE_PROCFS */
 	/* misc flags */
 	unsigned int hw_opened: 1;
+	/* start at wait queue */
+	wait_queue_head_t start_at_wait;
+	/* start at status info */
+	bool start_at_pending;
+	/* Clock type for pending start at */
+	int start_at_clock_class;
+#ifdef CONFIG_HIGH_RES_TIMERS
+	/* start at timer for use with system startat */
+	struct hrtimer start_at_timer;
+#endif
 };
 
 #define SUBSTREAM_BUSY(substream) ((substream)->ref_count > 0)
@@ -564,6 +581,10 @@ int snd_pcm_info_user(struct snd_pcm_substream *substream,
 int snd_pcm_status(struct snd_pcm_substream *substream,
 		   struct snd_pcm_status *status);
 int snd_pcm_start(struct snd_pcm_substream *substream);
+int snd_pcm_pre_start(struct snd_pcm_substream *substream, int state);
+int snd_pcm_do_start(struct snd_pcm_substream *substream, int state);
+void snd_pcm_undo_start(struct snd_pcm_substream *substream, int state);
+void snd_pcm_post_start(struct snd_pcm_substream *substream, int state);
 int snd_pcm_stop(struct snd_pcm_substream *substream, snd_pcm_state_t status);
 int snd_pcm_drain_done(struct snd_pcm_substream *substream);
 int snd_pcm_stop_xrun(struct snd_pcm_substream *substream);
@@ -1086,6 +1107,9 @@ snd_pcm_sframes_t snd_pcm_lib_writev(struct snd_pcm_substream *substream,
 snd_pcm_sframes_t snd_pcm_lib_readv(struct snd_pcm_substream *substream,
 				    void __user **bufs, snd_pcm_uframes_t frames);
 
+void snd_pcm_start_at_trigger(struct snd_pcm_substream *substream);
+void snd_pcm_start_at_cleanup(struct snd_pcm_substream *substream);
+
 extern const struct snd_pcm_hw_constraint_list snd_pcm_known_rates;
 
 int snd_pcm_limit_hw_rates(struct snd_pcm_runtime *runtime);
diff --git a/include/sound/soc-dai.h b/include/sound/soc-dai.h
index 212eaaf..b502ba0 100644
--- a/include/sound/soc-dai.h
+++ b/include/sound/soc-dai.h
@@ -205,6 +205,11 @@ struct snd_soc_dai_ops {
 	 */
 	snd_pcm_sframes_t (*delay)(struct snd_pcm_substream *,
 		struct snd_soc_dai *);
+
+	int (*start_at)(struct snd_pcm_substream *, struct snd_soc_dai *,
+		int, const struct timespec *);
+	int (*start_at_abort)(struct snd_pcm_substream *,
+		struct snd_soc_dai *);
 };
 
 /*
diff --git a/include/sound/soc.h b/include/sound/soc.h
index fb955e6..ce12720 100644
--- a/include/sound/soc.h
+++ b/include/sound/soc.h
@@ -737,6 +737,9 @@ struct snd_soc_ops {
 	int (*hw_free)(struct snd_pcm_substream *);
 	int (*prepare)(struct snd_pcm_substream *);
 	int (*trigger)(struct snd_pcm_substream *, int);
+	int (*start_at)(struct snd_pcm_substream *, int,
+		const struct timespec *);
+	int (*start_at_abort)(struct snd_pcm_substream *);
 };
 
 struct snd_soc_compr_ops {
diff --git a/include/uapi/sound/asound.h b/include/uapi/sound/asound.h
index a82108e..76919b9 100644
--- a/include/uapi/sound/asound.h
+++ b/include/uapi/sound/asound.h
@@ -293,6 +293,7 @@ typedef int __bitwise snd_pcm_state_t;
 #define	SNDRV_PCM_STATE_PAUSED		((__force snd_pcm_state_t) 6) /* stream is paused */
 #define	SNDRV_PCM_STATE_SUSPENDED	((__force snd_pcm_state_t) 7) /* hardware is suspended */
 #define	SNDRV_PCM_STATE_DISCONNECTED	((__force snd_pcm_state_t) 8) /* hardware is disconnected */
+#define	SNDRV_PCM_STATE_STARTING	((__force snd_pcm_state_t) 9) /* stream start has been delegated to the kernel */
 #define	SNDRV_PCM_STATE_LAST		SNDRV_PCM_STATE_DISCONNECTED
 
 enum {
@@ -503,6 +504,18 @@ enum {
 	SNDRV_PCM_TSTAMP_TYPE_LAST = SNDRV_PCM_TSTAMP_TYPE_MONOTONIC_RAW,
 };
 
+enum {
+	SNDRV_PCM_CLOCK_CLASS_SYSTEM = 0,
+	SNDRV_PCM_CLOCK_CLASS_AUDIO,
+	SNDRV_PCM_CLOCK_CLASS_LAST = SNDRV_PCM_CLOCK_CLASS_AUDIO,
+};
+
+struct snd_startat {
+	int clock_class;
+	int clock_type;
+	struct timespec start_time;
+};
+
 /* channel positions */
 enum {
 	SNDRV_CHMAP_UNKNOWN = 0,
@@ -582,6 +595,8 @@ enum {
 #define SNDRV_PCM_IOCTL_READN_FRAMES	_IOR('A', 0x53, struct snd_xfern)
 #define SNDRV_PCM_IOCTL_LINK		_IOW('A', 0x60, int)
 #define SNDRV_PCM_IOCTL_UNLINK		_IO('A', 0x61)
+#define SNDRV_PCM_IOCTL_START_AT        _IOW('A', 0x62, struct snd_startat)
+
 
 /*****************************************************************************
  *                                                                           *
diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 308c9ec..228d610 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -489,7 +489,8 @@ static void snd_pcm_xrun_injection_write(struct snd_info_entry *entry,
 
 	snd_pcm_stream_lock_irq(substream);
 	runtime = substream->runtime;
-	if (runtime && runtime->status->state == SNDRV_PCM_STATE_RUNNING)
+	if (runtime && (runtime->status->state == SNDRV_PCM_STATE_RUNNING ||
+			runtime->status->state == SNDRV_PCM_STATE_STARTING))
 		snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
 	snd_pcm_stream_unlock_irq(substream);
 }
@@ -746,6 +747,7 @@ int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 		INIT_LIST_HEAD(&substream->self_group.substreams);
 		list_add_tail(&substream->link_list, &substream->self_group.substreams);
 		atomic_set(&substream->mmap_count, 0);
+		init_waitqueue_head(&substream->start_at_wait);
 		prev = substream;
 	}
 	return 0;
diff --git a/sound/core/pcm_compat.c b/sound/core/pcm_compat.c
index 1f64ab0..63451e3 100644
--- a/sound/core/pcm_compat.c
+++ b/sound/core/pcm_compat.c
@@ -316,6 +316,25 @@ static int snd_pcm_status_user_x32(struct snd_pcm_substream *substream,
 }
 #endif /* CONFIG_X86_X32 */
 
+struct snd_startat32 {
+	u32 clock_class;
+	u32 clock_type;
+	struct compat_timespec start_time;
+} __packed;
+
+static int snd_pcm_start_at_compat(struct snd_pcm_substream *substream,
+					struct snd_startat32 __user *_start_at)
+{
+	struct snd_startat start_at;
+
+	if (get_user(start_at.clock_class, &_start_at.clock_class) ||
+	    get_user(start_at.clock_type, &_start_at.clock_type) ||
+	    compat_get_timespec(&start_at.start_time, &_start_at.start_time))
+		return -EFAULT;
+
+	return snd_pcm_start_at(substream, &start_at);
+}
+
 /* both for HW_PARAMS and HW_REFINE */
 static int snd_pcm_ioctl_hw_params_compat(struct snd_pcm_substream *substream,
 					  int refine, 
@@ -653,6 +672,7 @@ enum {
 	SNDRV_PCM_IOCTL_STATUS_EXT_X32 = _IOWR('A', 0x24, struct snd_pcm_status_x32),
 	SNDRV_PCM_IOCTL_SYNC_PTR_X32 = _IOWR('A', 0x23, struct snd_pcm_sync_ptr_x32),
 #endif /* CONFIG_X86_X32 */
+	SNDRV_PCM_IOCTL_START_AT32 = _IOWR('A', 0x62, struct snd_startat32)
 };
 
 static long snd_pcm_ioctl_compat(struct file *file, unsigned int cmd, unsigned long arg)
@@ -734,6 +754,8 @@ static long snd_pcm_ioctl_compat(struct file *file, unsigned int cmd, unsigned l
 	case SNDRV_PCM_IOCTL_CHANNEL_INFO_X32:
 		return snd_pcm_ioctl_channel_info_x32(substream, argp);
 #endif /* CONFIG_X86_X32 */
+	case SNDRV_PCM_IOCTL_START_AT32:
+		return snd_pcm_start_at_compat(substream, argp);
 	}
 
 	return -ENOIOCTLCMD;
diff --git a/sound/core/pcm_dmaengine.c b/sound/core/pcm_dmaengine.c
index fba365a..7956da1 100644
--- a/sound/core/pcm_dmaengine.c
+++ b/sound/core/pcm_dmaengine.c
@@ -142,7 +142,7 @@ static void dmaengine_pcm_dma_complete(void *arg)
 	snd_pcm_period_elapsed(substream);
 }
 
-static int dmaengine_pcm_prepare_and_submit(struct snd_pcm_substream *substream)
+int dmaengine_pcm_prepare_and_submit(struct snd_pcm_substream *substream)
 {
 	struct dmaengine_pcm_runtime_data *prtd = substream_to_prtd(substream);
 	struct dma_chan *chan = prtd->dma_chan;
@@ -170,6 +170,7 @@ static int dmaengine_pcm_prepare_and_submit(struct snd_pcm_substream *substream)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(dmaengine_pcm_prepare_and_submit);
 
 /**
  * snd_dmaengine_pcm_trigger - dmaengine based PCM trigger implementation
diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index 3a9b66c..c4d88ee 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -2025,6 +2025,7 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,
 	snd_pcm_stream_lock_irq(substream);
 	switch (runtime->status->state) {
 	case SNDRV_PCM_STATE_PREPARED:
+	case SNDRV_PCM_STATE_STARTING:
 	case SNDRV_PCM_STATE_RUNNING:
 	case SNDRV_PCM_STATE_PAUSED:
 		break;
@@ -2251,6 +2252,7 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
 		break;
 	case SNDRV_PCM_STATE_DRAINING:
 	case SNDRV_PCM_STATE_RUNNING:
+	case SNDRV_PCM_STATE_STARTING:
 	case SNDRV_PCM_STATE_PAUSED:
 		break;
 	case SNDRV_PCM_STATE_XRUN:
diff --git a/sound/core/pcm_native.c b/sound/core/pcm_native.c
index 4ba64fd..d370846 100644
--- a/sound/core/pcm_native.c
+++ b/sound/core/pcm_native.c
@@ -35,6 +35,9 @@
 #include <sound/timer.h>
 #include <sound/minors.h>
 #include <linux/uio.h>
+#if defined(CONFIG_HIGH_RES_TIMERS)
+#include <linux/hrtimer.h>
+#endif
 
 /*
  *  Compatibility
@@ -277,7 +280,7 @@ static const char * const snd_pcm_hw_param_names[] = {
 };
 #endif
 
-int snd_pcm_hw_refine(struct snd_pcm_substream *substream, 
+int snd_pcm_hw_refine(struct snd_pcm_substream *substream,
 		      struct snd_pcm_hw_params *params)
 {
 	unsigned int k;
@@ -1028,7 +1031,7 @@ static int snd_pcm_action_nonatomic(struct action_ops *ops,
 /*
  * start callbacks
  */
-static int snd_pcm_pre_start(struct snd_pcm_substream *substream, int state)
+int snd_pcm_pre_start(struct snd_pcm_substream *substream, int state)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	if (runtime->status->state != SNDRV_PCM_STATE_PREPARED)
@@ -1040,21 +1043,24 @@ static int snd_pcm_pre_start(struct snd_pcm_substream *substream, int state)
 	runtime->trigger_master = substream;
 	return 0;
 }
+EXPORT_SYMBOL_GPL(snd_pcm_pre_start);
 
-static int snd_pcm_do_start(struct snd_pcm_substream *substream, int state)
+int snd_pcm_do_start(struct snd_pcm_substream *substream, int state)
 {
 	if (substream->runtime->trigger_master != substream)
 		return 0;
 	return substream->ops->trigger(substream, SNDRV_PCM_TRIGGER_START);
 }
+EXPORT_SYMBOL_GPL(snd_pcm_do_start);
 
-static void snd_pcm_undo_start(struct snd_pcm_substream *substream, int state)
+void snd_pcm_undo_start(struct snd_pcm_substream *substream, int state)
 {
 	if (substream->runtime->trigger_master == substream)
 		substream->ops->trigger(substream, SNDRV_PCM_TRIGGER_STOP);
 }
+EXPORT_SYMBOL_GPL(snd_pcm_undo_start);
 
-static void snd_pcm_post_start(struct snd_pcm_substream *substream, int state)
+void snd_pcm_post_start(struct snd_pcm_substream *substream, int state)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	snd_pcm_trigger_tstamp(substream);
@@ -1067,6 +1073,7 @@ static void snd_pcm_post_start(struct snd_pcm_substream *substream, int state)
 		snd_pcm_playback_silence(substream, ULONG_MAX);
 	snd_pcm_timer_notify(substream, SNDRV_TIMER_EVENT_MSTART);
 }
+EXPORT_SYMBOL_GPL(snd_pcm_post_start);
 
 static struct action_ops snd_pcm_action_start = {
 	.pre_action = snd_pcm_pre_start,
@@ -1075,6 +1082,183 @@ static struct action_ops snd_pcm_action_start = {
 	.post_action = snd_pcm_post_start
 };
 
+void snd_pcm_start_at_cleanup(struct snd_pcm_substream *substream)
+{
+	substream->start_at_pending = 0;
+	wake_up(&substream->start_at_wait);
+}
+EXPORT_SYMBOL_GPL(snd_pcm_start_at_cleanup);
+
+void snd_pcm_start_at_trigger(struct snd_pcm_substream *substream)
+{
+	snd_pcm_stream_lock(substream);
+
+	if(substream->runtime->status->state == SNDRV_PCM_STATE_STARTING)
+		if(!snd_pcm_do_start(substream, SNDRV_PCM_STATE_RUNNING))
+			snd_pcm_post_start(substream, SNDRV_PCM_STATE_RUNNING);
+
+	snd_pcm_start_at_cleanup(substream);
+
+	snd_pcm_stream_unlock(substream);
+}
+EXPORT_SYMBOL_GPL(snd_pcm_start_at_trigger);
+
+#ifdef CONFIG_HIGH_RES_TIMERS
+static enum hrtimer_restart snd_pcm_do_start_time(struct hrtimer *timer)
+{
+	struct snd_pcm_substream *substream;
+
+	substream = container_of(timer, struct snd_pcm_substream,
+					start_at_timer);
+
+	snd_pcm_start_at_trigger(substream);
+
+	return HRTIMER_NORESTART;
+}
+#endif
+
+static int snd_pcm_startat_system(struct snd_pcm_substream *substream,
+	int clock_type, const struct timespec *start_time)
+{
+#ifdef CONFIG_HIGH_RES_TIMERS
+	struct timespec now;
+	clockid_t clock;
+
+	switch (clock_type) {
+	case SNDRV_PCM_TSTAMP_TYPE_GETTIMEOFDAY:
+		clock = CLOCK_REALTIME;
+		getnstimeofday(&now);
+		break;
+	case SNDRV_PCM_TSTAMP_TYPE_MONOTONIC:
+		clock = CLOCK_MONOTONIC;
+		ktime_get_ts(&now);
+		break;
+	default: /* unsupported clocks bounce off */
+		return -ENOSYS;
+	}
+
+	/* Check if start_time is in the past */
+	if (timespec_compare(&now, start_time) >= 0)
+		return -ETIME;
+
+	hrtimer_init(&substream->start_at_timer, clock, HRTIMER_MODE_ABS);
+	substream->start_at_timer.function = snd_pcm_do_start_time;
+
+	return hrtimer_start(&substream->start_at_timer,
+			timespec_to_ktime(*start_time), HRTIMER_MODE_ABS);
+#else
+	return -ENOSYS;
+#endif
+}
+
+static void snd_pcm_startat_system_cancel(struct snd_pcm_substream *substream)
+{
+#ifdef CONFIG_HIGH_RES_TIMERS
+	if(hrtimer_try_to_cancel(&substream->start_at_timer) == 1)
+		snd_pcm_start_at_cleanup(substream);
+#endif
+}
+
+static int snd_pcm_startat_audio(struct snd_pcm_substream *substream,
+	int clock_type, const struct timespec *start_time)
+{
+	if (substream->ops->start_at)
+		return substream->ops->start_at(substream, clock_type,
+			start_time);
+	else
+		return -ENOSYS;
+}
+
+static void snd_pcm_startat_audio_cancel(struct snd_pcm_substream *substream)
+{
+	if (substream->ops->start_at_abort)
+		substream->ops->start_at_abort(substream);
+}
+
+static int snd_pcm_start_at(struct snd_pcm_substream *substream,
+	struct snd_startat *start_at)
+{
+	int ret;
+
+	if (!timespec_valid(&start_at->start_time))
+		return -EINVAL;
+
+	snd_pcm_stream_lock(substream);
+
+	if(substream->start_at_pending) {
+		ret = -EBUSY;
+		goto end;
+	}
+
+	ret = snd_pcm_pre_start(substream, SNDRV_PCM_STATE_PREPARED);
+	if (ret < 0)
+		goto end;
+
+	switch (start_at->clock_class) {
+	case SNDRV_PCM_CLOCK_CLASS_SYSTEM:
+		ret = snd_pcm_startat_system(substream,
+			start_at->clock_type,
+			&start_at->start_time);
+		break;
+	case SNDRV_PCM_CLOCK_CLASS_AUDIO:
+		ret = snd_pcm_startat_audio(substream,
+			start_at->clock_type,
+			&start_at->start_time);
+		if(ret)
+			snd_pcm_startat_audio_cancel(substream);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	if (!ret) {
+		substream->runtime->status->state = SNDRV_PCM_STATE_STARTING;
+		substream->start_at_pending = true;
+		substream->start_at_clock_class = start_at->clock_class;
+	}
+
+end:
+	snd_pcm_stream_unlock(substream);
+	return ret;
+}
+
+static void snd_pcm_startat_cancel(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	if (runtime->status->state != SNDRV_PCM_STATE_STARTING)
+		return;
+
+	switch (substream->start_at_clock_class) {
+	case SNDRV_PCM_CLOCK_CLASS_SYSTEM:
+		snd_pcm_startat_system_cancel(substream);
+		break;
+	case SNDRV_PCM_CLOCK_CLASS_AUDIO:
+		snd_pcm_startat_audio_cancel(substream);
+		break;
+	default:
+		return;
+	}
+
+	runtime->status->state = SNDRV_PCM_STATE_SETUP;
+
+	wait_event_cmd(substream->start_at_wait,
+			!substream->start_at_pending,
+			snd_pcm_stream_unlock(substream),
+			snd_pcm_stream_lock(substream));
+}
+
+int snd_pcm_start_at_user(struct snd_pcm_substream *substream,
+	struct snd_startat __user *_start_at_user)
+{
+	struct snd_startat start_at;
+
+	if (copy_from_user(&start_at, _start_at_user, sizeof(start_at)))
+		return -EFAULT;
+
+	return snd_pcm_start_at(substream, &start_at);
+}
+
 /**
  * snd_pcm_start - start all linked streams
  * @substream: the PCM substream instance
@@ -1101,9 +1285,21 @@ static int snd_pcm_pre_stop(struct snd_pcm_substream *substream, int state)
 
 static int snd_pcm_do_stop(struct snd_pcm_substream *substream, int state)
 {
-	if (substream->runtime->trigger_master == substream &&
-	    snd_pcm_running(substream))
-		substream->ops->trigger(substream, SNDRV_PCM_TRIGGER_STOP);
+	if (substream->runtime->trigger_master == substream) {
+		switch(substream->runtime->status->state) {
+		case SNDRV_PCM_STATE_STARTING:
+			snd_pcm_startat_cancel(substream);
+			break;
+		case SNDRV_PCM_STATE_RUNNING:
+		case SNDRV_PCM_STATE_DRAINING:
+			substream->ops->trigger(substream,
+				SNDRV_PCM_TRIGGER_STOP);
+			break;
+		default:
+			break;
+		}
+	}
+
 	return 0; /* unconditonally stop all substreams */
 }
 
@@ -1167,11 +1363,13 @@ int snd_pcm_drain_done(struct snd_pcm_substream *substream)
  */
 int snd_pcm_stop_xrun(struct snd_pcm_substream *substream)
 {
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	unsigned long flags;
 	int ret = 0;
 
 	snd_pcm_stream_lock_irqsave(substream, flags);
-	if (snd_pcm_running(substream))
+	if (snd_pcm_running(substream) ||
+			runtime->status->state == SNDRV_PCM_STATE_STARTING)
 		ret = snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
 	snd_pcm_stream_unlock_irqrestore(substream, flags);
 	return ret;
@@ -1257,7 +1455,8 @@ static int snd_pcm_pause(struct snd_pcm_substream *substream, int push)
 static int snd_pcm_pre_suspend(struct snd_pcm_substream *substream, int state)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
-	if (runtime->status->state == SNDRV_PCM_STATE_SUSPENDED)
+	if ((runtime->status->state == SNDRV_PCM_STATE_SUSPENDED) ||
+			(runtime->status->state == SNDRV_PCM_STATE_STARTING))
 		return -EBUSY;
 	runtime->trigger_master = substream;
 	return 0;
@@ -1355,6 +1554,8 @@ static int snd_pcm_pre_resume(struct snd_pcm_substream *substream, int state)
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	if (!(runtime->info & SNDRV_PCM_INFO_RESUME))
 		return -ENOSYS;
+	if (runtime->status->state == SNDRV_PCM_STATE_STARTING)
+		return -EBUSY;
 	runtime->trigger_master = substream;
 	return 0;
 }
@@ -1439,6 +1640,7 @@ static int snd_pcm_xrun(struct snd_pcm_substream *substream)
 		result = 0;	/* already there */
 		break;
 	case SNDRV_PCM_STATE_RUNNING:
+	case SNDRV_PCM_STATE_STARTING:
 		result = snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
 		break;
 	default:
@@ -1458,6 +1660,7 @@ static int snd_pcm_pre_reset(struct snd_pcm_substream *substream, int state)
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	switch (runtime->status->state) {
 	case SNDRV_PCM_STATE_RUNNING:
+	case SNDRV_PCM_STATE_STARTING:
 	case SNDRV_PCM_STATE_PREPARED:
 	case SNDRV_PCM_STATE_PAUSED:
 	case SNDRV_PCM_STATE_SUSPENDED:
@@ -1512,7 +1715,8 @@ static int snd_pcm_pre_prepare(struct snd_pcm_substream *substream,
 	if (runtime->status->state == SNDRV_PCM_STATE_OPEN ||
 	    runtime->status->state == SNDRV_PCM_STATE_DISCONNECTED)
 		return -EBADFD;
-	if (snd_pcm_running(substream))
+	if (snd_pcm_running(substream) ||
+	    runtime->status->state == SNDRV_PCM_STATE_STARTING)
 		return -EBUSY;
 	substream->f_flags = f_flags;
 	return 0;
@@ -1578,6 +1782,7 @@ static int snd_pcm_pre_drain_init(struct snd_pcm_substream *substream, int state
 	case SNDRV_PCM_STATE_OPEN:
 	case SNDRV_PCM_STATE_DISCONNECTED:
 	case SNDRV_PCM_STATE_SUSPENDED:
+	case SNDRV_PCM_STATE_STARTING:
 		return -EBADFD;
 	}
 	runtime->trigger_master = substream;
@@ -1782,6 +1987,7 @@ static int snd_pcm_drop(struct snd_pcm_substream *substream)
 		snd_pcm_pause(substream, 0);
 
 	snd_pcm_stop(substream, SNDRV_PCM_STATE_SETUP);
+
 	/* runtime->control->appl_ptr = runtime->status->hw_ptr; */
 	snd_pcm_stream_unlock_irq(substream);
 
@@ -2234,6 +2440,7 @@ void snd_pcm_release_substream(struct snd_pcm_substream *substream)
 		return;
 
 	snd_pcm_drop(substream);
+
 	if (substream->hw_opened) {
 		if (substream->ops->hw_free &&
 		    substream->runtime->status->state != SNDRV_PCM_STATE_OPEN)
@@ -2441,6 +2648,7 @@ static snd_pcm_sframes_t snd_pcm_playback_rewind(struct snd_pcm_substream *subst
 	snd_pcm_stream_lock_irq(substream);
 	switch (runtime->status->state) {
 	case SNDRV_PCM_STATE_PREPARED:
+	case SNDRV_PCM_STATE_STARTING:
 		break;
 	case SNDRV_PCM_STATE_DRAINING:
 	case SNDRV_PCM_STATE_RUNNING:
@@ -2490,6 +2698,7 @@ static snd_pcm_sframes_t snd_pcm_capture_rewind(struct snd_pcm_substream *substr
 	switch (runtime->status->state) {
 	case SNDRV_PCM_STATE_PREPARED:
 	case SNDRV_PCM_STATE_DRAINING:
+	case SNDRV_PCM_STATE_STARTING:
 		break;
 	case SNDRV_PCM_STATE_RUNNING:
 		if (snd_pcm_update_hw_ptr(substream) >= 0)
@@ -2538,6 +2747,7 @@ static snd_pcm_sframes_t snd_pcm_playback_forward(struct snd_pcm_substream *subs
 	switch (runtime->status->state) {
 	case SNDRV_PCM_STATE_PREPARED:
 	case SNDRV_PCM_STATE_PAUSED:
+	case SNDRV_PCM_STATE_STARTING:
 		break;
 	case SNDRV_PCM_STATE_DRAINING:
 	case SNDRV_PCM_STATE_RUNNING:
@@ -2588,6 +2798,7 @@ static snd_pcm_sframes_t snd_pcm_capture_forward(struct snd_pcm_substream *subst
 	case SNDRV_PCM_STATE_PREPARED:
 	case SNDRV_PCM_STATE_DRAINING:
 	case SNDRV_PCM_STATE_PAUSED:
+	case SNDRV_PCM_STATE_STARTING:
 		break;
 	case SNDRV_PCM_STATE_RUNNING:
 		if (snd_pcm_update_hw_ptr(substream) >= 0)
@@ -2638,6 +2849,7 @@ static int snd_pcm_hwsync(struct snd_pcm_substream *substream)
 		/* Fall through */
 	case SNDRV_PCM_STATE_PREPARED:
 	case SNDRV_PCM_STATE_SUSPENDED:
+	case SNDRV_PCM_STATE_STARTING:
 		err = 0;
 		break;
 	case SNDRV_PCM_STATE_XRUN:
@@ -2671,6 +2883,7 @@ static int snd_pcm_delay(struct snd_pcm_substream *substream,
 		/* Fall through */
 	case SNDRV_PCM_STATE_PREPARED:
 	case SNDRV_PCM_STATE_SUSPENDED:
+	case SNDRV_PCM_STATE_STARTING:
 		err = 0;
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 			n = snd_pcm_playback_hw_avail(runtime);
@@ -2781,6 +2994,8 @@ static int snd_pcm_common_ioctl1(struct file *file,
 		return snd_pcm_action_lock_irq(&snd_pcm_action_start, substream, SNDRV_PCM_STATE_RUNNING);
 	case SNDRV_PCM_IOCTL_LINK:
 		return snd_pcm_link(substream, (int)(unsigned long) arg);
+	case SNDRV_PCM_IOCTL_START_AT:
+		return snd_pcm_start_at(substream, arg);
 	case SNDRV_PCM_IOCTL_UNLINK:
 		return snd_pcm_unlink(substream);
 	case SNDRV_PCM_IOCTL_RESUME:
@@ -3172,6 +3387,7 @@ static unsigned int snd_pcm_playback_poll(struct file *file, poll_table * wait)
 	case SNDRV_PCM_STATE_RUNNING:
 	case SNDRV_PCM_STATE_PREPARED:
 	case SNDRV_PCM_STATE_PAUSED:
+	case SNDRV_PCM_STATE_STARTING:
 		if (avail >= runtime->control->avail_min) {
 			mask = POLLOUT | POLLWRNORM;
 			break;
@@ -3209,6 +3425,7 @@ static unsigned int snd_pcm_capture_poll(struct file *file, poll_table * wait)
 	avail = snd_pcm_capture_avail(runtime);
 	switch (runtime->status->state) {
 	case SNDRV_PCM_STATE_RUNNING:
+	case SNDRV_PCM_STATE_STARTING:
 	case SNDRV_PCM_STATE_PREPARED:
 	case SNDRV_PCM_STATE_PAUSED:
 		if (avail >= runtime->control->avail_min) {
diff --git a/sound/soc/Kconfig b/sound/soc/Kconfig
index 7ff7d88..a012b26 100644
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -50,6 +50,7 @@ source "sound/soc/jz4740/Kconfig"
 source "sound/soc/nuc900/Kconfig"
 source "sound/soc/omap/Kconfig"
 source "sound/soc/kirkwood/Kconfig"
+source "sound/soc/img/Kconfig"
 source "sound/soc/intel/Kconfig"
 source "sound/soc/mediatek/Kconfig"
 source "sound/soc/mxs/Kconfig"
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index 8eb06db..78625fa 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -27,6 +27,7 @@ obj-$(CONFIG_SND_SOC)	+= davinci/
 obj-$(CONFIG_SND_SOC)	+= dwc/
 obj-$(CONFIG_SND_SOC)	+= fsl/
 obj-$(CONFIG_SND_SOC)	+= jz4740/
+obj-$(CONFIG_SND_SOC)	+= img/
 obj-$(CONFIG_SND_SOC)	+= intel/
 obj-$(CONFIG_SND_SOC)	+= mediatek/
 obj-$(CONFIG_SND_SOC)	+= mxs/
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index cfdafc4..c0b2e5f 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -85,6 +85,10 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_PCM1681 if I2C
 	select SND_SOC_PCM1792A if SPI_MASTER
 	select SND_SOC_PCM3008
+	select SND_SOC_PCM3060_I2C if I2C
+	select SND_SOC_PCM3060_SPI if SPI_MASTER
+	select SND_SOC_PCM3168A_I2C if I2C
+	select SND_SOC_PCM3168A_SPI if SPI_MASTER
 	select SND_SOC_PCM512x_I2C if I2C
 	select SND_SOC_PCM512x_SPI if SPI_MASTER
 	select SND_SOC_RT286 if I2C
@@ -506,6 +510,28 @@ config SND_SOC_PCM1792A
 config SND_SOC_PCM3008
        tristate
 
+config SND_SOC_PCM3060
+	tristate
+
+config SND_SOC_PCM3060_SPI
+	tristate
+	select SND_SOC_PCM3060
+
+config SND_SOC_PCM3060_I2C
+	tristate
+	select SND_SOC_PCM3060
+
+config SND_SOC_PCM3168A
+	tristate
+
+config SND_SOC_PCM3168A_SPI
+	tristate
+	select SND_SOC_PCM3168A
+
+config SND_SOC_PCM3168A_I2C
+	tristate
+	select SND_SOC_PCM3168A
+
 config SND_SOC_PCM512x
 	tristate
 
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index f632fc4..1f944ec 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -78,6 +78,12 @@ snd-soc-nau8825-objs := nau8825.o
 snd-soc-pcm1681-objs := pcm1681.o
 snd-soc-pcm1792a-codec-objs := pcm1792a.o
 snd-soc-pcm3008-objs := pcm3008.o
+snd-soc-pcm3060-objs := pcm3060.o
+snd-soc-pcm3060-i2c-objs := pcm3060-i2c.o
+snd-soc-pcm3060-spi-objs := pcm3060-spi.o
+snd-soc-pcm3168a-objs := pcm3168a.o
+snd-soc-pcm3168a-i2c-objs := pcm3168a-i2c.o
+snd-soc-pcm3168a-spi-objs := pcm3168a-spi.o
 snd-soc-pcm512x-objs := pcm512x.o
 snd-soc-pcm512x-i2c-objs := pcm512x-i2c.o
 snd-soc-pcm512x-spi-objs := pcm512x-spi.o
@@ -273,6 +279,12 @@ obj-$(CONFIG_SND_SOC_NAU8825)   += snd-soc-nau8825.o
 obj-$(CONFIG_SND_SOC_PCM1681)	+= snd-soc-pcm1681.o
 obj-$(CONFIG_SND_SOC_PCM1792A)	+= snd-soc-pcm1792a-codec.o
 obj-$(CONFIG_SND_SOC_PCM3008)	+= snd-soc-pcm3008.o
+obj-$(CONFIG_SND_SOC_PCM3060)	+= snd-soc-pcm3060.o
+obj-$(CONFIG_SND_SOC_PCM3060_I2C)	+= snd-soc-pcm3060-i2c.o
+obj-$(CONFIG_SND_SOC_PCM3060_SPI)	+= snd-soc-pcm3060-spi.o
+obj-$(CONFIG_SND_SOC_PCM3168A)	+= snd-soc-pcm3168a.o
+obj-$(CONFIG_SND_SOC_PCM3168A_I2C)	+= snd-soc-pcm3168a-i2c.o
+obj-$(CONFIG_SND_SOC_PCM3168A_SPI)	+= snd-soc-pcm3168a-spi.o
 obj-$(CONFIG_SND_SOC_PCM512x)	+= snd-soc-pcm512x.o
 obj-$(CONFIG_SND_SOC_PCM512x_I2C)	+= snd-soc-pcm512x-i2c.o
 obj-$(CONFIG_SND_SOC_PCM512x_SPI)	+= snd-soc-pcm512x-spi.o
diff --git a/sound/soc/codecs/pcm3060-i2c.c b/sound/soc/codecs/pcm3060-i2c.c
new file mode 100644
index 0000000..a143703
--- /dev/null
+++ b/sound/soc/codecs/pcm3060-i2c.c
@@ -0,0 +1,66 @@
+/*
+ * PCM3060 codec i2c driver
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/module.h>
+
+#include <sound/soc.h>
+
+#include "pcm3060.h"
+
+static int pcm3060_i2c_probe(struct i2c_client *i2c,
+			     const struct i2c_device_id *id)
+{
+	struct regmap *regmap;
+
+	regmap = devm_regmap_init_i2c(i2c, &pcm3060_regmap);
+	if (IS_ERR(regmap))
+		return PTR_ERR(regmap);
+
+	return pcm3060_probe(&i2c->dev, regmap);
+}
+
+static int pcm3060_i2c_remove(struct i2c_client *i2c)
+{
+	pcm3060_remove(&i2c->dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id pcm3060_i2c_id[] = {
+	{ "pcm3060", },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, pcm3060_i2c_id);
+
+static const struct of_device_id pcm3060_of_match[] = {
+	{ .compatible = "ti,pcm3060", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, pcm3060_of_match);
+
+static struct i2c_driver pcm3060_i2c_driver = {
+	.probe		= pcm3060_i2c_probe,
+	.remove		= pcm3060_i2c_remove,
+	.id_table	= pcm3060_i2c_id,
+	.driver		= {
+		.name	= "pcm3060",
+		.of_match_table = pcm3060_of_match,
+		.pm		= &pcm3060_pm_ops,
+	},
+};
+module_i2c_driver(pcm3060_i2c_driver);
+
+MODULE_DESCRIPTION("PCM3060 I2C codec driver");
+MODULE_AUTHOR("Damien Horsley <Damien.Horsley@imgtec.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/codecs/pcm3060-spi.c b/sound/soc/codecs/pcm3060-spi.c
new file mode 100644
index 0000000..c8831ae
--- /dev/null
+++ b/sound/soc/codecs/pcm3060-spi.c
@@ -0,0 +1,65 @@
+/*
+ * PCM3060 codec spi driver
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/spi/spi.h>
+
+#include <sound/soc.h>
+
+#include "pcm3060.h"
+
+static int pcm3060_spi_probe(struct spi_device *spi)
+{
+	struct regmap *regmap;
+
+	regmap = devm_regmap_init_spi(spi, &pcm3060_regmap);
+	if (IS_ERR(regmap))
+		return PTR_ERR(regmap);
+
+	return pcm3060_probe(&spi->dev, regmap);
+}
+
+static int pcm3060_spi_remove(struct spi_device *spi)
+{
+	pcm3060_remove(&spi->dev);
+
+	return 0;
+}
+
+static const struct spi_device_id pcm3060_spi_id[] = {
+	{ "pcm3060", },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, pcm3060_spi_id);
+
+static const struct of_device_id pcm3060_of_match[] = {
+	{ .compatible = "ti,pcm3060", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, pcm3060_of_match);
+
+static struct spi_driver pcm3060_spi_driver = {
+	.probe		= pcm3060_spi_probe,
+	.remove		= pcm3060_spi_remove,
+	.id_table	= pcm3060_spi_id,
+	.driver = {
+		.name	= "pcm3060",
+		.of_match_table = pcm3060_of_match,
+		.pm		= &pcm3060_pm_ops,
+	},
+};
+module_spi_driver(pcm3060_spi_driver);
+
+MODULE_DESCRIPTION("PCM3060 SPI codec driver");
+MODULE_AUTHOR("Damien Horsley <Damien.Horsley@imgtec.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/codecs/pcm3060.c b/sound/soc/codecs/pcm3060.c
new file mode 100644
index 0000000..e92ac0a
--- /dev/null
+++ b/sound/soc/codecs/pcm3060.c
@@ -0,0 +1,636 @@
+/*
+ * PCM3060 codec driver
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+
+#include "pcm3060.h"
+
+#define PCM3060_FORMATS (SNDRV_PCM_FMTBIT_S24_3LE | \
+			 SNDRV_PCM_FMTBIT_S24_LE |  \
+			 SNDRV_PCM_FMTBIT_S32_LE)
+
+#define PCM3060_FMT_I2S		0x0
+#define PCM3060_FMT_LEFT_J	0x1
+#define PCM3060_FMT_RIGHT_J	0x2
+
+#define PCM3060_NUM_SUPPLIES 2
+static const char *const pcm3060_supply_names[PCM3060_NUM_SUPPLIES] = {
+	"VCC",
+	"VDD"
+};
+
+struct pcm3060_priv {
+	struct regulator_bulk_data supplies[PCM3060_NUM_SUPPLIES];
+	struct regmap *regmap;
+	struct clk *scki_dac;
+	struct clk *scki_adc;
+	bool adc_slave_mode;
+	bool dac_slave_mode;
+	unsigned long sysclk_dac;
+	unsigned long sysclk_adc;
+	unsigned int adc_fmt;
+	unsigned int dac_fmt;
+};
+
+static const char *const pcm3060_over_mult[] = { "1", "2" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3060_dac_over_mult, PCM3060_DAC_OV_PH_MUTE,
+		PCM3060_DAC_OVER_SHIFT, pcm3060_over_mult);
+
+static const char *const pcm3060_roll_off[] = { "Sharp", "Slow" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3060_dac_roll_off, PCM3060_DAC_FLT_DEMP_Z,
+		PCM3060_DAC_FLT_SHIFT, pcm3060_roll_off);
+
+static const char *const pcm3060_demp[] = { "44.1khz", "48khz", "32khz" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3060_dac_demp, PCM3060_DAC_FLT_DEMP_Z,
+		PCM3060_DAC_DMF_SHIFT, pcm3060_demp);
+
+static const char *const pcm3060_zf_func[] = { "Individual", "Joined" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3060_dac_zf_func, PCM3060_DAC_FLT_DEMP_Z,
+		PCM3060_DAC_AZRO_SHIFT, pcm3060_zf_func);
+
+static const char *const pcm3060_pol[] = { "Active High", "Active Low" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3060_dac_zf_pol, PCM3060_DAC_FLT_DEMP_Z,
+		PCM3060_DAC_ZREV_SHIFT, pcm3060_pol);
+
+static const char *const pcm3060_con[] = { "Differential", "Single-Ended" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3060_dac_con, PCM3060_RST_PWR_SE,
+		PCM3060_SE_SHIFT, pcm3060_con);
+
+/* -100db to 0db, register values 0-54 cause mute */
+static const DECLARE_TLV_DB_SCALE(pcm3060_dac_tlv, -10050, 50, 1);
+
+/* -100db to 20db, register values 0-14 cause mute */
+static const DECLARE_TLV_DB_SCALE(pcm3060_adc_tlv, -10050, 50, 1);
+
+static const struct snd_kcontrol_new pcm3060_snd_controls[] = {
+	SOC_ENUM("DAC Connection Type", pcm3060_dac_con),
+	SOC_DOUBLE_R_RANGE_TLV("DAC Playback Volume",
+			PCM3060_DAC_VOL_L, PCM3060_DAC_VOL_R,
+			0, 54, 255, 0, pcm3060_dac_tlv),
+	SOC_ENUM("DAC Oversampling Rate Multiplier", pcm3060_dac_over_mult),
+	SOC_SINGLE("DAC Invert Switch", PCM3060_DAC_OV_PH_MUTE,
+			PCM3060_DAC_DREV_SHIFT, 1, 0),
+	SOC_ENUM("DAC Digital Filter roll-off", pcm3060_dac_roll_off),
+	SOC_SINGLE("DAC De-Emphasis Switch", PCM3060_DAC_FLT_DEMP_Z,
+			PCM3060_DAC_DMC_SHIFT, 1, 0),
+	SOC_ENUM("DAC De-Emphasis Type", pcm3060_dac_demp),
+	SOC_ENUM("DAC Zero Flag Polarity", pcm3060_dac_zf_pol),
+	SOC_ENUM("DAC Zero Flag Function", pcm3060_dac_zf_func),
+	SOC_DOUBLE_R_RANGE_TLV("ADC Capture Volume",
+			PCM3060_ADC_VOL_L, PCM3060_ADC_VOL_R,
+			0, 14, 255, 0, pcm3060_adc_tlv),
+	SOC_SINGLE("ADC Zero-Cross Detection Switch", PCM3060_ADC_OPT,
+			PCM3060_ADC_ZCDD_SHIFT, 1, 1),
+	SOC_SINGLE("ADC High-Pass Filter Switch", PCM3060_ADC_OPT,
+			PCM3060_ADC_BYP_SHIFT, 1, 1),
+	SOC_SINGLE("ADC Invert Switch", PCM3060_ADC_OPT,
+			PCM3060_ADC_DREV_SHIFT, 1, 0),
+	SOC_DOUBLE("ADC Mute Switch", PCM3060_ADC_OPT,
+			PCM3060_ADC_MUTE_L_SHIFT, PCM3060_ADC_MUTE_R_SHIFT,
+			1, 0),
+};
+
+static const struct snd_soc_dapm_widget pcm3060_dapm_widgets[] = {
+	SND_SOC_DAPM_DAC("DAC", "Playback", PCM3060_RST_PWR_SE,
+			PCM3060_DAPSV_SHIFT, 1),
+
+	SND_SOC_DAPM_OUTPUT("AOUTL"),
+	SND_SOC_DAPM_OUTPUT("AOUTR"),
+
+	SND_SOC_DAPM_ADC("ADC", "Capture", PCM3060_RST_PWR_SE,
+			PCM3060_ADPSV_SHIFT, 1),
+
+	SND_SOC_DAPM_INPUT("AINL"),
+	SND_SOC_DAPM_INPUT("AINR"),
+};
+
+static const struct snd_soc_dapm_route pcm3060_dapm_routes[] = {
+	/* Playback */
+	{ "AOUTL", NULL, "DAC" },
+	{ "AOUTR", NULL, "DAC" },
+
+	/* Capture */
+	{ "ADC", NULL, "AINL" },
+	{ "ADC", NULL, "AINR" },
+};
+
+static unsigned int pcm3060_scki_ratios[] = {
+	768,
+	512,
+	384,
+	256,
+	192,
+	128
+};
+
+#define PCM3060_NUM_SCKI_RATIOS_DAC	ARRAY_SIZE(pcm3060_scki_ratios)
+#define PCM3060_NUM_SCKI_RATIOS_ADC	(ARRAY_SIZE(pcm3060_scki_ratios) - 2)
+
+#define PCM1368A_MAX_SYSCLK	36864000
+
+static int pcm3060_reset(struct pcm3060_priv *pcm3060)
+{
+	int ret;
+	u32 mask = PCM3060_MRST_MASK | PCM3060_SRST_MASK;
+	unsigned long sysclk = min(pcm3060->sysclk_dac, pcm3060->sysclk_adc);
+
+	ret = regmap_update_bits(pcm3060->regmap, PCM3060_RST_PWR_SE, mask, 0);
+	if (ret)
+		return ret;
+
+	/* Internal reset is de-asserted after 1024 cycles of both SCKIs */
+	msleep(DIV_ROUND_UP(1024 * 1000, sysclk));
+
+	return regmap_update_bits(pcm3060->regmap, PCM3060_RST_PWR_SE,
+				mask, mask);
+}
+
+static int pcm3060_digital_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct pcm3060_priv *pcm3060 = snd_soc_codec_get_drvdata(dai->codec);
+	u32 mask = PCM3060_DAC_MUTE_R_MASK | PCM3060_DAC_MUTE_L_MASK;
+
+	regmap_update_bits(pcm3060->regmap, PCM3060_DAC_OV_PH_MUTE,
+			mask, mute ? mask : 0);
+
+	return 0;
+}
+
+static int pcm3060_set_dai_sysclk_dac(struct snd_soc_dai *dai,
+				  int clk_id, unsigned int freq, int dir)
+{
+	struct pcm3060_priv *pcm3060 = snd_soc_codec_get_drvdata(dai->codec);
+
+	if (freq > PCM1368A_MAX_SYSCLK)
+		return -EINVAL;
+
+	pcm3060->sysclk_dac = freq;
+
+	return 0;
+}
+
+static int pcm3060_set_dai_sysclk_adc(struct snd_soc_dai *dai,
+				  int clk_id, unsigned int freq, int dir)
+{
+	struct pcm3060_priv *pcm3060 = snd_soc_codec_get_drvdata(dai->codec);
+
+	if (freq > PCM1368A_MAX_SYSCLK)
+		return -EINVAL;
+
+	pcm3060->sysclk_adc = freq;
+
+	return 0;
+}
+
+static int pcm3060_set_dai_fmt(struct snd_soc_dai *dai,
+			       unsigned int format, bool dac)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct pcm3060_priv *pcm3060 = snd_soc_codec_get_drvdata(codec);
+	u32 fmt, reg, mask, shift;
+	bool slave_mode;
+
+	switch (format & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_LEFT_J:
+		fmt = PCM3060_FMT_LEFT_J;
+		break;
+	case SND_SOC_DAIFMT_I2S:
+		fmt = PCM3060_FMT_I2S;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		fmt = PCM3060_FMT_RIGHT_J;
+		break;
+	default:
+		dev_err(codec->dev, "unsupported dai format\n");
+		return -EINVAL;
+	}
+
+	switch (format & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		slave_mode = true;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		slave_mode = false;
+		break;
+	default:
+		dev_err(codec->dev, "unsupported master/slave mode\n");
+		return -EINVAL;
+	}
+
+	switch (format & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	default:
+		dev_err(codec->dev, "LRCLK/BCLK inversion not supported\n");
+		return -EINVAL;
+	}
+
+	if (dac) {
+		reg = PCM3060_DAC_FMT;
+		mask = PCM3060_DAC_FMT_MASK;
+		shift = PCM3060_DAC_FMT_SHIFT;
+		pcm3060->dac_slave_mode = slave_mode;
+		pcm3060->dac_fmt = fmt;
+	} else {
+		reg = PCM3060_ADC_FMT;
+		mask = PCM3060_ADC_FMT_MASK;
+		shift = PCM3060_ADC_FMT_SHIFT;
+		pcm3060->adc_slave_mode = slave_mode;
+		pcm3060->adc_fmt = fmt;
+	}
+
+	regmap_update_bits(pcm3060->regmap, reg, mask, fmt << shift);
+
+	return 0;
+}
+
+static int pcm3060_set_dai_fmt_dac(struct snd_soc_dai *dai,
+			       unsigned int format)
+{
+	return pcm3060_set_dai_fmt(dai, format, true);
+}
+
+static int pcm3060_set_dai_fmt_adc(struct snd_soc_dai *dai,
+			       unsigned int format)
+{
+	return pcm3060_set_dai_fmt(dai, format, false);
+}
+
+static int pcm3060_hw_params(struct snd_pcm_substream *substream,
+			     struct snd_pcm_hw_params *params,
+			     struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct pcm3060_priv *pcm3060 = snd_soc_codec_get_drvdata(codec);
+	u32 val, mask, shift, reg;
+	bool slave_mode, tx;
+	unsigned int fmt, rate, channels, max_ratio, ratio;
+	int i;
+	snd_pcm_format_t format;
+
+	rate = params_rate(params);
+	format = params_format(params);
+	channels = params_channels(params);
+
+	tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
+	if (tx) {
+		max_ratio = PCM3060_NUM_SCKI_RATIOS_DAC;
+		reg = PCM3060_DAC_FMT;
+		mask = PCM3060_DAC_MS_MASK;
+		shift = PCM3060_DAC_MS_SHIFT;
+		ratio = pcm3060->sysclk_dac / rate;
+		slave_mode = pcm3060->dac_slave_mode;
+		fmt = pcm3060->dac_fmt;
+	} else {
+		max_ratio = PCM3060_NUM_SCKI_RATIOS_ADC;
+		reg = PCM3060_ADC_FMT;
+		mask = PCM3060_ADC_MS_MASK;
+		shift = PCM3060_ADC_MS_SHIFT;
+		ratio = pcm3060->sysclk_adc / rate;
+		slave_mode = pcm3060->adc_slave_mode;
+		fmt = pcm3060->adc_fmt;
+	}
+
+	for (i = 0; i < max_ratio; i++) {
+		if (pcm3060_scki_ratios[i] == ratio)
+			break;
+	}
+
+	if (i == max_ratio) {
+		dev_err(codec->dev, "unsupported sysclk ratio\n");
+		return -EINVAL;
+	}
+
+	if (!slave_mode && (format == SNDRV_PCM_FORMAT_S24_3LE)) {
+		dev_err(codec->dev,
+			"48-bit frames not supported in master mode\n");
+		return -EINVAL;
+	}
+
+	val = slave_mode ? 0 : ((i + 1) << shift);
+
+	regmap_update_bits(pcm3060->regmap, reg, mask, val);
+
+	if (tx) {
+		mask = PCM3060_DAC_FMT_MASK;
+		shift = PCM3060_DAC_FMT_SHIFT;
+	} else {
+		mask = PCM3060_ADC_FMT_MASK;
+		shift = PCM3060_ADC_FMT_SHIFT;
+	}
+
+	if ((fmt == PCM3060_FMT_RIGHT_J) && (format == SNDRV_PCM_FORMAT_S32)) {
+		/*
+		 * Justification has no effect here as the whole frame
+		 * is filled with the samples, but the register field
+		 * must be set to left justified for correct operation
+		 */
+		fmt = PCM3060_FMT_LEFT_J;
+	}
+
+	regmap_update_bits(pcm3060->regmap, reg, mask, fmt << shift);
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops pcm3060_dac_dai_ops = {
+	.set_fmt	= pcm3060_set_dai_fmt_dac,
+	.set_sysclk	= pcm3060_set_dai_sysclk_dac,
+	.hw_params	= pcm3060_hw_params,
+	.digital_mute	= pcm3060_digital_mute,
+};
+
+static const struct snd_soc_dai_ops pcm3060_adc_dai_ops = {
+	.set_fmt	= pcm3060_set_dai_fmt_adc,
+	.set_sysclk	= pcm3060_set_dai_sysclk_adc,
+	.hw_params	= pcm3060_hw_params,
+};
+
+static struct snd_soc_dai_driver pcm3060_dais[] = {
+	{
+		.name = "pcm3060-dac",
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = SNDRV_PCM_RATE_8000_192000,
+			.formats = PCM3060_FORMATS,
+		},
+		.ops = &pcm3060_dac_dai_ops,
+	},
+	{
+		.name = "pcm3060-adc",
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = SNDRV_PCM_RATE_8000_96000,
+			.formats = PCM3060_FORMATS,
+		},
+		.ops = &pcm3060_adc_dai_ops,
+	},
+};
+
+static const struct reg_default pcm3060_reg_default[] = {
+	{ PCM3060_RST_PWR_SE, PCM3060_MRST_MASK | PCM3060_SRST_MASK |
+			PCM3060_ADPSV_MASK | PCM3060_DAPSV_MASK },
+	{ PCM3060_DAC_VOL_L, 0xff },
+	{ PCM3060_DAC_VOL_R, 0xff },
+	{ PCM3060_DAC_FMT, 0x00 },
+	{ PCM3060_DAC_OV_PH_MUTE, 0x00 },
+	{ PCM3060_DAC_FLT_DEMP_Z, 0x00 },
+	{ PCM3060_ADC_VOL_L, 0xd7 },
+	{ PCM3060_ADC_VOL_R, 0xd7 },
+	{ PCM3060_ADC_FMT, 0x00 },
+	{ PCM3060_ADC_OPT, 0x00 },
+};
+
+static bool pcm3060_volatile_register(struct device *dev, unsigned int reg)
+{
+	return false;
+}
+
+static bool pcm3060_readable_register(struct device *dev, unsigned int reg)
+{
+	if (reg >= PCM3060_RST_PWR_SE)
+		return true;
+	else
+		return false;
+}
+
+static bool pcm3060_writeable_register(struct device *dev, unsigned int reg)
+{
+	if (reg >= PCM3060_RST_PWR_SE)
+		return true;
+	else
+		return false;
+}
+
+const struct regmap_config pcm3060_regmap = {
+	.reg_bits = 8,
+	.val_bits = 8,
+
+	.max_register = PCM3060_ADC_OPT,
+	.reg_defaults = pcm3060_reg_default,
+	.num_reg_defaults = ARRAY_SIZE(pcm3060_reg_default),
+	.readable_reg = pcm3060_readable_register,
+	.volatile_reg = pcm3060_volatile_register,
+	.writeable_reg = pcm3060_writeable_register,
+	.cache_type = REGCACHE_FLAT,
+};
+EXPORT_SYMBOL_GPL(pcm3060_regmap);
+
+static const struct snd_soc_codec_driver pcm3060_driver = {
+	.controls = pcm3060_snd_controls,
+	.num_controls = ARRAY_SIZE(pcm3060_snd_controls),
+	.dapm_widgets = pcm3060_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(pcm3060_dapm_widgets),
+	.dapm_routes = pcm3060_dapm_routes,
+	.num_dapm_routes = ARRAY_SIZE(pcm3060_dapm_routes),
+};
+
+int pcm3060_probe(struct device *dev, struct regmap *regmap)
+{
+	struct pcm3060_priv *pcm3060;
+	int ret, i;
+
+	pcm3060 = devm_kzalloc(dev, sizeof(*pcm3060), GFP_KERNEL);
+	if (pcm3060 == NULL)
+		return -ENOMEM;
+
+	dev_set_drvdata(dev, pcm3060);
+
+	pcm3060->scki_dac = devm_clk_get(dev, "sckid");
+	if (IS_ERR(pcm3060->scki_dac)) {
+		dev_err(dev, "failed to get the clock (dac): %ld\n",
+				PTR_ERR(pcm3060->scki_dac));
+		return PTR_ERR(pcm3060->scki_dac);
+	}
+
+	ret = clk_prepare_enable(pcm3060->scki_dac);
+	if (ret) {
+		dev_err(dev, "failed to enable mclk (dac): %d\n", ret);
+		return ret;
+	}
+
+	pcm3060->sysclk_dac = clk_get_rate(pcm3060->scki_dac);
+
+	pcm3060->scki_adc = devm_clk_get(dev, "sckia");
+	if (IS_ERR(pcm3060->scki_adc)) {
+		dev_err(dev, "failed to get the clock (adc): %ld\n",
+				PTR_ERR(pcm3060->scki_adc));
+		ret = PTR_ERR(pcm3060->scki_adc);
+		goto err_clk;
+	}
+
+	ret = clk_prepare_enable(pcm3060->scki_adc);
+	if (ret) {
+		dev_err(dev, "failed to enable mclk (adc): %d\n", ret);
+		goto err_clk;
+	}
+
+	pcm3060->sysclk_adc = clk_get_rate(pcm3060->scki_adc);
+
+	for (i = 0; i < ARRAY_SIZE(pcm3060->supplies); i++)
+		pcm3060->supplies[i].supply = pcm3060_supply_names[i];
+
+	ret = devm_regulator_bulk_get(dev,
+			ARRAY_SIZE(pcm3060->supplies), pcm3060->supplies);
+	if (ret) {
+		dev_err(dev, "failed to request supplies: %d\n", ret);
+		goto err_clks;
+	}
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(pcm3060->supplies),
+				    pcm3060->supplies);
+	if (ret) {
+		dev_err(dev, "failed to enable supplies: %d\n", ret);
+		goto err_clks;
+	}
+
+	pcm3060->regmap = regmap;
+	if (IS_ERR(pcm3060->regmap)) {
+		ret = PTR_ERR(pcm3060->regmap);
+		dev_err(dev, "failed to allocate regmap: %d\n", ret);
+		goto err_regulator;
+	}
+
+	ret = pcm3060_reset(pcm3060);
+	if (ret) {
+		dev_err(dev, "Failed to reset device: %d\n", ret);
+		goto err_regulator;
+	}
+
+	ret = snd_soc_register_codec(dev, &pcm3060_driver, pcm3060_dais,
+			ARRAY_SIZE(pcm3060_dais));
+	if (ret) {
+		dev_err(dev, "failed to register codec:%d\n", ret);
+		goto err_regulator;
+	}
+
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_idle(dev);
+
+	return 0;
+
+err_regulator:
+	regulator_bulk_disable(ARRAY_SIZE(pcm3060->supplies),
+			pcm3060->supplies);
+err_clks:
+	clk_disable_unprepare(pcm3060->scki_adc);
+err_clk:
+	clk_disable_unprepare(pcm3060->scki_dac);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pcm3060_probe);
+
+void pcm3060_remove(struct device *dev)
+{
+	snd_soc_unregister_codec(dev);
+	pm_runtime_disable(dev);
+}
+EXPORT_SYMBOL_GPL(pcm3060_remove);
+
+#ifdef CONFIG_PM
+static int pcm3060_rt_resume(struct device *dev)
+{
+	struct pcm3060_priv *pcm3060 = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_prepare_enable(pcm3060->scki_dac);
+	if (ret) {
+		dev_err(dev, "failed to enable mclk (dac): %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(pcm3060->scki_adc);
+	if (ret) {
+		dev_err(dev, "failed to enable mclk (adc): %d\n", ret);
+		goto err_clk;
+	}
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(pcm3060->supplies),
+				    pcm3060->supplies);
+	if (ret) {
+		dev_err(dev, "failed to enable supplies: %d\n", ret);
+		goto err_clks;
+	}
+
+	ret = pcm3060_reset(pcm3060);
+	if (ret) {
+		dev_err(dev, "Failed to reset device: %d\n", ret);
+		goto err_regulator;
+	}
+
+	regcache_cache_only(pcm3060->regmap, false);
+
+	regcache_mark_dirty(pcm3060->regmap);
+
+	ret = regcache_sync(pcm3060->regmap);
+	if (ret) {
+		dev_err(dev, "failed to sync regmap: %d\n", ret);
+		goto err_regulator;
+	}
+
+	return 0;
+
+err_regulator:
+	regulator_bulk_disable(ARRAY_SIZE(pcm3060->supplies),
+			       pcm3060->supplies);
+err_clks:
+	clk_disable_unprepare(pcm3060->scki_adc);
+err_clk:
+	clk_disable_unprepare(pcm3060->scki_dac);
+
+	return ret;
+}
+
+static int pcm3060_rt_suspend(struct device *dev)
+{
+	struct pcm3060_priv *pcm3060 = dev_get_drvdata(dev);
+
+	regcache_cache_only(pcm3060->regmap, true);
+
+	regulator_bulk_disable(ARRAY_SIZE(pcm3060->supplies),
+			       pcm3060->supplies);
+
+	clk_disable_unprepare(pcm3060->scki_adc);
+	clk_disable_unprepare(pcm3060->scki_dac);
+
+	return 0;
+}
+#endif
+
+const struct dev_pm_ops pcm3060_pm_ops = {
+	SET_RUNTIME_PM_OPS(pcm3060_rt_suspend, pcm3060_rt_resume, NULL)
+};
+EXPORT_SYMBOL_GPL(pcm3060_pm_ops);
+
+MODULE_DESCRIPTION("PCM3060 codec driver");
+MODULE_AUTHOR("Damien Horsley <Damien.Horsley@imgtec.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/codecs/pcm3060.h b/sound/soc/codecs/pcm3060.h
new file mode 100644
index 0000000..1de2e6a
--- /dev/null
+++ b/sound/soc/codecs/pcm3060.h
@@ -0,0 +1,86 @@
+/*
+ * PCM3060 codec driver header
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#ifndef __PCM3060_H__
+#define __PCM3060_H__
+
+extern const struct dev_pm_ops pcm3060_pm_ops;
+extern const struct regmap_config pcm3060_regmap;
+
+extern int pcm3060_probe(struct device *dev, struct regmap *regmap);
+extern void pcm3060_remove(struct device *dev);
+
+#define PCM3060_RST_PWR_SE			0x40
+#define PCM3060_MRST_MASK			0x80
+#define PCM3060_SRST_MASK			0x40
+#define PCM3060_ADPSV_SHIFT			5
+#define PCM3060_ADPSV_MASK			0x20
+#define PCM3060_DAPSV_SHIFT			4
+#define PCM3060_DAPSV_MASK			0x10
+#define PCM3060_SE_SHIFT			0
+#define PCM3060_SE_MASK				0x01
+
+#define PCM3060_DAC_VOL_L			0x41
+
+#define PCM3060_DAC_VOL_R			0x42
+
+#define PCM3060_DAC_FMT				0x43
+#define PCM3060_DAC_CSEL_MASK			0x80
+#define PCM3060_DAC_MS_SHIFT			4
+#define PCM3060_DAC_MS_MASK			0x70
+#define PCM3060_DAC_FMT_SHIFT			0
+#define PCM3060_DAC_FMT_MASK			0x3
+
+#define PCM3060_DAC_OV_PH_MUTE			0x44
+#define PCM3060_DAC_OVER_SHIFT			6
+#define PCM3060_DAC_OVER_MASK			0x40
+#define PCM3060_DAC_DREV_SHIFT			2
+#define PCM3060_DAC_DREV_MASK			0x4
+#define PCM3060_DAC_MUTE_R_MASK			0x2
+#define PCM3060_DAC_MUTE_L_MASK			0x1
+
+#define PCM3060_DAC_FLT_DEMP_Z			0x45
+#define PCM3060_DAC_FLT_SHIFT			7
+#define PCM3060_DAC_FLT_MASK			0x80
+#define PCM3060_DAC_DMF_SHIFT			5
+#define PCM3060_DAC_DMF_MASK			0x60
+#define PCM3060_DAC_DMC_SHIFT			4
+#define PCM3060_DAC_DMC_MASK			0x10
+#define PCM3060_DAC_ZREV_SHIFT			1
+#define PCM3060_DAC_ZREV_MASK			0x2
+#define PCM3060_DAC_AZRO_SHIFT			0
+#define PCM3060_DAC_AZRO_MASK			0x1
+
+#define PCM3060_ADC_VOL_L			0x46
+
+#define PCM3060_ADC_VOL_R			0x47
+
+#define PCM3060_ADC_FMT				0x48
+#define PCM3060_ADC_CSEL_MASK			0x80
+#define PCM3060_ADC_MS_SHIFT			4
+#define PCM3060_ADC_MS_MASK			0x70
+#define PCM3060_ADC_FMT_SHIFT			0
+#define PCM3060_ADC_FMT_MASK			0x3
+
+#define PCM3060_ADC_OPT				0x49
+#define PCM3060_ADC_ZCDD_SHIFT			4
+#define PCM3060_ADC_ZCDD_MASK			0x10
+#define PCM3060_ADC_BYP_SHIFT			3
+#define PCM3060_ADC_BYP_MASK			0x8
+#define PCM3060_ADC_DREV_SHIFT			2
+#define PCM3060_ADC_DREV_MASK			0x4
+#define PCM3060_ADC_MUTE_R_SHIFT		1
+#define PCM3060_ADC_MUTE_R_MASK			0x2
+#define PCM3060_ADC_MUTE_L_SHIFT		0
+#define PCM3060_ADC_MUTE_L_MASK			0x1
+
+#endif
diff --git a/sound/soc/codecs/pcm3168a-i2c.c b/sound/soc/codecs/pcm3168a-i2c.c
new file mode 100644
index 0000000..c296d39
--- /dev/null
+++ b/sound/soc/codecs/pcm3168a-i2c.c
@@ -0,0 +1,66 @@
+/*
+ * PCM3168A codec i2c driver
+ *
+ * Copyright (C) 2014 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/module.h>
+
+#include <sound/soc.h>
+
+#include "pcm3168a.h"
+
+static int pcm3168a_i2c_probe(struct i2c_client *i2c,
+			     const struct i2c_device_id *id)
+{
+	struct regmap *regmap;
+
+	regmap = devm_regmap_init_i2c(i2c, &pcm3168a_regmap);
+	if (IS_ERR(regmap))
+		return PTR_ERR(regmap);
+
+	return pcm3168a_probe(&i2c->dev, regmap);
+}
+
+static int pcm3168a_i2c_remove(struct i2c_client *i2c)
+{
+	pcm3168a_remove(&i2c->dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id pcm3168a_i2c_id[] = {
+	{ "pcm3168a", },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, pcm3168a_i2c_id);
+
+static const struct of_device_id pcm3168a_of_match[] = {
+	{ .compatible = "ti,pcm3168a", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, pcm3168a_of_match);
+
+static struct i2c_driver pcm3168a_i2c_driver = {
+	.probe		= pcm3168a_i2c_probe,
+	.remove		= pcm3168a_i2c_remove,
+	.id_table	= pcm3168a_i2c_id,
+	.driver		= {
+		.name	= "pcm3168a",
+		.of_match_table = pcm3168a_of_match,
+		.pm		= &pcm3168a_pm_ops,
+	},
+};
+module_i2c_driver(pcm3168a_i2c_driver);
+
+MODULE_DESCRIPTION("PCM3168A I2C codec driver");
+MODULE_AUTHOR("Damien Horsley <Damien.Horsley@imgtec.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/codecs/pcm3168a-spi.c b/sound/soc/codecs/pcm3168a-spi.c
new file mode 100644
index 0000000..d351e5a
--- /dev/null
+++ b/sound/soc/codecs/pcm3168a-spi.c
@@ -0,0 +1,65 @@
+/*
+ * PCM3168A codec spi driver
+ *
+ * Copyright (C) 2014 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/spi/spi.h>
+
+#include <sound/soc.h>
+
+#include "pcm3168a.h"
+
+static int pcm3168a_spi_probe(struct spi_device *spi)
+{
+	struct regmap *regmap;
+
+	regmap = devm_regmap_init_spi(spi, &pcm3168a_regmap);
+	if (IS_ERR(regmap))
+		return PTR_ERR(regmap);
+
+	return pcm3168a_probe(&spi->dev, regmap);
+}
+
+static int pcm3168a_spi_remove(struct spi_device *spi)
+{
+	pcm3168a_remove(&spi->dev);
+
+	return 0;
+}
+
+static const struct spi_device_id pcm3168a_spi_id[] = {
+	{ "pcm3168a", },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, pcm3168a_spi_id);
+
+static const struct of_device_id pcm3168a_of_match[] = {
+	{ .compatible = "ti,pcm3168a", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, pcm3168a_of_match);
+
+static struct spi_driver pcm3168a_spi_driver = {
+	.probe		= pcm3168a_spi_probe,
+	.remove		= pcm3168a_spi_remove,
+	.id_table	= pcm3168a_spi_id,
+	.driver = {
+		.name	= "pcm3168a",
+		.of_match_table = pcm3168a_of_match,
+		.pm		= &pcm3168a_pm_ops,
+	},
+};
+module_spi_driver(pcm3168a_spi_driver);
+
+MODULE_DESCRIPTION("PCM3168A SPI codec driver");
+MODULE_AUTHOR("Damien Horsley <Damien.Horsley@imgtec.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/codecs/pcm3168a.c b/sound/soc/codecs/pcm3168a.c
new file mode 100644
index 0000000..b6fbbd6
--- /dev/null
+++ b/sound/soc/codecs/pcm3168a.c
@@ -0,0 +1,764 @@
+/*
+ * PCM3168A codec driver
+ *
+ * Copyright (C) 2014 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+
+#include "pcm3168a.h"
+
+#define PCM3168A_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \
+			 SNDRV_PCM_FMTBIT_S24_3LE | \
+			 SNDRV_PCM_FMTBIT_S24_LE | \
+			 SNDRV_PCM_FMTBIT_S32_LE)
+
+#define PCM3168A_FMT_I2S		0x0
+#define PCM3168A_FMT_LEFT_J		0x1
+#define PCM3168A_FMT_RIGHT_J		0x2
+#define PCM3168A_FMT_RIGHT_J_16		0x3
+#define PCM3168A_FMT_DSP_A		0x4
+#define PCM3168A_FMT_DSP_B		0x5
+#define PCM3168A_FMT_DSP_MASK		0x4
+
+#define PCM3168A_NUM_SUPPLIES 6
+static const char *const pcm3168a_supply_names[PCM3168A_NUM_SUPPLIES] = {
+	"VDD1",
+	"VDD2",
+	"VCCAD1",
+	"VCCAD2",
+	"VCCDA1",
+	"VCCDA2"
+};
+
+struct pcm3168a_priv {
+	struct regulator_bulk_data supplies[PCM3168A_NUM_SUPPLIES];
+	struct regmap *regmap;
+	struct clk *scki;
+	bool adc_slave_mode;
+	bool dac_slave_mode;
+	unsigned long sysclk;
+	unsigned int adc_fmt;
+	unsigned int dac_fmt;
+};
+
+static const char *const pcm3168a_roll_off[] = { "Sharp", "Slow" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_d1_roll_off, PCM3168A_DAC_OP_FLT,
+		PCM3168A_DAC_FLT_SHIFT, pcm3168a_roll_off);
+static SOC_ENUM_SINGLE_DECL(pcm3168a_d2_roll_off, PCM3168A_DAC_OP_FLT,
+		PCM3168A_DAC_FLT_SHIFT + 1, pcm3168a_roll_off);
+static SOC_ENUM_SINGLE_DECL(pcm3168a_d3_roll_off, PCM3168A_DAC_OP_FLT,
+		PCM3168A_DAC_FLT_SHIFT + 2, pcm3168a_roll_off);
+static SOC_ENUM_SINGLE_DECL(pcm3168a_d4_roll_off, PCM3168A_DAC_OP_FLT,
+		PCM3168A_DAC_FLT_SHIFT + 3, pcm3168a_roll_off);
+
+static const char *const pcm3168a_volume_type[] = {
+		"Individual", "Master + Individual" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_dac_volume_type, PCM3168A_DAC_ATT_DEMP_ZF,
+		PCM3168A_DAC_ATMDDA_SHIFT, pcm3168a_volume_type);
+
+static const char *const pcm3168a_att_speed_mult[] = { "2048", "4096" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_dac_att_mult, PCM3168A_DAC_ATT_DEMP_ZF,
+		PCM3168A_DAC_ATSPDA_SHIFT, pcm3168a_att_speed_mult);
+
+static const char *const pcm3168a_demp[] = {
+		"Disabled", "48khz", "44.1khz", "32khz" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_dac_demp, PCM3168A_DAC_ATT_DEMP_ZF,
+		PCM3168A_DAC_DEMP_SHIFT, pcm3168a_demp);
+
+static const char *const pcm3168a_zf_func[] = {
+		"DAC 1/2/3/4 AND", "DAC 1/2/3/4 OR", "DAC 1/2/3 AND",
+		"DAC 1/2/3 OR", "DAC 4 AND", "DAC 4 OR" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_dac_zf_func, PCM3168A_DAC_ATT_DEMP_ZF,
+		PCM3168A_DAC_AZRO_SHIFT, pcm3168a_zf_func);
+
+static const char *const pcm3168a_pol[] = { "Active High", "Active Low" };
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_dac_zf_pol, PCM3168A_DAC_ATT_DEMP_ZF,
+		PCM3168A_DAC_ATSPDA_SHIFT, pcm3168a_pol);
+
+static const char *const pcm3168a_con[] = { "Differential", "Single-Ended" };
+
+static SOC_ENUM_DOUBLE_DECL(pcm3168a_adc1_con, PCM3168A_ADC_SEAD,
+				0, 1, pcm3168a_con);
+static SOC_ENUM_DOUBLE_DECL(pcm3168a_adc2_con, PCM3168A_ADC_SEAD,
+				2, 3, pcm3168a_con);
+static SOC_ENUM_DOUBLE_DECL(pcm3168a_adc3_con, PCM3168A_ADC_SEAD,
+				4, 5, pcm3168a_con);
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_adc_volume_type, PCM3168A_ADC_ATT_OVF,
+		PCM3168A_ADC_ATMDAD_SHIFT, pcm3168a_volume_type);
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_adc_att_mult, PCM3168A_ADC_ATT_OVF,
+		PCM3168A_ADC_ATSPAD_SHIFT, pcm3168a_att_speed_mult);
+
+static SOC_ENUM_SINGLE_DECL(pcm3168a_adc_ov_pol, PCM3168A_ADC_ATT_OVF,
+		PCM3168A_ADC_OVFP_SHIFT, pcm3168a_pol);
+
+/* -100db to 0db, register values 0-54 cause mute */
+static const DECLARE_TLV_DB_SCALE(pcm3168a_dac_tlv, -10050, 50, 1);
+
+/* -100db to 20db, register values 0-14 cause mute */
+static const DECLARE_TLV_DB_SCALE(pcm3168a_adc_tlv, -10050, 50, 1);
+
+static const struct snd_kcontrol_new pcm3168a_snd_controls[] = {
+	SOC_SINGLE("DAC Power-Save Switch", PCM3168A_DAC_PWR_MST_FMT,
+			PCM3168A_DAC_PSMDA_SHIFT, 1, 1),
+	SOC_ENUM("DAC1 Digital Filter roll-off", pcm3168a_d1_roll_off),
+	SOC_ENUM("DAC2 Digital Filter roll-off", pcm3168a_d2_roll_off),
+	SOC_ENUM("DAC3 Digital Filter roll-off", pcm3168a_d3_roll_off),
+	SOC_ENUM("DAC4 Digital Filter roll-off", pcm3168a_d4_roll_off),
+	SOC_DOUBLE("DAC1 Invert Switch", PCM3168A_DAC_INV, 0, 1, 1, 0),
+	SOC_DOUBLE("DAC2 Invert Switch", PCM3168A_DAC_INV, 2, 3, 1, 0),
+	SOC_DOUBLE("DAC3 Invert Switch", PCM3168A_DAC_INV, 4, 5, 1, 0),
+	SOC_DOUBLE("DAC4 Invert Switch", PCM3168A_DAC_INV, 6, 7, 1, 0),
+	PCM3168A_DOUBLE_STS("DAC1 Zero Flag", PCM3168A_DAC_ZERO, 0, 1, 1, 0),
+	PCM3168A_DOUBLE_STS("DAC2 Zero Flag", PCM3168A_DAC_ZERO, 2, 3, 1, 0),
+	PCM3168A_DOUBLE_STS("DAC3 Zero Flag", PCM3168A_DAC_ZERO, 4, 5, 1, 0),
+	PCM3168A_DOUBLE_STS("DAC4 Zero Flag", PCM3168A_DAC_ZERO, 6, 7, 1, 0),
+	SOC_ENUM("DAC Volume Control Type", pcm3168a_dac_volume_type),
+	SOC_ENUM("DAC Volume Rate Multiplier", pcm3168a_dac_att_mult),
+	SOC_ENUM("DAC De-Emphasis", pcm3168a_dac_demp),
+	SOC_ENUM("DAC Zero Flag Function", pcm3168a_dac_zf_func),
+	SOC_ENUM("DAC Zero Flag Polarity", pcm3168a_dac_zf_pol),
+	SOC_SINGLE_RANGE_TLV("Master Playback Volume",
+			PCM3168A_DAC_VOL_MASTER, 0, 54, 255, 0,
+			pcm3168a_dac_tlv),
+	SOC_DOUBLE_R_RANGE_TLV("DAC1 Playback Volume",
+			PCM3168A_DAC_VOL_CHAN_START,
+			PCM3168A_DAC_VOL_CHAN_START + 1,
+			0, 54, 255, 0, pcm3168a_dac_tlv),
+	SOC_DOUBLE_R_RANGE_TLV("DAC2 Playback Volume",
+			PCM3168A_DAC_VOL_CHAN_START + 2,
+			PCM3168A_DAC_VOL_CHAN_START + 3,
+			0, 54, 255, 0, pcm3168a_dac_tlv),
+	SOC_DOUBLE_R_RANGE_TLV("DAC3 Playback Volume",
+			PCM3168A_DAC_VOL_CHAN_START + 4,
+			PCM3168A_DAC_VOL_CHAN_START + 5,
+			0, 54, 255, 0, pcm3168a_dac_tlv),
+	SOC_DOUBLE_R_RANGE_TLV("DAC4 Playback Volume",
+			PCM3168A_DAC_VOL_CHAN_START + 6,
+			PCM3168A_DAC_VOL_CHAN_START + 7,
+			0, 54, 255, 0, pcm3168a_dac_tlv),
+	SOC_SINGLE("ADC1 High-Pass Filter Switch", PCM3168A_ADC_PWR_HPFB,
+			PCM3168A_ADC_BYP_SHIFT, 1, 1),
+	SOC_SINGLE("ADC2 High-Pass Filter Switch", PCM3168A_ADC_PWR_HPFB,
+			PCM3168A_ADC_BYP_SHIFT + 1, 1, 1),
+	SOC_SINGLE("ADC3 High-Pass Filter Switch", PCM3168A_ADC_PWR_HPFB,
+			PCM3168A_ADC_BYP_SHIFT + 2, 1, 1),
+	SOC_ENUM("ADC1 Connection Type", pcm3168a_adc1_con),
+	SOC_ENUM("ADC2 Connection Type", pcm3168a_adc2_con),
+	SOC_ENUM("ADC3 Connection Type", pcm3168a_adc3_con),
+	SOC_DOUBLE("ADC1 Invert Switch", PCM3168A_ADC_INV, 0, 1, 1, 0),
+	SOC_DOUBLE("ADC2 Invert Switch", PCM3168A_ADC_INV, 2, 3, 1, 0),
+	SOC_DOUBLE("ADC3 Invert Switch", PCM3168A_ADC_INV, 4, 5, 1, 0),
+	SOC_DOUBLE("ADC1 Mute Switch", PCM3168A_ADC_MUTE, 0, 1, 1, 0),
+	SOC_DOUBLE("ADC2 Mute Switch", PCM3168A_ADC_MUTE, 2, 3, 1, 0),
+	SOC_DOUBLE("ADC3 Mute Switch", PCM3168A_ADC_MUTE, 4, 5, 1, 0),
+	PCM3168A_DOUBLE_STS("ADC1 Overflow Flag", PCM3168A_ADC_OV, 0, 1, 1, 0),
+	PCM3168A_DOUBLE_STS("ADC2 Overflow Flag", PCM3168A_ADC_OV, 2, 3, 1, 0),
+	PCM3168A_DOUBLE_STS("ADC3 Overflow Flag", PCM3168A_ADC_OV, 4, 5, 1, 0),
+	SOC_ENUM("ADC Volume Control Type", pcm3168a_adc_volume_type),
+	SOC_ENUM("ADC Volume Rate Multiplier", pcm3168a_adc_att_mult),
+	SOC_ENUM("ADC Overflow Flag Polarity", pcm3168a_adc_ov_pol),
+	SOC_SINGLE_RANGE_TLV("Master Capture Volume",
+			PCM3168A_ADC_VOL_MASTER, 0, 14, 255, 0,
+			pcm3168a_adc_tlv),
+	SOC_DOUBLE_R_RANGE_TLV("ADC1 Capture Volume",
+			PCM3168A_ADC_VOL_CHAN_START,
+			PCM3168A_ADC_VOL_CHAN_START + 1,
+			0, 14, 255, 0, pcm3168a_adc_tlv),
+	SOC_DOUBLE_R_RANGE_TLV("ADC2 Capture Volume",
+			PCM3168A_ADC_VOL_CHAN_START + 2,
+			PCM3168A_ADC_VOL_CHAN_START + 3,
+			0, 14, 255, 0, pcm3168a_adc_tlv),
+	SOC_DOUBLE_R_RANGE_TLV("ADC3 Capture Volume",
+			PCM3168A_ADC_VOL_CHAN_START + 4,
+			PCM3168A_ADC_VOL_CHAN_START + 5,
+			0, 14, 255, 0, pcm3168a_adc_tlv)
+};
+
+static const struct snd_soc_dapm_widget pcm3168a_dapm_widgets[] = {
+	SND_SOC_DAPM_DAC("DAC1", "Playback", PCM3168A_DAC_OP_FLT,
+			PCM3168A_DAC_OPEDA_SHIFT, 1),
+	SND_SOC_DAPM_DAC("DAC2", "Playback", PCM3168A_DAC_OP_FLT,
+			PCM3168A_DAC_OPEDA_SHIFT + 1, 1),
+	SND_SOC_DAPM_DAC("DAC3", "Playback", PCM3168A_DAC_OP_FLT,
+			PCM3168A_DAC_OPEDA_SHIFT + 2, 1),
+	SND_SOC_DAPM_DAC("DAC4", "Playback", PCM3168A_DAC_OP_FLT,
+			PCM3168A_DAC_OPEDA_SHIFT + 3, 1),
+
+	SND_SOC_DAPM_OUTPUT("AOUT1L"),
+	SND_SOC_DAPM_OUTPUT("AOUT1R"),
+	SND_SOC_DAPM_OUTPUT("AOUT2L"),
+	SND_SOC_DAPM_OUTPUT("AOUT2R"),
+	SND_SOC_DAPM_OUTPUT("AOUT3L"),
+	SND_SOC_DAPM_OUTPUT("AOUT3R"),
+	SND_SOC_DAPM_OUTPUT("AOUT4L"),
+	SND_SOC_DAPM_OUTPUT("AOUT4R"),
+
+	SND_SOC_DAPM_ADC("ADC1", "Capture", PCM3168A_ADC_PWR_HPFB,
+			PCM3168A_ADC_PSVAD_SHIFT, 1),
+	SND_SOC_DAPM_ADC("ADC2", "Capture", PCM3168A_ADC_PWR_HPFB,
+			PCM3168A_ADC_PSVAD_SHIFT + 1, 1),
+	SND_SOC_DAPM_ADC("ADC3", "Capture", PCM3168A_ADC_PWR_HPFB,
+			PCM3168A_ADC_PSVAD_SHIFT + 2, 1),
+
+	SND_SOC_DAPM_INPUT("AIN1L"),
+	SND_SOC_DAPM_INPUT("AIN1R"),
+	SND_SOC_DAPM_INPUT("AIN2L"),
+	SND_SOC_DAPM_INPUT("AIN2R"),
+	SND_SOC_DAPM_INPUT("AIN3L"),
+	SND_SOC_DAPM_INPUT("AIN3R")
+};
+
+static const struct snd_soc_dapm_route pcm3168a_dapm_routes[] = {
+	/* Playback */
+	{ "AOUT1L", NULL, "DAC1" },
+	{ "AOUT1R", NULL, "DAC1" },
+
+	{ "AOUT2L", NULL, "DAC2" },
+	{ "AOUT2R", NULL, "DAC2" },
+
+	{ "AOUT3L", NULL, "DAC3" },
+	{ "AOUT3R", NULL, "DAC3" },
+
+	{ "AOUT4L", NULL, "DAC4" },
+	{ "AOUT4R", NULL, "DAC4" },
+
+	/* Capture */
+	{ "ADC1", NULL, "AIN1L" },
+	{ "ADC1", NULL, "AIN1R" },
+
+	{ "ADC2", NULL, "AIN2L" },
+	{ "ADC2", NULL, "AIN2R" },
+
+	{ "ADC3", NULL, "AIN3L" },
+	{ "ADC3", NULL, "AIN3R" }
+};
+
+static unsigned int pcm3168a_scki_ratios[] = {
+	768,
+	512,
+	384,
+	256,
+	192,
+	128
+};
+
+#define PCM3168A_NUM_SCKI_RATIOS_DAC	ARRAY_SIZE(pcm3168a_scki_ratios)
+#define PCM3168A_NUM_SCKI_RATIOS_ADC	(ARRAY_SIZE(pcm3168a_scki_ratios) - 2)
+
+#define PCM1368A_MAX_SYSCLK		36864000
+
+static int pcm3168a_reset(struct pcm3168a_priv *pcm3168a)
+{
+	int ret = 0;
+
+	ret = regmap_write(pcm3168a->regmap, PCM3168A_RST_SMODE, 0);
+	if (ret)
+		return ret;
+
+	/* Internal reset is de-asserted after 3846 SCKI cycles */
+	msleep(DIV_ROUND_UP(3846 * 1000, pcm3168a->sysclk));
+
+	return regmap_write(pcm3168a->regmap, PCM3168A_RST_SMODE,
+			PCM3168A_MRST_MASK | PCM3168A_SRST_MASK);
+}
+
+static int pcm3168a_digital_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct pcm3168a_priv *pcm3168a = snd_soc_codec_get_drvdata(codec);
+
+	regmap_write(pcm3168a->regmap, PCM3168A_DAC_MUTE, mute ? 0xff : 0);
+
+	return 0;
+}
+
+static int pcm3168a_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+				  int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct pcm3168a_priv *pcm3168a = snd_soc_codec_get_drvdata(codec);
+
+	if (freq > PCM1368A_MAX_SYSCLK)
+		return -EINVAL;
+
+	pcm3168a->sysclk = freq;
+
+	return 0;
+}
+
+static int pcm3168a_set_dai_fmt(struct snd_soc_dai *codec_dai,
+			       unsigned int format, bool dac)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct pcm3168a_priv *pcm3168a = snd_soc_codec_get_drvdata(codec);
+	u32 fmt, reg, mask, shift;
+	bool slave_mode;
+
+	if (dac) {
+		reg = PCM3168A_DAC_PWR_MST_FMT;
+		mask = PCM3168A_DAC_FMT_MASK;
+		shift = PCM3168A_DAC_FMT_SHIFT;
+	} else {
+		reg = PCM3168A_ADC_MST_FMT;
+		mask = PCM3168A_ADC_FMTAD_MASK;
+		shift = PCM3168A_ADC_FMTAD_SHIFT;
+	}
+
+	switch (format & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_LEFT_J:
+		fmt = PCM3168A_FMT_LEFT_J;
+		break;
+	case SND_SOC_DAIFMT_I2S:
+		fmt = PCM3168A_FMT_I2S;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		fmt = PCM3168A_FMT_RIGHT_J;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		fmt = PCM3168A_FMT_DSP_A;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		fmt = PCM3168A_FMT_DSP_B;
+		break;
+	default:
+		dev_err(codec->dev, "unsupported dai format\n");
+		return -EINVAL;
+	}
+
+	regmap_update_bits(pcm3168a->regmap, reg, mask, fmt << shift);
+
+	switch (format & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		slave_mode = true;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		slave_mode = false;
+		break;
+	default:
+		dev_err(codec->dev, "unsupported master/slave mode\n");
+		return -EINVAL;
+	}
+
+	if (dac) {
+		pcm3168a->dac_slave_mode = slave_mode;
+		pcm3168a->dac_fmt = fmt;
+	} else {
+		pcm3168a->adc_slave_mode = slave_mode;
+		pcm3168a->adc_fmt = fmt;
+	}
+
+	switch (format & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int pcm3168a_set_dai_fmt_dac(struct snd_soc_dai *codec_dai,
+			       unsigned int format)
+{
+	return pcm3168a_set_dai_fmt(codec_dai, format, true);
+}
+
+static int pcm3168a_set_dai_fmt_adc(struct snd_soc_dai *codec_dai,
+			       unsigned int format)
+{
+	return pcm3168a_set_dai_fmt(codec_dai, format, false);
+}
+
+static int pcm3168a_hw_params(struct snd_pcm_substream *substream,
+			     struct snd_pcm_hw_params *params,
+			     struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct pcm3168a_priv *pcm3168a = snd_soc_codec_get_drvdata(codec);
+	bool tx, slave_mode;
+	u32 val, mask, shift, reg;
+	unsigned int rate, channels, fmt, ratio, max_ratio;
+	int i;
+	snd_pcm_format_t format;
+
+	rate = params_rate(params);
+	format = params_format(params);
+	channels = params_channels(params);
+
+	ratio = pcm3168a->sysclk / rate;
+
+	tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
+	if (tx) {
+		max_ratio = PCM3168A_NUM_SCKI_RATIOS_DAC;
+		reg = PCM3168A_DAC_PWR_MST_FMT;
+		mask = PCM3168A_DAC_MSDA_MASK;
+		shift = PCM3168A_DAC_MSDA_SHIFT;
+		slave_mode = pcm3168a->dac_slave_mode;
+		fmt = pcm3168a->dac_fmt;
+	} else {
+		max_ratio = PCM3168A_NUM_SCKI_RATIOS_ADC;
+		reg = PCM3168A_ADC_MST_FMT;
+		mask = PCM3168A_ADC_MSAD_MASK;
+		shift = PCM3168A_ADC_MSAD_SHIFT;
+		slave_mode = pcm3168a->adc_slave_mode;
+		fmt = pcm3168a->adc_fmt;
+	}
+
+	for (i = 0; i < max_ratio; i++) {
+		if (pcm3168a_scki_ratios[i] == ratio)
+			break;
+	}
+
+	if (i == max_ratio) {
+		dev_err(codec->dev, "unsupported sysclk ratio\n");
+		return -EINVAL;
+	}
+
+	if ((!slave_mode || (fmt & PCM3168A_FMT_DSP_MASK)) &&
+			(format == SNDRV_PCM_FORMAT_S24_3LE)) {
+		dev_err(codec->dev, "48-bit frames not supported in master mode or slave mode using DSP(A/B)\n");
+		return -EINVAL;
+	}
+
+	if ((!slave_mode || ((fmt != PCM3168A_FMT_RIGHT_J) &&
+			(fmt != PCM3168A_FMT_LEFT_J))) &&
+			(format == SNDRV_PCM_FORMAT_S16)) {
+		dev_err(codec->dev, "32-bit frames are supported only for slave mode using left/right justified\n");
+		return -EINVAL;
+	}
+
+	val = slave_mode ? 0 : ((i + 1) << shift);
+
+	regmap_update_bits(pcm3168a->regmap, reg, mask, val);
+
+	if (tx) {
+		mask = PCM3168A_DAC_FMT_MASK;
+		shift = PCM3168A_DAC_FMT_SHIFT;
+	} else {
+		mask = PCM3168A_ADC_FMTAD_MASK;
+		shift = PCM3168A_ADC_FMTAD_SHIFT;
+	}
+
+	/*
+	 * Justification has no effect for S32 and S16 as the whole frame
+	 * is filled with the samples, but the register field
+	 * must be set to a particular value for correct operation
+	 */
+	if ((fmt == PCM3168A_FMT_RIGHT_J) &&
+			(format == SNDRV_PCM_FORMAT_S32)) {
+		fmt = PCM3168A_FMT_LEFT_J;
+	} else if (format == SNDRV_PCM_FORMAT_S16) {
+		fmt = PCM3168A_FMT_RIGHT_J_16;
+	}
+
+	regmap_update_bits(pcm3168a->regmap, reg, mask, fmt << shift);
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops pcm3168a_dac_dai_ops = {
+	.set_fmt	= pcm3168a_set_dai_fmt_dac,
+	.set_sysclk	= pcm3168a_set_dai_sysclk,
+	.hw_params	= pcm3168a_hw_params,
+	.digital_mute	= pcm3168a_digital_mute
+};
+
+static const struct snd_soc_dai_ops pcm3168a_adc_dai_ops = {
+	.set_fmt	= pcm3168a_set_dai_fmt_adc,
+	.set_sysclk	= pcm3168a_set_dai_sysclk,
+	.hw_params	= pcm3168a_hw_params
+};
+
+static struct snd_soc_dai_driver pcm3168a_dais[] = {
+	{
+		.name = "pcm3168a-dac",
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 1,
+			.channels_max = 8,
+			.rates = SNDRV_PCM_RATE_8000_192000,
+			.formats = PCM3168A_FORMATS
+		},
+		.ops = &pcm3168a_dac_dai_ops
+	},
+	{
+		.name = "pcm3168a-adc",
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 1,
+			.channels_max = 6,
+			.rates = SNDRV_PCM_RATE_8000_96000,
+			.formats = PCM3168A_FORMATS
+		},
+		.ops = &pcm3168a_adc_dai_ops
+	},
+};
+
+static const struct reg_default pcm3168a_reg_default[] = {
+	{ PCM3168A_RST_SMODE, PCM3168A_MRST_MASK | PCM3168A_SRST_MASK },
+	{ PCM3168A_DAC_PWR_MST_FMT, 0x00 },
+	{ PCM3168A_DAC_OP_FLT, 0x00 },
+	{ PCM3168A_DAC_INV, 0x00 },
+	{ PCM3168A_DAC_MUTE, 0x00 },
+	{ PCM3168A_DAC_ZERO, 0x00 },
+	{ PCM3168A_DAC_ATT_DEMP_ZF, 0x00 },
+	{ PCM3168A_DAC_VOL_MASTER, 0xff },
+	{ PCM3168A_DAC_VOL_CHAN_START, 0xff },
+	{ PCM3168A_DAC_VOL_CHAN_START + 1, 0xff },
+	{ PCM3168A_DAC_VOL_CHAN_START + 2, 0xff },
+	{ PCM3168A_DAC_VOL_CHAN_START + 3, 0xff },
+	{ PCM3168A_DAC_VOL_CHAN_START + 4, 0xff },
+	{ PCM3168A_DAC_VOL_CHAN_START + 5, 0xff },
+	{ PCM3168A_DAC_VOL_CHAN_START + 6, 0xff },
+	{ PCM3168A_DAC_VOL_CHAN_START + 7, 0xff },
+	{ PCM3168A_ADC_SMODE, 0x00 },
+	{ PCM3168A_ADC_MST_FMT, 0x00 },
+	{ PCM3168A_ADC_PWR_HPFB, 0x00 },
+	{ PCM3168A_ADC_SEAD, 0x00 },
+	{ PCM3168A_ADC_INV, 0x00 },
+	{ PCM3168A_ADC_MUTE, 0x00 },
+	{ PCM3168A_ADC_OV, 0x00 },
+	{ PCM3168A_ADC_ATT_OVF, 0x00 },
+	{ PCM3168A_ADC_VOL_MASTER, 0xd3 },
+	{ PCM3168A_ADC_VOL_CHAN_START, 0xd3 },
+	{ PCM3168A_ADC_VOL_CHAN_START + 1, 0xd3 },
+	{ PCM3168A_ADC_VOL_CHAN_START + 2, 0xd3 },
+	{ PCM3168A_ADC_VOL_CHAN_START + 3, 0xd3 },
+	{ PCM3168A_ADC_VOL_CHAN_START + 4, 0xd3 },
+	{ PCM3168A_ADC_VOL_CHAN_START + 5, 0xd3 }
+};
+
+static bool pcm3168a_readable_register(struct device *dev, unsigned int reg)
+{
+	if (reg >= PCM3168A_RST_SMODE)
+		return true;
+	else
+		return false;
+}
+
+static bool pcm3168a_volatile_register(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case PCM3168A_DAC_ZERO:
+	case PCM3168A_ADC_OV:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool pcm3168a_writeable_register(struct device *dev, unsigned int reg)
+{
+	if (reg < PCM3168A_RST_SMODE)
+		return false;
+
+	switch (reg) {
+	case PCM3168A_DAC_ZERO:
+	case PCM3168A_ADC_OV:
+		return false;
+	default:
+		return true;
+	}
+}
+
+const struct regmap_config pcm3168a_regmap = {
+	.reg_bits = 8,
+	.val_bits = 8,
+
+	.max_register = PCM3168A_ADC_VOL_CHAN_START + 5,
+	.reg_defaults = pcm3168a_reg_default,
+	.num_reg_defaults = ARRAY_SIZE(pcm3168a_reg_default),
+	.readable_reg = pcm3168a_readable_register,
+	.volatile_reg = pcm3168a_volatile_register,
+	.writeable_reg = pcm3168a_writeable_register,
+	.cache_type = REGCACHE_FLAT
+};
+EXPORT_SYMBOL_GPL(pcm3168a_regmap);
+
+static const struct snd_soc_codec_driver pcm3168a_driver = {
+	.controls = pcm3168a_snd_controls,
+	.num_controls = ARRAY_SIZE(pcm3168a_snd_controls),
+	.dapm_widgets = pcm3168a_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(pcm3168a_dapm_widgets),
+	.dapm_routes = pcm3168a_dapm_routes,
+	.num_dapm_routes = ARRAY_SIZE(pcm3168a_dapm_routes)
+};
+
+int pcm3168a_probe(struct device *dev, struct regmap *regmap)
+{
+	struct pcm3168a_priv *pcm3168a;
+	int ret, i;
+
+	pcm3168a = devm_kzalloc(dev, sizeof(*pcm3168a), GFP_KERNEL);
+	if (pcm3168a == NULL)
+		return -ENOMEM;
+
+	dev_set_drvdata(dev, pcm3168a);
+
+	pcm3168a->scki = devm_clk_get(dev, "scki");
+	if (IS_ERR(pcm3168a->scki)) {
+		dev_err(dev, "failed to get the clock: %ld\n",
+				PTR_ERR(pcm3168a->scki));
+		return PTR_ERR(pcm3168a->scki);
+	}
+
+	ret = clk_prepare_enable(pcm3168a->scki);
+	if (ret) {
+		dev_err(dev, "failed to enable mclk: %d\n", ret);
+		return ret;
+	}
+
+	pcm3168a->sysclk = clk_get_rate(pcm3168a->scki);
+
+	for (i = 0; i < ARRAY_SIZE(pcm3168a->supplies); i++)
+		pcm3168a->supplies[i].supply = pcm3168a_supply_names[i];
+
+	ret = devm_regulator_bulk_get(dev,
+			ARRAY_SIZE(pcm3168a->supplies), pcm3168a->supplies);
+	if (ret) {
+		dev_err(dev, "failed to request supplies: %d\n", ret);
+		goto err_clk;
+	}
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(pcm3168a->supplies),
+				    pcm3168a->supplies);
+	if (ret) {
+		dev_err(dev, "failed to enable supplies: %d\n", ret);
+		goto err_clk;
+	}
+
+	pcm3168a->regmap = regmap;
+	if (IS_ERR(pcm3168a->regmap)) {
+		ret = PTR_ERR(pcm3168a->regmap);
+		dev_err(dev, "failed to allocate regmap: %d\n", ret);
+		goto err_regulator;
+	}
+
+	ret = pcm3168a_reset(pcm3168a);
+	if (ret) {
+		dev_err(dev, "Failed to reset device: %d\n", ret);
+		goto err_regulator;
+	}
+
+	ret = snd_soc_register_codec(dev, &pcm3168a_driver, pcm3168a_dais,
+			ARRAY_SIZE(pcm3168a_dais));
+	if (ret) {
+		dev_err(dev, "failed to register codec:%d\n", ret);
+		goto err_regulator;
+	}
+
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_idle(dev);
+
+	return 0;
+
+err_regulator:
+	regulator_bulk_disable(ARRAY_SIZE(pcm3168a->supplies),
+			pcm3168a->supplies);
+err_clk:
+	clk_disable_unprepare(pcm3168a->scki);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pcm3168a_probe);
+
+void pcm3168a_remove(struct device *dev)
+{
+	snd_soc_unregister_codec(dev);
+	pm_runtime_disable(dev);
+}
+EXPORT_SYMBOL_GPL(pcm3168a_remove);
+
+#ifdef CONFIG_PM
+static int pcm3168a_rt_resume(struct device *dev)
+{
+	struct pcm3168a_priv *pcm3168a = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_prepare_enable(pcm3168a->scki);
+	if (ret) {
+		dev_err(dev, "Failed to enable mclk: %d\n", ret);
+		return ret;
+	}
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(pcm3168a->supplies),
+				    pcm3168a->supplies);
+	if (ret) {
+		dev_err(dev, "Failed to enable supplies: %d\n", ret);
+		goto err_clk;
+	}
+
+	ret = pcm3168a_reset(pcm3168a);
+	if (ret) {
+		dev_err(dev, "Failed to reset device: %d\n", ret);
+		goto err_regulator;
+	}
+
+	regcache_cache_only(pcm3168a->regmap, false);
+
+	regcache_mark_dirty(pcm3168a->regmap);
+
+	ret = regcache_sync(pcm3168a->regmap);
+	if (ret) {
+		dev_err(dev, "Failed to sync regmap: %d\n", ret);
+		goto err_regulator;
+	}
+
+	return 0;
+
+err_regulator:
+	regulator_bulk_disable(ARRAY_SIZE(pcm3168a->supplies),
+			       pcm3168a->supplies);
+err_clk:
+	clk_disable_unprepare(pcm3168a->scki);
+
+	return ret;
+}
+
+static int pcm3168a_rt_suspend(struct device *dev)
+{
+	struct pcm3168a_priv *pcm3168a = dev_get_drvdata(dev);
+
+	regcache_cache_only(pcm3168a->regmap, true);
+
+	regulator_bulk_disable(ARRAY_SIZE(pcm3168a->supplies),
+			       pcm3168a->supplies);
+
+	clk_disable_unprepare(pcm3168a->scki);
+
+	return 0;
+}
+#endif
+
+const struct dev_pm_ops pcm3168a_pm_ops = {
+	SET_RUNTIME_PM_OPS(pcm3168a_rt_suspend, pcm3168a_rt_resume, NULL)
+};
+EXPORT_SYMBOL_GPL(pcm3168a_pm_ops);
+
+MODULE_DESCRIPTION("PCM3168A codec driver");
+MODULE_AUTHOR("Damien Horsley <Damien.Horsley@imgtec.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/codecs/pcm3168a.h b/sound/soc/codecs/pcm3168a.h
new file mode 100644
index 0000000..a4c7838
--- /dev/null
+++ b/sound/soc/codecs/pcm3168a.h
@@ -0,0 +1,111 @@
+/*
+ * PCM3168A codec driver header
+ *
+ * Copyright (C) 2014 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#ifndef __PCM3168A_H__
+#define __PCM3168A_H__
+
+extern const struct dev_pm_ops pcm3168a_pm_ops;
+extern const struct regmap_config pcm3168a_regmap;
+
+extern int pcm3168a_probe(struct device *dev, struct regmap *regmap);
+extern void pcm3168a_remove(struct device *dev);
+
+#define PCM3168A_RST_SMODE			0x40
+#define PCM3168A_MRST_MASK			0x80
+#define PCM3168A_SRST_MASK			0x40
+#define PCM3168A_DAC_SRDA_SHIFT			0
+#define PCM3168A_DAC_SRDA_MASK			0x3
+
+#define PCM3168A_DAC_PWR_MST_FMT		0x41
+#define PCM3168A_DAC_PSMDA_SHIFT		7
+#define PCM3168A_DAC_PSMDA_MASK			0x80
+#define PCM3168A_DAC_MSDA_SHIFT			4
+#define PCM3168A_DAC_MSDA_MASK			0x70
+#define PCM3168A_DAC_FMT_SHIFT			0
+#define PCM3168A_DAC_FMT_MASK			0xf
+
+#define PCM3168A_DAC_OP_FLT			0x42
+#define PCM3168A_DAC_OPEDA_SHIFT		4
+#define PCM3168A_DAC_OPEDA_MASK			0xf0
+#define PCM3168A_DAC_FLT_SHIFT			0
+#define PCM3168A_DAC_FLT_MASK			0xf
+
+#define PCM3168A_DAC_INV			0x43
+
+#define PCM3168A_DAC_MUTE			0x44
+
+#define PCM3168A_DAC_ZERO			0x45
+
+#define PCM3168A_DAC_ATT_DEMP_ZF		0x46
+#define PCM3168A_DAC_ATMDDA_MASK		0x80
+#define PCM3168A_DAC_ATMDDA_SHIFT		7
+#define PCM3168A_DAC_ATSPDA_MASK		0x40
+#define PCM3168A_DAC_ATSPDA_SHIFT		6
+#define PCM3168A_DAC_DEMP_SHIFT			4
+#define PCM3168A_DAC_DEMP_MASK			0x30
+#define PCM3168A_DAC_AZRO_SHIFT			1
+#define PCM3168A_DAC_AZRO_MASK			0xe
+#define PCM3168A_DAC_ZREV_MASK			0x1
+#define PCM3168A_DAC_ZREV_SHIFT			0
+
+#define PCM3168A_DAC_VOL_MASTER			0x47
+
+#define PCM3168A_DAC_VOL_CHAN_START		0x48
+
+#define PCM3168A_ADC_SMODE			0x50
+#define PCM3168A_ADC_SRAD_SHIFT			0
+#define PCM3168A_ADC_SRAD_MASK			0x3
+
+#define PCM3168A_ADC_MST_FMT			0x51
+#define PCM3168A_ADC_MSAD_SHIFT			4
+#define PCM3168A_ADC_MSAD_MASK			0x70
+#define PCM3168A_ADC_FMTAD_SHIFT		0
+#define PCM3168A_ADC_FMTAD_MASK			0x7
+
+#define PCM3168A_ADC_PWR_HPFB			0x52
+#define PCM3168A_ADC_PSVAD_SHIFT		4
+#define PCM3168A_ADC_PSVAD_MASK			0x70
+#define PCM3168A_ADC_BYP_SHIFT			0
+#define PCM3168A_ADC_BYP_MASK			0x7
+
+#define PCM3168A_ADC_SEAD			0x53
+
+#define PCM3168A_ADC_INV			0x54
+
+#define PCM3168A_ADC_MUTE			0x55
+
+#define PCM3168A_ADC_OV				0x56
+
+#define PCM3168A_ADC_ATT_OVF			0x57
+#define PCM3168A_ADC_ATMDAD_MASK		0x80
+#define PCM3168A_ADC_ATMDAD_SHIFT		7
+#define PCM3168A_ADC_ATSPAD_MASK		0x40
+#define PCM3168A_ADC_ATSPAD_SHIFT		6
+#define PCM3168A_ADC_OVFP_MASK			0x1
+#define PCM3168A_ADC_OVFP_SHIFT			0
+
+#define PCM3168A_ADC_VOL_MASTER			0x58
+
+#define PCM3168A_ADC_VOL_CHAN_START		0x59
+
+#define PCM3168A_DOUBLE_STS(xname, reg, shift_left, shift_right, max, invert) \
+{									\
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),		\
+	.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,		\
+	.put = snd_soc_put_volsw,					\
+	.access = SNDRV_CTL_ELEM_ACCESS_READ |				\
+		SNDRV_CTL_ELEM_ACCESS_VOLATILE,				\
+	.private_value = SOC_DOUBLE_VALUE(reg, shift_left, shift_right,	\
+	max, invert, 0)							\
+}
+
+#endif
diff --git a/sound/soc/img/Kconfig b/sound/soc/img/Kconfig
new file mode 100644
index 0000000..3cf3479
--- /dev/null
+++ b/sound/soc/img/Kconfig
@@ -0,0 +1,50 @@
+config SND_SOC_IMG
+	bool "Audio support for Imagination Technologies designs"
+	depends on MACH_PISTACHIO
+	help
+	  Audio support for Imagination Technologies audio hardware
+
+config SND_SOC_IMG_I2S_IN
+	tristate "Imagination I2S Input Device Driver"
+	depends on SND_SOC_IMG
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	help
+	  Say Y or M if you want to add support for I2S in driver for
+	  Imagination Technologies I2S in device.
+
+config SND_SOC_IMG_I2S_OUT
+	tristate "Imagination I2S Output Device Driver"
+	depends on SND_SOC_IMG
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	help
+	  Say Y or M if you want to add support for I2S out driver for
+	  Imagination Technologies I2S out device.
+
+config SND_SOC_IMG_PARALLEL_OUT
+	tristate "Imagination Parallel Output Device Driver"
+	depends on SND_SOC_IMG
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	help
+	  Say Y or M if you want to add support for parallel out driver for
+	  Imagination Technologies parallel out device.
+
+config SND_SOC_IMG_SPDIF_IN
+	tristate "Imagination SPDIF Input Device Driver"
+	depends on SND_SOC_IMG
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	help
+	  Say Y or M if you want to add support for SPDIF input driver for
+	  Imagination Technologies SPDIF input device.
+
+config SND_SOC_IMG_SPDIF_OUT
+	tristate "Imagination SPDIF Output Device Driver"
+	depends on SND_SOC_IMG
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	help
+	  Say Y or M if you want to add support for SPDIF out driver for
+	  Imagination Technologies SPDIF out device.
+
+
+config SND_SOC_IMG_PISTACHIO_EVENT_TIMER
+	tristate "Support for Pistachio SoC Event Timer Driver"
+	depends on SND_SOC_IMG
diff --git a/sound/soc/img/Makefile b/sound/soc/img/Makefile
new file mode 100644
index 0000000..6c79e2d
--- /dev/null
+++ b/sound/soc/img/Makefile
@@ -0,0 +1,7 @@
+obj-$(CONFIG_SND_SOC_IMG_I2S_IN) += img-i2s-in.o
+obj-$(CONFIG_SND_SOC_IMG_I2S_OUT) += img-i2s-out.o
+obj-$(CONFIG_SND_SOC_IMG_PARALLEL_OUT) += img-parallel-out.o
+obj-$(CONFIG_SND_SOC_IMG_SPDIF_IN) += img-spdif-in.o
+obj-$(CONFIG_SND_SOC_IMG_SPDIF_OUT) += img-spdif-out.o
+
+obj-$(CONFIG_SND_SOC_IMG_PISTACHIO_EVENT_TIMER) += pistachio-event-timer.o
diff --git a/sound/soc/img/img-i2s-in.c b/sound/soc/img/img-i2s-in.c
new file mode 100644
index 0000000..dc1e53a
--- /dev/null
+++ b/sound/soc/img/img-i2s-in.c
@@ -0,0 +1,508 @@
+/*
+ * IMG I2S input controller driver
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/reset.h>
+
+#include <sound/core.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#define IMG_I2S_IN_RX_FIFO			0x0
+
+#define IMG_I2S_IN_CTL				0x4
+#define IMG_I2S_IN_CTL_ACTIVE_CHAN_MASK		0xfffffffc
+#define IMG_I2S_IN_CTL_ACTIVE_CH_SHIFT		2
+#define IMG_I2S_IN_CTL_16PACK_MASK		BIT(1)
+#define IMG_I2S_IN_CTL_ME_MASK			BIT(0)
+
+#define IMG_I2S_IN_CH_CTL			0x4
+#define IMG_I2S_IN_CH_CTL_CCDEL_MASK		0x38000
+#define IMG_I2S_IN_CH_CTL_CCDEL_SHIFT		15
+#define IMG_I2S_IN_CH_CTL_FEN_MASK		BIT(14)
+#define IMG_I2S_IN_CH_CTL_FMODE_MASK		BIT(13)
+#define IMG_I2S_IN_CH_CTL_16PACK_MASK		BIT(12)
+#define IMG_I2S_IN_CH_CTL_JUST_MASK		BIT(10)
+#define IMG_I2S_IN_CH_CTL_PACKH_MASK		BIT(9)
+#define IMG_I2S_IN_CH_CTL_CLK_TRANS_MASK	BIT(8)
+#define IMG_I2S_IN_CH_CTL_BLKP_MASK		BIT(7)
+#define IMG_I2S_IN_CH_CTL_FIFO_FLUSH_MASK	BIT(6)
+#define IMG_I2S_IN_CH_CTL_LRD_MASK		BIT(3)
+#define IMG_I2S_IN_CH_CTL_FW_MASK		BIT(2)
+#define IMG_I2S_IN_CH_CTL_SW_MASK		BIT(1)
+#define IMG_I2S_IN_CH_CTL_ME_MASK		BIT(0)
+
+#define IMG_I2S_IN_CH_STRIDE			0x20
+
+struct img_i2s_in {
+	void __iomem *base;
+	struct clk *clk_sys;
+	struct snd_dmaengine_dai_dma_data dma_data;
+	struct device *dev;
+	unsigned int max_i2s_chan;
+	void __iomem *channel_base;
+	unsigned int active_channels;
+	struct snd_soc_dai_driver dai_driver;
+};
+
+static inline void img_i2s_in_writel(struct img_i2s_in *i2s, u32 val, u32 reg)
+{
+	writel(val, i2s->base + reg);
+}
+
+static inline u32 img_i2s_in_readl(struct img_i2s_in *i2s, u32 reg)
+{
+	return readl(i2s->base + reg);
+}
+
+static inline void img_i2s_in_ch_writel(struct img_i2s_in *i2s, u32 chan,
+					u32 val, u32 reg)
+{
+	writel(val, i2s->channel_base + (chan * IMG_I2S_IN_CH_STRIDE) + reg);
+}
+
+static inline u32 img_i2s_in_ch_readl(struct img_i2s_in *i2s, u32 chan,
+					u32 reg)
+{
+	return readl(i2s->channel_base + (chan * IMG_I2S_IN_CH_STRIDE) + reg);
+}
+
+static inline u32 img_i2s_in_ch_disable(struct img_i2s_in *i2s, u32 chan)
+{
+	u32 reg;
+
+	reg = img_i2s_in_ch_readl(i2s, chan, IMG_I2S_IN_CH_CTL);
+	reg &= ~IMG_I2S_IN_CH_CTL_ME_MASK;
+	img_i2s_in_ch_writel(i2s, chan, reg, IMG_I2S_IN_CH_CTL);
+
+	return reg;
+}
+
+static inline void img_i2s_in_ch_enable(struct img_i2s_in *i2s, u32 chan,
+					u32 reg)
+{
+	reg |= IMG_I2S_IN_CH_CTL_ME_MASK;
+	img_i2s_in_ch_writel(i2s, chan, reg, IMG_I2S_IN_CH_CTL);
+}
+
+static inline void img_i2s_in_flush(struct img_i2s_in *i2s)
+{
+	int i;
+	u32 reg;
+
+	for (i = 0; i < i2s->active_channels; i++) {
+		reg = img_i2s_in_ch_disable(i2s, i);
+		reg |= IMG_I2S_IN_CH_CTL_FIFO_FLUSH_MASK;
+		img_i2s_in_ch_writel(i2s, i, reg, IMG_I2S_IN_CH_CTL);
+		reg &= ~IMG_I2S_IN_CH_CTL_FIFO_FLUSH_MASK;
+		img_i2s_in_ch_writel(i2s, i, reg, IMG_I2S_IN_CH_CTL);
+		img_i2s_in_ch_enable(i2s, i, reg);
+	}
+}
+
+static int img_i2s_in_trigger(struct snd_pcm_substream *substream, int cmd,
+	struct snd_soc_dai *dai)
+{
+	struct img_i2s_in *i2s = snd_soc_dai_get_drvdata(dai);
+	u32 reg;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		reg = img_i2s_in_readl(i2s, IMG_I2S_IN_CTL);
+		reg |= IMG_I2S_IN_CTL_ME_MASK;
+		img_i2s_in_writel(i2s, reg, IMG_I2S_IN_CTL);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		reg = img_i2s_in_readl(i2s, IMG_I2S_IN_CTL);
+		reg &= ~IMG_I2S_IN_CTL_ME_MASK;
+		img_i2s_in_writel(i2s, reg, IMG_I2S_IN_CTL);
+		img_i2s_in_flush(i2s);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int img_i2s_in_check_rate(struct img_i2s_in *i2s,
+		unsigned int sample_rate, unsigned int frame_size,
+		unsigned int *bclk_filter_enable,
+		unsigned int *bclk_filter_value)
+{
+	unsigned int bclk_freq, cur_freq;
+
+	bclk_freq = sample_rate * frame_size;
+
+	cur_freq = clk_get_rate(i2s->clk_sys);
+
+	if (cur_freq >= bclk_freq * 8) {
+		*bclk_filter_enable = 1;
+		*bclk_filter_value = 0;
+	} else if (cur_freq >= bclk_freq * 7) {
+		*bclk_filter_enable = 1;
+		*bclk_filter_value = 1;
+	} else if (cur_freq >= bclk_freq * 6) {
+		*bclk_filter_enable = 0;
+		*bclk_filter_value = 0;
+	} else {
+		dev_err(i2s->dev,
+			"Sys clock rate %u insufficient for sample rate %u\n",
+			cur_freq, sample_rate);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int img_i2s_in_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct img_i2s_in *i2s = snd_soc_dai_get_drvdata(dai);
+	unsigned int rate, channels, i2s_channels, frame_size;
+	unsigned int bclk_filter_enable, bclk_filter_value;
+	int i, ret = 0;
+	u32 reg, control_reg, control_mask, chan_control_mask;
+	u32 control_set = 0, chan_control_set = 0;
+	snd_pcm_format_t format;
+
+	rate = params_rate(params);
+	format = params_format(params);
+	channels = params_channels(params);
+	i2s_channels = channels / 2;
+
+	switch (format) {
+	case SNDRV_PCM_FORMAT_S32_LE:
+		frame_size = 64;
+		chan_control_set |= IMG_I2S_IN_CH_CTL_SW_MASK;
+		chan_control_set |= IMG_I2S_IN_CH_CTL_FW_MASK;
+		chan_control_set |= IMG_I2S_IN_CH_CTL_PACKH_MASK;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		frame_size = 64;
+		chan_control_set |= IMG_I2S_IN_CH_CTL_SW_MASK;
+		chan_control_set |= IMG_I2S_IN_CH_CTL_FW_MASK;
+		break;
+	case SNDRV_PCM_FORMAT_S16_LE:
+		frame_size = 32;
+		control_set |= IMG_I2S_IN_CTL_16PACK_MASK;
+		chan_control_set |= IMG_I2S_IN_CH_CTL_16PACK_MASK;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if ((channels < 2) ||
+			(channels > (i2s->max_i2s_chan * 2)) ||
+			(channels % 2))
+		return -EINVAL;
+
+	control_set |= ((i2s_channels - 1) << IMG_I2S_IN_CTL_ACTIVE_CH_SHIFT);
+
+	ret = img_i2s_in_check_rate(i2s, rate, frame_size,
+			&bclk_filter_enable, &bclk_filter_value);
+	if (ret < 0)
+		return ret;
+
+	if (bclk_filter_enable)
+		chan_control_set |= IMG_I2S_IN_CH_CTL_FEN_MASK;
+
+	if (bclk_filter_value)
+		chan_control_set |= IMG_I2S_IN_CH_CTL_FMODE_MASK;
+
+	control_mask = (u32)(~IMG_I2S_IN_CTL_16PACK_MASK &
+			~IMG_I2S_IN_CTL_ACTIVE_CHAN_MASK);
+
+	chan_control_mask = (u32)(~IMG_I2S_IN_CH_CTL_16PACK_MASK &
+			~IMG_I2S_IN_CH_CTL_FEN_MASK &
+			~IMG_I2S_IN_CH_CTL_FMODE_MASK &
+			~IMG_I2S_IN_CH_CTL_SW_MASK &
+			~IMG_I2S_IN_CH_CTL_FW_MASK &
+			~IMG_I2S_IN_CH_CTL_PACKH_MASK);
+
+	control_reg = img_i2s_in_readl(i2s, IMG_I2S_IN_CTL);
+	control_reg = (control_reg & control_mask) | control_set;
+	img_i2s_in_writel(i2s, control_reg, IMG_I2S_IN_CTL);
+
+	for (i = 0; i < i2s_channels; i++) {
+		reg = img_i2s_in_ch_disable(i2s, i);
+		reg = (reg & chan_control_mask) | chan_control_set;
+		img_i2s_in_ch_writel(i2s, i, reg, IMG_I2S_IN_CH_CTL);
+		img_i2s_in_ch_enable(i2s, i, reg);
+	}
+	for (; i < i2s->max_i2s_chan; i++) {
+		reg = img_i2s_in_ch_disable(i2s, i);
+		reg = (reg & chan_control_mask) | chan_control_set;
+		img_i2s_in_ch_writel(i2s, i, reg, IMG_I2S_IN_CH_CTL);
+	}
+
+	i2s->active_channels = i2s_channels;
+
+	return 0;
+}
+
+static int img_i2s_in_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	struct img_i2s_in *i2s = snd_soc_dai_get_drvdata(dai);
+	int i;
+	u32 chan_control_mask, lrd_set = 0, blkp_set = 0, chan_control_set = 0;
+	u32 reg;
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		lrd_set |= IMG_I2S_IN_CH_CTL_LRD_MASK;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		lrd_set |= IMG_I2S_IN_CH_CTL_LRD_MASK;
+		blkp_set |= IMG_I2S_IN_CH_CTL_BLKP_MASK;
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		blkp_set |= IMG_I2S_IN_CH_CTL_BLKP_MASK;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		chan_control_set |= IMG_I2S_IN_CH_CTL_CLK_TRANS_MASK;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	chan_control_mask = (u32)~IMG_I2S_IN_CH_CTL_CLK_TRANS_MASK;
+
+	/*
+	 * BLKP and LRD must be set during separate register writes
+	 */
+	for (i = 0; i < i2s->active_channels; i++) {
+		reg = img_i2s_in_ch_disable(i2s, i);
+		reg = (reg & chan_control_mask) | chan_control_set;
+		img_i2s_in_ch_writel(i2s, i, reg, IMG_I2S_IN_CH_CTL);
+		reg = (reg & ~IMG_I2S_IN_CH_CTL_BLKP_MASK) | blkp_set;
+		img_i2s_in_ch_writel(i2s, i, reg, IMG_I2S_IN_CH_CTL);
+		reg = (reg & ~IMG_I2S_IN_CH_CTL_LRD_MASK) | lrd_set;
+		img_i2s_in_ch_writel(i2s, i, reg, IMG_I2S_IN_CH_CTL);
+		img_i2s_in_ch_enable(i2s, i, reg);
+	}
+
+	for (; i < i2s->max_i2s_chan; i++) {
+		reg = img_i2s_in_ch_readl(i2s, i, IMG_I2S_IN_CH_CTL);
+		reg = (reg & chan_control_mask) | chan_control_set;
+		img_i2s_in_ch_writel(i2s, i, reg, IMG_I2S_IN_CH_CTL);
+		reg = (reg & ~IMG_I2S_IN_CH_CTL_BLKP_MASK) | blkp_set;
+		img_i2s_in_ch_writel(i2s, i, reg, IMG_I2S_IN_CH_CTL);
+		reg = (reg & ~IMG_I2S_IN_CH_CTL_LRD_MASK) | lrd_set;
+		img_i2s_in_ch_writel(i2s, i, reg, IMG_I2S_IN_CH_CTL);
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops img_i2s_in_dai_ops = {
+	.trigger = img_i2s_in_trigger,
+	.hw_params = img_i2s_in_hw_params,
+	.set_fmt = img_i2s_in_set_fmt
+};
+
+static int img_i2s_in_dai_probe(struct snd_soc_dai *dai)
+{
+	struct img_i2s_in *i2s = snd_soc_dai_get_drvdata(dai);
+
+	snd_soc_dai_init_dma_data(dai, NULL, &i2s->dma_data);
+
+	return 0;
+}
+
+static const struct snd_soc_component_driver img_i2s_in_component = {
+	.name = "img-i2s-in"
+};
+
+static int img_i2s_in_dma_prepare_slave_config(struct snd_pcm_substream *st,
+	struct snd_pcm_hw_params *params, struct dma_slave_config *sc)
+{
+	unsigned int i2s_channels = params_channels(params) / 2;
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct snd_dmaengine_dai_dma_data *dma_data;
+	int ret;
+
+	dma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, st);
+
+	ret = snd_hwparams_to_dma_slave_config(st, params, sc);
+	if (ret)
+		return ret;
+
+	sc->src_addr = dma_data->addr;
+	sc->src_addr_width = dma_data->addr_width;
+	sc->src_maxburst = 4 * i2s_channels;
+
+	return 0;
+}
+
+static const struct snd_dmaengine_pcm_config img_i2s_in_dma_config = {
+	.prepare_slave_config = img_i2s_in_dma_prepare_slave_config
+};
+
+static int img_i2s_in_probe(struct platform_device *pdev)
+{
+	struct img_i2s_in *i2s;
+	struct resource *res;
+	void __iomem *base;
+	int ret, i;
+	struct reset_control *rst;
+	u32 reg;
+	unsigned int max_i2s_chan_pow_2;
+	struct device *dev = &pdev->dev;
+
+	i2s = devm_kzalloc(dev, sizeof(*i2s), GFP_KERNEL);
+	if (!i2s)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, i2s);
+
+	i2s->dev = dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	i2s->base = base;
+
+	if (of_property_read_u32(pdev->dev.of_node, "img,i2s-channels",
+			&i2s->max_i2s_chan)) {
+		dev_err(dev, "No img,i2s-channels property\n");
+		return -EINVAL;
+	}
+
+	max_i2s_chan_pow_2 = 1 << get_count_order(i2s->max_i2s_chan);
+
+	i2s->channel_base = base + (max_i2s_chan_pow_2 * 0x20);
+
+	i2s->clk_sys = devm_clk_get(dev, "sys");
+	if (IS_ERR(i2s->clk_sys))
+		return PTR_ERR(i2s->clk_sys);
+
+	ret = clk_prepare_enable(i2s->clk_sys);
+	if (ret)
+		return ret;
+
+	i2s->active_channels = 1;
+	i2s->dma_data.addr = res->start + IMG_I2S_IN_RX_FIFO;
+	i2s->dma_data.addr_width = 4;
+
+	i2s->dai_driver.probe = img_i2s_in_dai_probe;
+	i2s->dai_driver.capture.channels_min = 2;
+	i2s->dai_driver.capture.channels_max = i2s->max_i2s_chan * 2;
+	i2s->dai_driver.capture.rates = SNDRV_PCM_RATE_8000_192000;
+	i2s->dai_driver.capture.formats = SNDRV_PCM_FMTBIT_S32_LE |
+		SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE;
+	i2s->dai_driver.ops = &img_i2s_in_dai_ops;
+
+	rst = devm_reset_control_get(dev, "rst");
+	if (IS_ERR(rst)) {
+		dev_dbg(dev, "No top level reset found\n");
+
+		reg = img_i2s_in_readl(i2s, IMG_I2S_IN_CTL);
+		reg &= ~IMG_I2S_IN_CTL_ME_MASK;
+		img_i2s_in_writel(i2s, reg, IMG_I2S_IN_CTL);
+
+		for (i = 0; i < i2s->max_i2s_chan; i++) {
+			reg = img_i2s_in_ch_disable(i2s, i);
+			reg |= IMG_I2S_IN_CH_CTL_FIFO_FLUSH_MASK;
+			img_i2s_in_ch_writel(i2s, i, reg, IMG_I2S_IN_CH_CTL);
+			reg &= ~IMG_I2S_IN_CH_CTL_FIFO_FLUSH_MASK;
+			img_i2s_in_ch_writel(i2s, i, reg, IMG_I2S_IN_CH_CTL);
+		}
+	} else {
+		reset_control_assert(rst);
+		reset_control_deassert(rst);
+	}
+
+	img_i2s_in_writel(i2s, 0, IMG_I2S_IN_CTL);
+
+	for (i = 0; i < i2s->max_i2s_chan; i++)
+		img_i2s_in_ch_writel(i2s, i,
+			(4 << IMG_I2S_IN_CH_CTL_CCDEL_SHIFT) |
+			IMG_I2S_IN_CH_CTL_JUST_MASK |
+			IMG_I2S_IN_CH_CTL_FW_MASK, IMG_I2S_IN_CH_CTL);
+
+	ret = devm_snd_soc_register_component(dev, &img_i2s_in_component,
+						&i2s->dai_driver, 1);
+	if (ret)
+		goto err_clk_disable;
+
+	ret = devm_snd_dmaengine_pcm_register(dev, &img_i2s_in_dma_config, 0);
+	if (ret)
+		goto err_clk_disable;
+
+	return 0;
+
+err_clk_disable:
+	clk_disable_unprepare(i2s->clk_sys);
+
+	return ret;
+}
+
+static int img_i2s_in_dev_remove(struct platform_device *pdev)
+{
+	struct img_i2s_in *i2s = platform_get_drvdata(pdev);
+
+	clk_disable_unprepare(i2s->clk_sys);
+
+	return 0;
+}
+
+static const struct of_device_id img_i2s_in_of_match[] = {
+	{ .compatible = "img,i2s-in" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, img_i2s_in_of_match);
+
+static struct platform_driver img_i2s_in_driver = {
+	.driver = {
+		.name = "img-i2s-in",
+		.of_match_table = img_i2s_in_of_match
+	},
+	.probe = img_i2s_in_probe,
+	.remove = img_i2s_in_dev_remove
+};
+module_platform_driver(img_i2s_in_driver);
+
+MODULE_AUTHOR("Damien Horsley <Damien.Horsley@imgtec.com>");
+MODULE_DESCRIPTION("IMG I2S Input Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/img/img-i2s-out.c b/sound/soc/img/img-i2s-out.c
new file mode 100644
index 0000000..ea840f1
--- /dev/null
+++ b/sound/soc/img/img-i2s-out.c
@@ -0,0 +1,585 @@
+/*
+ * IMG I2S output controller driver
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/reset.h>
+
+#include <sound/core.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#define IMG_I2S_OUT_TX_FIFO			0x0
+
+#define IMG_I2S_OUT_CTL				0x4
+#define IMG_I2S_OUT_CTL_EXT_EN_CLK_MASK		BIT(25)
+#define IMG_I2S_OUT_CTL_DATA_EN_MASK		BIT(24)
+#define IMG_I2S_OUT_CTL_ACTIVE_CHAN_MASK	0xffe000
+#define IMG_I2S_OUT_CTL_ACTIVE_CHAN_SHIFT	13
+#define IMG_I2S_OUT_CTL_FRM_SIZE_MASK		BIT(8)
+#define IMG_I2S_OUT_CTL_MASTER_MASK		BIT(6)
+#define IMG_I2S_OUT_CTL_CLK_MASK		BIT(5)
+#define IMG_I2S_OUT_CTL_CLK_EN_MASK		BIT(4)
+#define IMG_I2S_OUT_CTL_FRM_CLK_POL_MASK	BIT(3)
+#define IMG_I2S_OUT_CTL_BCLK_POL_MASK		BIT(2)
+#define IMG_I2S_OUT_CTL_ME_MASK			BIT(0)
+
+#define IMG_I2S_OUT_CH_CTL			0x4
+#define IMG_I2S_OUT_CHAN_CTL_CH_MASK		BIT(11)
+#define IMG_I2S_OUT_CHAN_CTL_LT_MASK		BIT(10)
+#define IMG_I2S_OUT_CHAN_CTL_FMT_MASK		0xf0
+#define IMG_I2S_OUT_CHAN_CTL_FMT_SHIFT		4
+#define IMG_I2S_OUT_CHAN_CTL_JUST_MASK		BIT(3)
+#define IMG_I2S_OUT_CHAN_CTL_CLKT_MASK		BIT(1)
+#define IMG_I2S_OUT_CHAN_CTL_ME_MASK		BIT(0)
+
+#define IMG_I2S_OUT_CH_STRIDE			0x20
+
+struct img_i2s_out {
+	void __iomem *base;
+	struct clk *clk_sys;
+	struct clk *clk_ref;
+	struct snd_dmaengine_dai_dma_data dma_data;
+	struct device *dev;
+	unsigned int max_i2s_chan;
+	void __iomem *channel_base;
+	bool force_clk_active;
+	unsigned int active_channels;
+	struct reset_control *rst;
+	struct snd_soc_dai_driver dai_driver;
+};
+
+static int img_i2s_out_suspend(struct device *dev)
+{
+	struct img_i2s_out *i2s = dev_get_drvdata(dev);
+
+	if (!i2s->force_clk_active)
+		clk_disable_unprepare(i2s->clk_ref);
+
+	return 0;
+}
+
+static int img_i2s_out_resume(struct device *dev)
+{
+	struct img_i2s_out *i2s = dev_get_drvdata(dev);
+	int ret;
+
+	if (!i2s->force_clk_active) {
+		ret = clk_prepare_enable(i2s->clk_ref);
+		if (ret) {
+			dev_err(dev, "clk_enable failed: %d\n", ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static inline void img_i2s_out_writel(struct img_i2s_out *i2s, u32 val,
+					u32 reg)
+{
+	writel(val, i2s->base + reg);
+}
+
+static inline u32 img_i2s_out_readl(struct img_i2s_out *i2s, u32 reg)
+{
+	return readl(i2s->base + reg);
+}
+
+static inline void img_i2s_out_ch_writel(struct img_i2s_out *i2s,
+					u32 chan, u32 val, u32 reg)
+{
+	writel(val, i2s->channel_base + (chan * IMG_I2S_OUT_CH_STRIDE) + reg);
+}
+
+static inline u32 img_i2s_out_ch_readl(struct img_i2s_out *i2s, u32 chan,
+					u32 reg)
+{
+	return readl(i2s->channel_base + (chan * IMG_I2S_OUT_CH_STRIDE) + reg);
+}
+
+static inline u32 img_i2s_out_ch_disable(struct img_i2s_out *i2s, u32 chan)
+{
+	u32 reg;
+
+	reg = img_i2s_out_ch_readl(i2s, chan, IMG_I2S_OUT_CH_CTL);
+	reg &= ~IMG_I2S_OUT_CHAN_CTL_ME_MASK;
+	img_i2s_out_ch_writel(i2s, chan, reg, IMG_I2S_OUT_CH_CTL);
+
+	return reg;
+}
+
+static inline void img_i2s_out_ch_enable(struct img_i2s_out *i2s, u32 chan,
+					u32 reg)
+{
+	reg |= IMG_I2S_OUT_CHAN_CTL_ME_MASK;
+	img_i2s_out_ch_writel(i2s, chan, reg, IMG_I2S_OUT_CH_CTL);
+}
+
+static inline u32 img_i2s_out_disable(struct img_i2s_out *i2s)
+{
+	u32 reg;
+
+	reg = img_i2s_out_readl(i2s, IMG_I2S_OUT_CTL);
+	reg &= ~IMG_I2S_OUT_CTL_ME_MASK;
+	img_i2s_out_writel(i2s, reg, IMG_I2S_OUT_CTL);
+
+	return reg;
+}
+
+static inline void img_i2s_out_enable(struct img_i2s_out *i2s, u32 reg)
+{
+	reg |= IMG_I2S_OUT_CTL_ME_MASK;
+	img_i2s_out_writel(i2s, reg, IMG_I2S_OUT_CTL);
+}
+
+static void img_i2s_out_reset(struct img_i2s_out *i2s)
+{
+	int i;
+	u32 core_ctl, chan_ctl;
+
+	core_ctl = img_i2s_out_readl(i2s, IMG_I2S_OUT_CTL) &
+			~IMG_I2S_OUT_CTL_ME_MASK &
+			~IMG_I2S_OUT_CTL_DATA_EN_MASK;
+
+	if (!i2s->force_clk_active)
+		core_ctl &= ~IMG_I2S_OUT_CTL_CLK_EN_MASK;
+
+	chan_ctl = img_i2s_out_ch_readl(i2s, 0, IMG_I2S_OUT_CH_CTL) &
+			~IMG_I2S_OUT_CHAN_CTL_ME_MASK;
+
+	reset_control_assert(i2s->rst);
+	reset_control_deassert(i2s->rst);
+
+	for (i = 0; i < i2s->max_i2s_chan; i++)
+		img_i2s_out_ch_writel(i2s, i, chan_ctl, IMG_I2S_OUT_CH_CTL);
+
+	for (i = 0; i < i2s->active_channels; i++)
+		img_i2s_out_ch_enable(i2s, i, chan_ctl);
+
+	img_i2s_out_writel(i2s, core_ctl, IMG_I2S_OUT_CTL);
+	img_i2s_out_enable(i2s, core_ctl);
+}
+
+static int img_i2s_out_trigger(struct snd_pcm_substream *substream, int cmd,
+	struct snd_soc_dai *dai)
+{
+	struct img_i2s_out *i2s = snd_soc_dai_get_drvdata(dai);
+	u32 reg;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		reg = img_i2s_out_readl(i2s, IMG_I2S_OUT_CTL);
+		if (!i2s->force_clk_active)
+			reg |= IMG_I2S_OUT_CTL_CLK_EN_MASK;
+		reg |= IMG_I2S_OUT_CTL_DATA_EN_MASK;
+		img_i2s_out_writel(i2s, reg, IMG_I2S_OUT_CTL);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		img_i2s_out_reset(i2s);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int img_i2s_out_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct img_i2s_out *i2s = snd_soc_dai_get_drvdata(dai);
+	unsigned int channels, i2s_channels;
+	long pre_div_a, pre_div_b, diff_a, diff_b, rate, clk_rate;
+	int i;
+	u32 reg, control_reg, control_mask, control_set = 0;
+	snd_pcm_format_t format;
+
+	rate = params_rate(params);
+	format = params_format(params);
+	channels = params_channels(params);
+	i2s_channels = channels / 2;
+
+	if (format != SNDRV_PCM_FORMAT_S32_LE)
+		return -EINVAL;
+
+	if ((channels < 2) ||
+			(channels > (i2s->max_i2s_chan * 2)) ||
+			(channels % 2))
+		return -EINVAL;
+
+	pre_div_a = clk_round_rate(i2s->clk_ref, rate * 256);
+	if (pre_div_a < 0)
+		return pre_div_a;
+	pre_div_b = clk_round_rate(i2s->clk_ref, rate * 384);
+	if (pre_div_b < 0)
+		return pre_div_b;
+
+	diff_a = abs((pre_div_a / 256) - rate);
+	diff_b = abs((pre_div_b / 384) - rate);
+
+	/* If diffs are equal, use lower clock rate */
+	if (diff_a > diff_b)
+		clk_set_rate(i2s->clk_ref, pre_div_b);
+	else
+		clk_set_rate(i2s->clk_ref, pre_div_a);
+
+	/*
+	 * Another driver (eg alsa machine driver) may have rejected the above
+	 * change. Get the current rate and set the register bit according to
+	 * the new minimum diff
+	 */
+	clk_rate = clk_get_rate(i2s->clk_ref);
+
+	diff_a = abs((clk_rate / 256) - rate);
+	diff_b = abs((clk_rate / 384) - rate);
+
+	if (diff_a > diff_b)
+		control_set |= IMG_I2S_OUT_CTL_CLK_MASK;
+
+	control_set |= (((i2s_channels - 1) <<
+			IMG_I2S_OUT_CTL_ACTIVE_CHAN_SHIFT) &
+			IMG_I2S_OUT_CTL_ACTIVE_CHAN_MASK);
+
+	control_mask = (u32)(~IMG_I2S_OUT_CTL_CLK_MASK &
+			~IMG_I2S_OUT_CTL_ACTIVE_CHAN_MASK);
+
+	control_reg = img_i2s_out_disable(i2s);
+	control_reg = (control_reg & control_mask) | control_set;
+	img_i2s_out_writel(i2s, control_reg, IMG_I2S_OUT_CTL);
+
+	for (i = 0; i < i2s_channels; i++) {
+		reg = img_i2s_out_ch_readl(i2s, i, IMG_I2S_OUT_CH_CTL);
+		img_i2s_out_ch_enable(i2s, i, reg);
+	}
+
+	for (; i < i2s->max_i2s_chan; i++)
+		img_i2s_out_ch_disable(i2s, i);
+
+	img_i2s_out_enable(i2s, control_reg);
+
+	i2s->active_channels = i2s_channels;
+
+	return 0;
+}
+
+static int img_i2s_out_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	struct img_i2s_out *i2s = snd_soc_dai_get_drvdata(dai);
+	int i, ret = 0;
+	bool force_clk_active;
+	u32 chan_control_mask, control_mask, chan_control_set = 0;
+	u32 reg = 0, control_reg, control_set = 0;
+
+	force_clk_active = ((fmt & SND_SOC_DAIFMT_CLOCK_MASK) ==
+			SND_SOC_DAIFMT_CONT);
+
+	if (force_clk_active)
+		control_set |= IMG_I2S_OUT_CTL_CLK_EN_MASK;
+	else
+		control_set |= IMG_I2S_OUT_CTL_EXT_EN_CLK_MASK;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		control_set |= IMG_I2S_OUT_CTL_MASTER_MASK;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		control_set |= IMG_I2S_OUT_CTL_BCLK_POL_MASK;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		control_set |= IMG_I2S_OUT_CTL_BCLK_POL_MASK;
+		control_set |= IMG_I2S_OUT_CTL_FRM_CLK_POL_MASK;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		control_set |= IMG_I2S_OUT_CTL_FRM_CLK_POL_MASK;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		chan_control_set |= IMG_I2S_OUT_CHAN_CTL_CLKT_MASK;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	control_mask = (u32)(~IMG_I2S_OUT_CTL_CLK_EN_MASK &
+		~IMG_I2S_OUT_CTL_MASTER_MASK &
+		~IMG_I2S_OUT_CTL_BCLK_POL_MASK &
+		~IMG_I2S_OUT_CTL_FRM_CLK_POL_MASK &
+		~IMG_I2S_OUT_CTL_EXT_EN_CLK_MASK);
+
+	chan_control_mask = (u32)~IMG_I2S_OUT_CHAN_CTL_CLKT_MASK;
+
+	control_reg = img_i2s_out_disable(i2s);
+	control_reg = (control_reg & control_mask) | control_set;
+	img_i2s_out_writel(i2s, control_reg, IMG_I2S_OUT_CTL);
+
+	for (i = 0; i < i2s->active_channels; i++) {
+		reg = img_i2s_out_ch_disable(i2s, i);
+		reg = (reg & chan_control_mask) | chan_control_set;
+		img_i2s_out_ch_writel(i2s, i, reg, IMG_I2S_OUT_CH_CTL);
+		img_i2s_out_ch_enable(i2s, i, reg);
+	}
+
+	for (; i < i2s->max_i2s_chan; i++)
+		img_i2s_out_ch_writel(i2s, i, reg, IMG_I2S_OUT_CH_CTL);
+
+	img_i2s_out_enable(i2s, control_reg);
+
+	i2s->force_clk_active = force_clk_active;
+
+	return ret;
+}
+
+static int img_i2s_out_start_at(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *cpu_dai, int clock_type,
+		const struct timespec *ts)
+{
+	struct img_i2s_out *i2s = snd_soc_dai_get_drvdata(cpu_dai);
+	u32 reg;
+
+	if (!i2s->force_clk_active) {
+		reg = img_i2s_out_readl(i2s, IMG_I2S_OUT_CTL);
+		reg |= IMG_I2S_OUT_CTL_DATA_EN_MASK;
+		img_i2s_out_writel(i2s, reg, IMG_I2S_OUT_CTL);
+	}
+
+	return 0;
+}
+
+static int img_i2s_out_start_at_abort(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *cpu_dai)
+{
+	struct img_i2s_out *i2s = snd_soc_dai_get_drvdata(cpu_dai);
+
+	img_i2s_out_reset(i2s);
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops img_i2s_out_dai_ops = {
+	.trigger = img_i2s_out_trigger,
+	.hw_params = img_i2s_out_hw_params,
+	.set_fmt = img_i2s_out_set_fmt,
+	.start_at = img_i2s_out_start_at,
+	.start_at_abort = img_i2s_out_start_at_abort
+};
+
+static int img_i2s_out_dai_probe(struct snd_soc_dai *dai)
+{
+	struct img_i2s_out *i2s = snd_soc_dai_get_drvdata(dai);
+
+	snd_soc_dai_init_dma_data(dai, &i2s->dma_data, NULL);
+
+	return 0;
+}
+
+static const struct snd_soc_component_driver img_i2s_out_component = {
+	.name = "img-i2s-out"
+};
+
+static int img_i2s_out_dma_prepare_slave_config(struct snd_pcm_substream *st,
+	struct snd_pcm_hw_params *params, struct dma_slave_config *sc)
+{
+	unsigned int i2s_channels = params_channels(params) / 2;
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct snd_dmaengine_dai_dma_data *dma_data;
+	int ret;
+
+	dma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, st);
+
+	ret = snd_hwparams_to_dma_slave_config(st, params, sc);
+	if (ret)
+		return ret;
+
+	sc->dst_addr = dma_data->addr;
+	sc->dst_addr_width = dma_data->addr_width;
+	sc->dst_maxburst = 4 * i2s_channels;
+
+	return 0;
+}
+
+static const struct snd_dmaengine_pcm_config img_i2s_out_dma_config = {
+	.prepare_slave_config = img_i2s_out_dma_prepare_slave_config
+};
+
+static int img_i2s_out_probe(struct platform_device *pdev)
+{
+	struct img_i2s_out *i2s;
+	struct resource *res;
+	void __iomem *base;
+	int i, ret;
+	unsigned int max_i2s_chan_pow_2;
+	u32 reg;
+
+	i2s = devm_kzalloc(&pdev->dev, sizeof(*i2s), GFP_KERNEL);
+	if (!i2s)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, i2s);
+
+	i2s->dev = &pdev->dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	i2s->base = base;
+
+	if (of_property_read_u32(pdev->dev.of_node, "img,i2s-channels",
+			&i2s->max_i2s_chan)) {
+		dev_err(&pdev->dev, "No img,i2s-channels property\n");
+		return -EINVAL;
+	}
+
+	max_i2s_chan_pow_2 = 1 << get_count_order(i2s->max_i2s_chan);
+
+	i2s->channel_base = base + (max_i2s_chan_pow_2 * 0x20);
+
+	i2s->rst = devm_reset_control_get(&pdev->dev, "rst");
+	if (IS_ERR(i2s->rst)) {
+		dev_err(&pdev->dev, "No top level reset found\n");
+		return PTR_ERR(i2s->rst);
+	}
+
+	i2s->clk_sys = devm_clk_get(&pdev->dev, "sys");
+	if (IS_ERR(i2s->clk_sys))
+		return PTR_ERR(i2s->clk_sys);
+
+	i2s->clk_ref = devm_clk_get(&pdev->dev, "ref");
+	if (IS_ERR(i2s->clk_ref))
+		return PTR_ERR(i2s->clk_ref);
+
+	ret = clk_prepare_enable(i2s->clk_sys);
+	if (ret)
+		return ret;
+
+	reg = IMG_I2S_OUT_CTL_FRM_SIZE_MASK;
+	img_i2s_out_writel(i2s, reg, IMG_I2S_OUT_CTL);
+
+	reg = IMG_I2S_OUT_CHAN_CTL_JUST_MASK |
+		IMG_I2S_OUT_CHAN_CTL_LT_MASK |
+		IMG_I2S_OUT_CHAN_CTL_CH_MASK |
+		(8 << IMG_I2S_OUT_CHAN_CTL_FMT_SHIFT);
+
+	for (i = 0; i < i2s->max_i2s_chan; i++)
+		img_i2s_out_ch_writel(i2s, i, reg, IMG_I2S_OUT_CH_CTL);
+
+	img_i2s_out_reset(i2s);
+
+	pm_runtime_enable(&pdev->dev);
+	if (!pm_runtime_enabled(&pdev->dev)) {
+		ret = img_i2s_out_resume(&pdev->dev);
+		if (ret)
+			goto err_pm_disable;
+	}
+
+	i2s->active_channels = 1;
+	i2s->dma_data.addr = res->start + IMG_I2S_OUT_TX_FIFO;
+	i2s->dma_data.addr_width = 4;
+	i2s->dma_data.maxburst = 4;
+
+	i2s->dai_driver.probe = img_i2s_out_dai_probe;
+	i2s->dai_driver.playback.channels_min = 2;
+	i2s->dai_driver.playback.channels_max = i2s->max_i2s_chan * 2;
+	i2s->dai_driver.playback.rates = SNDRV_PCM_RATE_8000_192000;
+	i2s->dai_driver.playback.formats = SNDRV_PCM_FMTBIT_S32_LE;
+	i2s->dai_driver.ops = &img_i2s_out_dai_ops;
+
+	ret = devm_snd_soc_register_component(&pdev->dev,
+			&img_i2s_out_component, &i2s->dai_driver, 1);
+	if (ret)
+		goto err_suspend;
+
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev,
+			&img_i2s_out_dma_config,
+			SND_DMAENGINE_PCM_FLAG_EARLY_START);
+	if (ret)
+		goto err_suspend;
+
+	return 0;
+
+err_suspend:
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		img_i2s_out_suspend(&pdev->dev);
+err_pm_disable:
+	pm_runtime_disable(&pdev->dev);
+	clk_disable_unprepare(i2s->clk_sys);
+
+	return ret;
+}
+
+static int img_i2s_out_dev_remove(struct platform_device *pdev)
+{
+	struct img_i2s_out *i2s = platform_get_drvdata(pdev);
+
+	pm_runtime_disable(&pdev->dev);
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		img_i2s_out_suspend(&pdev->dev);
+
+	clk_disable_unprepare(i2s->clk_sys);
+
+	return 0;
+}
+
+static const struct of_device_id img_i2s_out_of_match[] = {
+	{ .compatible = "img,i2s-out" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, img_i2s_out_of_match);
+
+static const struct dev_pm_ops img_i2s_out_pm_ops = {
+	SET_RUNTIME_PM_OPS(img_i2s_out_suspend,
+			   img_i2s_out_resume, NULL)
+};
+
+static struct platform_driver img_i2s_out_driver = {
+	.driver = {
+		.name = "img-i2s-out",
+		.of_match_table = img_i2s_out_of_match,
+		.pm = &img_i2s_out_pm_ops
+	},
+	.probe = img_i2s_out_probe,
+	.remove = img_i2s_out_dev_remove
+};
+module_platform_driver(img_i2s_out_driver);
+
+MODULE_AUTHOR("Damien Horsley <Damien.Horsley@imgtec.com>");
+MODULE_DESCRIPTION("IMG I2S Output Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/img/img-parallel-out.c b/sound/soc/img/img-parallel-out.c
new file mode 100644
index 0000000..4c232a9
--- /dev/null
+++ b/sound/soc/img/img-parallel-out.c
@@ -0,0 +1,404 @@
+/*
+ * IMG parallel output controller driver
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/reset.h>
+
+#include <sound/core.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#define IMG_PRL_OUT_TX_FIFO		0
+
+#define IMG_PRL_OUT_CTL			0x4
+#define IMG_PRL_OUT_CTL_CH_MASK		BIT(4)
+#define IMG_PRL_OUT_CTL_PACKH_MASK	BIT(3)
+#define IMG_PRL_OUT_CTL_EDGE_MASK	BIT(2)
+#define IMG_PRL_OUT_CTL_ME_MASK		BIT(1)
+#define IMG_PRL_OUT_CTL_SRST_MASK	BIT(0)
+
+static const char *const img_prl_out_edge_names[] = { "Rising", "Falling" };
+
+struct img_prl_out {
+	spinlock_t lock;
+	void __iomem *base;
+	struct clk *clk_sys;
+	struct clk *clk_ref;
+	struct snd_dmaengine_dai_dma_data dma_data;
+	struct device *dev;
+	bool active;
+	struct reset_control *rst;
+};
+
+static int img_prl_out_suspend(struct device *dev)
+{
+	struct img_prl_out *prl = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(prl->clk_ref);
+
+	return 0;
+}
+
+static int img_prl_out_resume(struct device *dev)
+{
+	struct img_prl_out *prl = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_prepare_enable(prl->clk_ref);
+	if (ret) {
+		dev_err(dev, "clk_enable failed: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static inline void img_prl_out_writel(struct img_prl_out *prl,
+				u32 val, u32 reg)
+{
+	writel(val, prl->base + reg);
+}
+
+static inline u32 img_prl_out_readl(struct img_prl_out *prl, u32 reg)
+{
+	return readl(prl->base + reg);
+}
+
+static void img_prl_out_reset(struct img_prl_out *prl)
+{
+	u32 ctl;
+
+	ctl = img_prl_out_readl(prl, IMG_PRL_OUT_CTL) &
+			~IMG_PRL_OUT_CTL_ME_MASK;
+
+	reset_control_assert(prl->rst);
+	reset_control_deassert(prl->rst);
+
+	img_prl_out_writel(prl, ctl, IMG_PRL_OUT_CTL);
+}
+
+static int img_prl_out_edge_info(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_info *uinfo)
+{
+	return snd_ctl_enum_info(uinfo, 1, 2, img_prl_out_edge_names);
+}
+
+static int img_prl_out_get_edge(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct img_prl_out *prl = snd_soc_dai_get_drvdata(cpu_dai);
+	u32 reg;
+	unsigned long flags;
+
+	spin_lock_irqsave(&prl->lock, flags);
+	reg = img_prl_out_readl(prl, IMG_PRL_OUT_CTL);
+	ucontrol->value.integer.value[0] = !!(reg & IMG_PRL_OUT_CTL_EDGE_MASK);
+	spin_unlock_irqrestore(&prl->lock, flags);
+
+	return 0;
+}
+
+static int img_prl_out_set_edge(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct img_prl_out *prl = snd_soc_dai_get_drvdata(cpu_dai);
+	unsigned long flags;
+	int ret = 0;
+	u32 reg;
+
+	spin_lock_irqsave(&prl->lock, flags);
+	if (prl->active) {
+		ret = -EBUSY;
+	} else {
+		reg = img_prl_out_readl(prl, IMG_PRL_OUT_CTL);
+		if (ucontrol->value.integer.value[0])
+			reg |= IMG_PRL_OUT_CTL_EDGE_MASK;
+		else
+			reg &= ~IMG_PRL_OUT_CTL_EDGE_MASK;
+		img_prl_out_writel(prl, reg, IMG_PRL_OUT_CTL);
+	}
+	spin_unlock_irqrestore(&prl->lock, flags);
+
+	return ret;
+}
+
+static struct snd_kcontrol_new img_prl_out_controls[] = {
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = "Parallel Out Edge Falling",
+		.info = img_prl_out_edge_info,
+		.get = img_prl_out_get_edge,
+		.put = img_prl_out_set_edge
+	}
+};
+
+static int img_prl_out_trigger(struct snd_pcm_substream *substream, int cmd,
+			struct snd_soc_dai *dai)
+{
+	struct img_prl_out *prl = snd_soc_dai_get_drvdata(dai);
+	unsigned long flags;
+	int ret = 0;
+	u32 reg;
+
+	spin_lock_irqsave(&prl->lock, flags);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		reg = img_prl_out_readl(prl, IMG_PRL_OUT_CTL);
+		reg |= IMG_PRL_OUT_CTL_ME_MASK;
+		img_prl_out_writel(prl, reg, IMG_PRL_OUT_CTL);
+		prl->active = true;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		img_prl_out_reset(prl);
+		prl->active = false;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	spin_unlock_irqrestore(&prl->lock, flags);
+
+	return ret;
+}
+
+static int img_prl_out_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct img_prl_out *prl = snd_soc_dai_get_drvdata(dai);
+	unsigned int rate, channels;
+	u32 reg, reg_set = 0;
+	unsigned long flags;
+	snd_pcm_format_t format;
+
+	rate = params_rate(params);
+	format = params_format(params);
+	channels = params_channels(params);
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S32_LE:
+		reg_set |= IMG_PRL_OUT_CTL_PACKH_MASK;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (channels != 2)
+		return -EINVAL;
+
+	clk_set_rate(prl->clk_ref, rate * 256);
+
+	spin_lock_irqsave(&prl->lock, flags);
+	reg = img_prl_out_readl(prl, IMG_PRL_OUT_CTL);
+	reg = (reg & ~IMG_PRL_OUT_CTL_PACKH_MASK) | reg_set;
+	img_prl_out_writel(prl, reg, IMG_PRL_OUT_CTL);
+	spin_unlock_irqrestore(&prl->lock, flags);
+
+	return 0;
+}
+
+static int img_prl_out_start_at(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *cpu_dai, int clock_type,
+		const struct timespec *ts)
+{
+	struct img_prl_out *prl = snd_soc_dai_get_drvdata(cpu_dai);
+	unsigned long flags;
+
+	spin_lock_irqsave(&prl->lock, flags);
+	prl->active = true;
+	spin_unlock_irqrestore(&prl->lock, flags);
+
+	return 0;
+}
+
+static int img_prl_out_start_at_abort(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *cpu_dai)
+{
+	struct img_prl_out *prl = snd_soc_dai_get_drvdata(cpu_dai);
+	unsigned long flags;
+
+	spin_lock_irqsave(&prl->lock, flags);
+	prl->active = false;
+	img_prl_out_reset(prl);
+	spin_unlock_irqrestore(&prl->lock, flags);
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops img_prl_out_dai_ops = {
+	.trigger = img_prl_out_trigger,
+	.hw_params = img_prl_out_hw_params,
+	.start_at = img_prl_out_start_at,
+	.start_at_abort = img_prl_out_start_at_abort
+};
+
+static int img_prl_out_dai_probe(struct snd_soc_dai *dai)
+{
+	struct img_prl_out *prl = snd_soc_dai_get_drvdata(dai);
+
+	snd_soc_dai_init_dma_data(dai, &prl->dma_data, NULL);
+
+	snd_soc_add_dai_controls(dai, img_prl_out_controls,
+			ARRAY_SIZE(img_prl_out_controls));
+
+	return 0;
+}
+
+static struct snd_soc_dai_driver img_prl_out_dai = {
+	.probe = img_prl_out_dai_probe,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_192000,
+		.formats = SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_S24_LE
+	},
+	.ops = &img_prl_out_dai_ops
+};
+
+static const struct snd_soc_component_driver img_prl_out_component = {
+	.name = "img-prl-out"
+};
+
+static int img_prl_out_probe(struct platform_device *pdev)
+{
+	struct img_prl_out *prl;
+	struct resource *res;
+	void __iomem *base;
+	int ret;
+
+	prl = devm_kzalloc(&pdev->dev, sizeof(*prl), GFP_KERNEL);
+	if (!prl)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, prl);
+
+	prl->dev = &pdev->dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	prl->base = base;
+
+	prl->rst = devm_reset_control_get(&pdev->dev, "rst");
+	if (IS_ERR(prl->rst)) {
+		dev_err(&pdev->dev, "No top level reset found\n");
+		return PTR_ERR(prl->rst);
+	}
+
+	prl->clk_sys = devm_clk_get(&pdev->dev, "sys");
+	if (IS_ERR(prl->clk_sys))
+		return PTR_ERR(prl->clk_sys);
+
+	prl->clk_ref = devm_clk_get(&pdev->dev, "ref");
+	if (IS_ERR(prl->clk_ref))
+		return PTR_ERR(prl->clk_ref);
+
+	ret = clk_prepare_enable(prl->clk_sys);
+	if (ret)
+		return ret;
+
+	img_prl_out_writel(prl, IMG_PRL_OUT_CTL_EDGE_MASK, IMG_PRL_OUT_CTL);
+	img_prl_out_reset(prl);
+
+	pm_runtime_enable(&pdev->dev);
+	if (!pm_runtime_enabled(&pdev->dev)) {
+		ret = img_prl_out_resume(&pdev->dev);
+		if (ret)
+			goto err_pm_disable;
+	}
+
+	spin_lock_init(&prl->lock);
+
+	prl->dma_data.addr = res->start + IMG_PRL_OUT_TX_FIFO;
+	prl->dma_data.addr_width = 4;
+	prl->dma_data.maxburst = 4;
+
+	ret = devm_snd_soc_register_component(&pdev->dev,
+			&img_prl_out_component,
+			&img_prl_out_dai, 1);
+	if (ret)
+		goto err_suspend;
+
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL,
+			SND_DMAENGINE_PCM_FLAG_EARLY_START);
+	if (ret)
+		goto err_suspend;
+
+	return 0;
+
+err_suspend:
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		img_prl_out_suspend(&pdev->dev);
+err_pm_disable:
+	pm_runtime_disable(&pdev->dev);
+	clk_disable_unprepare(prl->clk_sys);
+
+	return ret;
+}
+
+static int img_prl_out_dev_remove(struct platform_device *pdev)
+{
+	struct img_prl_out *prl = platform_get_drvdata(pdev);
+
+	pm_runtime_disable(&pdev->dev);
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		img_prl_out_suspend(&pdev->dev);
+
+	clk_disable_unprepare(prl->clk_sys);
+
+	return 0;
+}
+
+static const struct of_device_id img_prl_out_of_match[] = {
+	{ .compatible = "img,parallel-out" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, img_prl_out_of_match);
+
+static const struct dev_pm_ops img_prl_out_pm_ops = {
+	SET_RUNTIME_PM_OPS(img_prl_out_suspend,
+			   img_prl_out_resume, NULL)
+};
+
+static struct platform_driver img_prl_out_driver = {
+	.driver = {
+		.name = "img-parallel-out",
+		.of_match_table = img_prl_out_of_match,
+		.pm = &img_prl_out_pm_ops
+	},
+	.probe = img_prl_out_probe,
+	.remove = img_prl_out_dev_remove
+};
+module_platform_driver(img_prl_out_driver);
+
+MODULE_AUTHOR("Damien Horsley <Damien.Horsley@imgtec.com>");
+MODULE_DESCRIPTION("IMG Parallel Output Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/img/img-spdif-in.c b/sound/soc/img/img-spdif-in.c
new file mode 100644
index 0000000..b388b2d
--- /dev/null
+++ b/sound/soc/img/img-spdif-in.c
@@ -0,0 +1,799 @@
+/*
+ * IMG SPDIF input controller driver
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/reset.h>
+
+#include <sound/core.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#define IMG_SPDIF_IN_RX_FIFO_OFFSET		0
+
+#define IMG_SPDIF_IN_CTL			0x4
+#define IMG_SPDIF_IN_CTL_LOCKLO_MASK		0xff
+#define IMG_SPDIF_IN_CTL_LOCKLO_SHIFT		0
+#define IMG_SPDIF_IN_CTL_LOCKHI_MASK		0xff00
+#define IMG_SPDIF_IN_CTL_LOCKHI_SHIFT		8
+#define IMG_SPDIF_IN_CTL_TRK_MASK		0xff0000
+#define IMG_SPDIF_IN_CTL_TRK_SHIFT		16
+#define IMG_SPDIF_IN_CTL_SRD_MASK		0x70000000
+#define IMG_SPDIF_IN_CTL_SRD_SHIFT		28
+#define IMG_SPDIF_IN_CTL_SRT_MASK		BIT(31)
+
+#define IMG_SPDIF_IN_STATUS			0x8
+#define IMG_SPDIF_IN_STATUS_SAM_MASK		0x7000
+#define IMG_SPDIF_IN_STATUS_SAM_SHIFT		12
+#define IMG_SPDIF_IN_STATUS_LOCK_MASK		BIT(15)
+#define IMG_SPDIF_IN_STATUS_LOCK_SHIFT		15
+
+#define IMG_SPDIF_IN_CLKGEN			0x1c
+#define IMG_SPDIF_IN_CLKGEN_NOM_MASK		0x3ff
+#define IMG_SPDIF_IN_CLKGEN_NOM_SHIFT		0
+#define IMG_SPDIF_IN_CLKGEN_HLD_MASK		0x3ff0000
+#define IMG_SPDIF_IN_CLKGEN_HLD_SHIFT		16
+
+#define IMG_SPDIF_IN_CSL			0x20
+
+#define IMG_SPDIF_IN_CSH			0x24
+#define IMG_SPDIF_IN_CSH_MASK			0xff
+#define IMG_SPDIF_IN_CSH_SHIFT			0
+
+#define IMG_SPDIF_IN_SOFT_RESET			0x28
+#define IMG_SPDIF_IN_SOFT_RESET_MASK		BIT(0)
+
+#define IMG_SPDIF_IN_ACLKGEN_START		0x2c
+#define IMG_SPDIF_IN_ACLKGEN_NOM_MASK		0x3ff
+#define IMG_SPDIF_IN_ACLKGEN_NOM_SHIFT		0
+#define IMG_SPDIF_IN_ACLKGEN_HLD_MASK		0xffc00
+#define IMG_SPDIF_IN_ACLKGEN_HLD_SHIFT		10
+#define IMG_SPDIF_IN_ACLKGEN_TRK_MASK		0xff00000
+#define IMG_SPDIF_IN_ACLKGEN_TRK_SHIFT		20
+
+#define IMG_SPDIF_IN_NUM_ACLKGEN		4
+
+struct img_spdif_in {
+	spinlock_t lock;
+	void __iomem *base;
+	struct clk *clk_sys;
+	struct snd_dmaengine_dai_dma_data dma_data;
+	struct device *dev;
+	unsigned int trk;
+	bool multi_freq;
+	int lock_acquire;
+	int lock_release;
+	unsigned int single_freq;
+	unsigned int multi_freqs[IMG_SPDIF_IN_NUM_ACLKGEN];
+	bool active;
+
+	/* Write-only registers */
+	unsigned int aclkgen_regs[IMG_SPDIF_IN_NUM_ACLKGEN];
+};
+
+static inline void img_spdif_in_writel(struct img_spdif_in *spdif,
+					u32 val, u32 reg)
+{
+	writel(val, spdif->base + reg);
+}
+
+static inline u32 img_spdif_in_readl(struct img_spdif_in *spdif, u32 reg)
+{
+	return readl(spdif->base + reg);
+}
+
+static inline void img_spdif_in_aclkgen_writel(struct img_spdif_in *spdif,
+						u32 index)
+{
+	img_spdif_in_writel(spdif, spdif->aclkgen_regs[index],
+			IMG_SPDIF_IN_ACLKGEN_START + (index * 0x4));
+}
+
+static int img_spdif_in_check_max_rate(struct img_spdif_in *spdif,
+		unsigned int sample_rate, unsigned long *actual_freq)
+{
+	unsigned long min_freq, freq_t;
+
+	/* Clock rate must be at least 24x the bit rate */
+	min_freq = sample_rate * 2 * 32 * 24;
+
+	freq_t = clk_get_rate(spdif->clk_sys);
+
+	if (freq_t < min_freq)
+		return -EINVAL;
+
+	*actual_freq = freq_t;
+
+	return 0;
+}
+
+static int img_spdif_in_do_clkgen_calc(unsigned int rate, unsigned int *pnom,
+		unsigned int *phld, unsigned long clk_rate)
+{
+	unsigned int ori, nom, hld;
+
+	/*
+	 * Calculate oversampling ratio, nominal phase increment and hold
+	 * increment for the given rate / frequency
+	 */
+
+	if (!rate)
+		return -EINVAL;
+
+	ori = clk_rate / (rate * 64);
+
+	if (!ori)
+		return -EINVAL;
+
+	nom = (4096 / ori) + 1;
+	do
+		hld = 4096 - (--nom * (ori - 1));
+	while (hld < 120);
+
+	*pnom = nom;
+	*phld = hld;
+
+	return 0;
+}
+
+static int img_spdif_in_do_clkgen_single(struct img_spdif_in *spdif,
+		unsigned int rate)
+{
+	unsigned int nom, hld;
+	unsigned long flags, clk_rate;
+	int ret = 0;
+	u32 reg;
+
+	ret = img_spdif_in_check_max_rate(spdif, rate, &clk_rate);
+	if (ret)
+		return ret;
+
+	ret = img_spdif_in_do_clkgen_calc(rate, &nom, &hld, clk_rate);
+	if (ret)
+		return ret;
+
+	reg = (nom << IMG_SPDIF_IN_CLKGEN_NOM_SHIFT) &
+		IMG_SPDIF_IN_CLKGEN_NOM_MASK;
+	reg |= (hld << IMG_SPDIF_IN_CLKGEN_HLD_SHIFT) &
+		IMG_SPDIF_IN_CLKGEN_HLD_MASK;
+
+	spin_lock_irqsave(&spdif->lock, flags);
+
+	if (spdif->active) {
+		spin_unlock_irqrestore(&spdif->lock, flags);
+		return -EBUSY;
+	}
+
+	img_spdif_in_writel(spdif, reg, IMG_SPDIF_IN_CLKGEN);
+
+	spdif->single_freq = rate;
+
+	spin_unlock_irqrestore(&spdif->lock, flags);
+
+	return 0;
+}
+
+static int img_spdif_in_do_clkgen_multi(struct img_spdif_in *spdif,
+		unsigned int multi_freqs[])
+{
+	unsigned int nom, hld, rate, max_rate = 0;
+	unsigned long flags, clk_rate;
+	int i, ret = 0;
+	u32 reg, trk_reg, temp_regs[IMG_SPDIF_IN_NUM_ACLKGEN];
+
+	for (i = 0; i < IMG_SPDIF_IN_NUM_ACLKGEN; i++)
+		if (multi_freqs[i] > max_rate)
+			max_rate = multi_freqs[i];
+
+	ret = img_spdif_in_check_max_rate(spdif, max_rate, &clk_rate);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < IMG_SPDIF_IN_NUM_ACLKGEN; i++) {
+		rate = multi_freqs[i];
+
+		ret = img_spdif_in_do_clkgen_calc(rate, &nom, &hld, clk_rate);
+		if (ret)
+			return ret;
+
+		reg = (nom << IMG_SPDIF_IN_ACLKGEN_NOM_SHIFT) &
+			IMG_SPDIF_IN_ACLKGEN_NOM_MASK;
+		reg |= (hld << IMG_SPDIF_IN_ACLKGEN_HLD_SHIFT) &
+			IMG_SPDIF_IN_ACLKGEN_HLD_MASK;
+		temp_regs[i] = reg;
+	}
+
+	spin_lock_irqsave(&spdif->lock, flags);
+
+	if (spdif->active) {
+		spin_unlock_irqrestore(&spdif->lock, flags);
+		return -EBUSY;
+	}
+
+	trk_reg = spdif->trk << IMG_SPDIF_IN_ACLKGEN_TRK_SHIFT;
+
+	for (i = 0; i < IMG_SPDIF_IN_NUM_ACLKGEN; i++) {
+		spdif->aclkgen_regs[i] = temp_regs[i] | trk_reg;
+		img_spdif_in_aclkgen_writel(spdif, i);
+	}
+
+	spdif->multi_freq = true;
+	spdif->multi_freqs[0] = multi_freqs[0];
+	spdif->multi_freqs[1] = multi_freqs[1];
+	spdif->multi_freqs[2] = multi_freqs[2];
+	spdif->multi_freqs[3] = multi_freqs[3];
+
+	spin_unlock_irqrestore(&spdif->lock, flags);
+
+	return 0;
+}
+
+static int img_spdif_in_iec958_info(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+
+	return 0;
+}
+
+static int img_spdif_in_get_status_mask(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.iec958.status[0] = 0xff;
+	ucontrol->value.iec958.status[1] = 0xff;
+	ucontrol->value.iec958.status[2] = 0xff;
+	ucontrol->value.iec958.status[3] = 0xff;
+	ucontrol->value.iec958.status[4] = 0xff;
+
+	return 0;
+}
+
+static int img_spdif_in_get_status(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct img_spdif_in *spdif = snd_soc_dai_get_drvdata(cpu_dai);
+	u32 reg;
+
+	reg = img_spdif_in_readl(spdif, IMG_SPDIF_IN_CSL);
+	ucontrol->value.iec958.status[0] = reg & 0xff;
+	ucontrol->value.iec958.status[1] = (reg >> 8) & 0xff;
+	ucontrol->value.iec958.status[2] = (reg >> 16) & 0xff;
+	ucontrol->value.iec958.status[3] = (reg >> 24) & 0xff;
+	reg = img_spdif_in_readl(spdif, IMG_SPDIF_IN_CSH);
+	ucontrol->value.iec958.status[4] = (reg & IMG_SPDIF_IN_CSH_MASK)
+		>> IMG_SPDIF_IN_CSH_SHIFT;
+
+	return 0;
+}
+
+static int img_spdif_in_info_multi_freq(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = IMG_SPDIF_IN_NUM_ACLKGEN;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = LONG_MAX;
+
+	return 0;
+}
+
+static int img_spdif_in_get_multi_freq(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct img_spdif_in *spdif = snd_soc_dai_get_drvdata(cpu_dai);
+	unsigned long flags;
+
+	spin_lock_irqsave(&spdif->lock, flags);
+	if (spdif->multi_freq) {
+		ucontrol->value.integer.value[0] = spdif->multi_freqs[0];
+		ucontrol->value.integer.value[1] = spdif->multi_freqs[1];
+		ucontrol->value.integer.value[2] = spdif->multi_freqs[2];
+		ucontrol->value.integer.value[3] = spdif->multi_freqs[3];
+	} else {
+		ucontrol->value.integer.value[0] = 0;
+		ucontrol->value.integer.value[1] = 0;
+		ucontrol->value.integer.value[2] = 0;
+		ucontrol->value.integer.value[3] = 0;
+	}
+	spin_unlock_irqrestore(&spdif->lock, flags);
+
+	return 0;
+}
+
+static int img_spdif_in_set_multi_freq(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct img_spdif_in *spdif = snd_soc_dai_get_drvdata(cpu_dai);
+	unsigned int multi_freqs[IMG_SPDIF_IN_NUM_ACLKGEN];
+	bool multi_freq;
+	unsigned long flags;
+
+	if ((ucontrol->value.integer.value[0] == 0) &&
+			(ucontrol->value.integer.value[1] == 0) &&
+			(ucontrol->value.integer.value[2] == 0) &&
+			(ucontrol->value.integer.value[3] == 0)) {
+		multi_freq = false;
+	} else {
+		multi_freqs[0] = ucontrol->value.integer.value[0];
+		multi_freqs[1] = ucontrol->value.integer.value[1];
+		multi_freqs[2] = ucontrol->value.integer.value[2];
+		multi_freqs[3] = ucontrol->value.integer.value[3];
+		multi_freq = true;
+	}
+
+	if (multi_freq)
+		return img_spdif_in_do_clkgen_multi(spdif, multi_freqs);
+
+	spin_lock_irqsave(&spdif->lock, flags);
+
+	if (spdif->active) {
+		spin_unlock_irqrestore(&spdif->lock, flags);
+		return -EBUSY;
+	}
+
+	spdif->multi_freq = false;
+
+	spin_unlock_irqrestore(&spdif->lock, flags);
+
+	return 0;
+}
+
+static int img_spdif_in_info_lock_freq(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = LONG_MAX;
+
+	return 0;
+}
+
+static int img_spdif_in_get_lock_freq(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *uc)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct img_spdif_in *spdif = snd_soc_dai_get_drvdata(cpu_dai);
+	u32 reg;
+	int i;
+	unsigned long flags;
+
+	spin_lock_irqsave(&spdif->lock, flags);
+
+	reg = img_spdif_in_readl(spdif, IMG_SPDIF_IN_STATUS);
+	if (reg & IMG_SPDIF_IN_STATUS_LOCK_MASK) {
+		if (spdif->multi_freq) {
+			i = ((reg & IMG_SPDIF_IN_STATUS_SAM_MASK) >>
+					IMG_SPDIF_IN_STATUS_SAM_SHIFT) - 1;
+			uc->value.integer.value[0] = spdif->multi_freqs[i];
+		} else {
+			uc->value.integer.value[0] = spdif->single_freq;
+		}
+	} else {
+		uc->value.integer.value[0] = 0;
+	}
+
+	spin_unlock_irqrestore(&spdif->lock, flags);
+
+	return 0;
+}
+
+static int img_spdif_in_info_trk(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 255;
+
+	return 0;
+}
+
+static int img_spdif_in_get_trk(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct img_spdif_in *spdif = snd_soc_dai_get_drvdata(cpu_dai);
+
+	ucontrol->value.integer.value[0] = spdif->trk;
+
+	return 0;
+}
+
+static int img_spdif_in_set_trk(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct img_spdif_in *spdif = snd_soc_dai_get_drvdata(cpu_dai);
+	unsigned long flags;
+	int i;
+	u32 reg;
+
+	spin_lock_irqsave(&spdif->lock, flags);
+
+	if (spdif->active) {
+		spin_unlock_irqrestore(&spdif->lock, flags);
+		return -EBUSY;
+	}
+
+	spdif->trk = ucontrol->value.integer.value[0];
+
+	reg = img_spdif_in_readl(spdif, IMG_SPDIF_IN_CTL);
+	reg &= ~IMG_SPDIF_IN_CTL_TRK_MASK;
+	reg |= spdif->trk << IMG_SPDIF_IN_CTL_TRK_SHIFT;
+	img_spdif_in_writel(spdif, reg, IMG_SPDIF_IN_CTL);
+
+	for (i = 0; i < IMG_SPDIF_IN_NUM_ACLKGEN; i++) {
+		spdif->aclkgen_regs[i] = (spdif->aclkgen_regs[i] &
+			~IMG_SPDIF_IN_ACLKGEN_TRK_MASK) |
+			(spdif->trk << IMG_SPDIF_IN_ACLKGEN_TRK_SHIFT);
+
+		img_spdif_in_aclkgen_writel(spdif, i);
+	}
+
+	spin_unlock_irqrestore(&spdif->lock, flags);
+
+	return 0;
+}
+
+static int img_spdif_in_info_lock(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = -128;
+	uinfo->value.integer.max = 127;
+
+	return 0;
+}
+
+static int img_spdif_in_get_lock_acquire(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct img_spdif_in *spdif = snd_soc_dai_get_drvdata(cpu_dai);
+
+	ucontrol->value.integer.value[0] = spdif->lock_acquire;
+
+	return 0;
+}
+
+static int img_spdif_in_set_lock_acquire(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct img_spdif_in *spdif = snd_soc_dai_get_drvdata(cpu_dai);
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&spdif->lock, flags);
+
+	if (spdif->active) {
+		spin_unlock_irqrestore(&spdif->lock, flags);
+		return -EBUSY;
+	}
+
+	spdif->lock_acquire = ucontrol->value.integer.value[0];
+
+	reg = img_spdif_in_readl(spdif, IMG_SPDIF_IN_CTL);
+	reg &= ~IMG_SPDIF_IN_CTL_LOCKHI_MASK;
+	reg |= (spdif->lock_acquire << IMG_SPDIF_IN_CTL_LOCKHI_SHIFT) &
+		IMG_SPDIF_IN_CTL_LOCKHI_MASK;
+	img_spdif_in_writel(spdif, reg, IMG_SPDIF_IN_CTL);
+
+	spin_unlock_irqrestore(&spdif->lock, flags);
+
+	return 0;
+}
+
+static int img_spdif_in_get_lock_release(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct img_spdif_in *spdif = snd_soc_dai_get_drvdata(cpu_dai);
+
+	ucontrol->value.integer.value[0] = spdif->lock_release;
+
+	return 0;
+}
+
+static int img_spdif_in_set_lock_release(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct img_spdif_in *spdif = snd_soc_dai_get_drvdata(cpu_dai);
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&spdif->lock, flags);
+
+	if (spdif->active) {
+		spin_unlock_irqrestore(&spdif->lock, flags);
+		return -EBUSY;
+	}
+
+	spdif->lock_release = ucontrol->value.integer.value[0];
+
+	reg = img_spdif_in_readl(spdif, IMG_SPDIF_IN_CTL);
+	reg &= ~IMG_SPDIF_IN_CTL_LOCKLO_MASK;
+	reg |= (spdif->lock_release << IMG_SPDIF_IN_CTL_LOCKLO_SHIFT) &
+		IMG_SPDIF_IN_CTL_LOCKLO_MASK;
+	img_spdif_in_writel(spdif, reg, IMG_SPDIF_IN_CTL);
+
+	spin_unlock_irqrestore(&spdif->lock, flags);
+
+	return 0;
+}
+
+static struct snd_kcontrol_new img_spdif_in_controls[] = {
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READ,
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = SNDRV_CTL_NAME_IEC958("", CAPTURE, MASK),
+		.info = img_spdif_in_iec958_info,
+		.get = img_spdif_in_get_status_mask
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = SNDRV_CTL_NAME_IEC958("", CAPTURE, DEFAULT),
+		.info = img_spdif_in_iec958_info,
+		.get = img_spdif_in_get_status
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = "SPDIF In Multi Frequency Acquire",
+		.info = img_spdif_in_info_multi_freq,
+		.get = img_spdif_in_get_multi_freq,
+		.put = img_spdif_in_set_multi_freq
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = "SPDIF In Lock Frequency",
+		.info = img_spdif_in_info_lock_freq,
+		.get = img_spdif_in_get_lock_freq
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = "SPDIF In Lock TRK",
+		.info = img_spdif_in_info_trk,
+		.get = img_spdif_in_get_trk,
+		.put = img_spdif_in_set_trk
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = "SPDIF In Lock Acquire Threshold",
+		.info = img_spdif_in_info_lock,
+		.get = img_spdif_in_get_lock_acquire,
+		.put = img_spdif_in_set_lock_acquire
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = "SPDIF In Lock Release Threshold",
+		.info = img_spdif_in_info_lock,
+		.get = img_spdif_in_get_lock_release,
+		.put = img_spdif_in_set_lock_release
+	}
+};
+
+static int img_spdif_in_trigger(struct snd_pcm_substream *substream, int cmd,
+	struct snd_soc_dai *dai)
+{
+	unsigned long flags;
+	struct img_spdif_in *spdif = snd_soc_dai_get_drvdata(dai);
+	int ret = 0;
+	u32 reg;
+
+	spin_lock_irqsave(&spdif->lock, flags);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		reg = img_spdif_in_readl(spdif, IMG_SPDIF_IN_CTL);
+		if (spdif->multi_freq)
+			reg &= ~IMG_SPDIF_IN_CTL_SRD_MASK;
+		else
+			reg |= (1UL << IMG_SPDIF_IN_CTL_SRD_SHIFT);
+		reg |= IMG_SPDIF_IN_CTL_SRT_MASK;
+		img_spdif_in_writel(spdif, reg, IMG_SPDIF_IN_CTL);
+		spdif->active = true;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		reg = img_spdif_in_readl(spdif, IMG_SPDIF_IN_CTL);
+		reg &= ~IMG_SPDIF_IN_CTL_SRT_MASK;
+		img_spdif_in_writel(spdif, reg, IMG_SPDIF_IN_CTL);
+		spdif->active = false;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	spin_unlock_irqrestore(&spdif->lock, flags);
+
+	return ret;
+}
+
+static int img_spdif_in_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct img_spdif_in *spdif = snd_soc_dai_get_drvdata(dai);
+	unsigned int rate, channels;
+	snd_pcm_format_t format;
+
+	rate = params_rate(params);
+	channels = params_channels(params);
+	format = params_format(params);
+
+	if (format != SNDRV_PCM_FORMAT_S32_LE)
+		return -EINVAL;
+
+	if (channels != 2)
+		return -EINVAL;
+
+	return img_spdif_in_do_clkgen_single(spdif, rate);
+}
+
+static const struct snd_soc_dai_ops img_spdif_in_dai_ops = {
+	.trigger = img_spdif_in_trigger,
+	.hw_params = img_spdif_in_hw_params
+};
+
+static int img_spdif_in_dai_probe(struct snd_soc_dai *dai)
+{
+	struct img_spdif_in *spdif = snd_soc_dai_get_drvdata(dai);
+
+	snd_soc_dai_init_dma_data(dai, NULL, &spdif->dma_data);
+
+	snd_soc_add_dai_controls(dai, img_spdif_in_controls,
+			ARRAY_SIZE(img_spdif_in_controls));
+
+	return 0;
+}
+
+static struct snd_soc_dai_driver img_spdif_in_dai = {
+	.probe = img_spdif_in_dai_probe,
+	.capture = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_192000,
+		.formats = SNDRV_PCM_FMTBIT_S32_LE
+	},
+	.ops = &img_spdif_in_dai_ops
+};
+
+static const struct snd_soc_component_driver img_spdif_in_component = {
+	.name = "img-spdif-in"
+};
+
+static int img_spdif_in_probe(struct platform_device *pdev)
+{
+	struct img_spdif_in *spdif;
+	struct resource *res;
+	void __iomem *base;
+	int ret;
+	struct reset_control *rst;
+	u32 reg;
+
+	spdif = devm_kzalloc(&pdev->dev, sizeof(*spdif), GFP_KERNEL);
+	if (!spdif)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, spdif);
+
+	spdif->dev = &pdev->dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	spdif->base = base;
+
+	spdif->clk_sys = devm_clk_get(&pdev->dev, "sys");
+	if (IS_ERR(spdif->clk_sys))
+		return PTR_ERR(spdif->clk_sys);
+
+	ret = clk_prepare_enable(spdif->clk_sys);
+	if (ret)
+		return ret;
+
+	rst = devm_reset_control_get(&pdev->dev, "rst");
+	if (IS_ERR(rst)) {
+		dev_dbg(&pdev->dev,
+				"No top level reset found\n");
+		img_spdif_in_writel(spdif, IMG_SPDIF_IN_SOFT_RESET_MASK,
+				IMG_SPDIF_IN_SOFT_RESET);
+		img_spdif_in_writel(spdif, 0, IMG_SPDIF_IN_SOFT_RESET);
+	} else {
+		reset_control_assert(rst);
+		reset_control_deassert(rst);
+	}
+
+	spin_lock_init(&spdif->lock);
+
+	spdif->dma_data.addr = res->start + IMG_SPDIF_IN_RX_FIFO_OFFSET;
+	spdif->dma_data.addr_width = 4;
+	spdif->dma_data.maxburst = 4;
+	spdif->trk = 0x80;
+	spdif->lock_acquire = 4;
+	spdif->lock_release = -128;
+
+	reg = (spdif->lock_acquire << IMG_SPDIF_IN_CTL_LOCKHI_SHIFT) &
+		IMG_SPDIF_IN_CTL_LOCKHI_MASK;
+	reg |= (spdif->lock_release << IMG_SPDIF_IN_CTL_LOCKLO_SHIFT) &
+		IMG_SPDIF_IN_CTL_LOCKLO_MASK;
+	reg |= (spdif->trk << IMG_SPDIF_IN_CTL_TRK_SHIFT) &
+		IMG_SPDIF_IN_CTL_TRK_MASK;
+	img_spdif_in_writel(spdif, reg, IMG_SPDIF_IN_CTL);
+
+	ret = devm_snd_soc_register_component(&pdev->dev,
+			&img_spdif_in_component, &img_spdif_in_dai, 1);
+	if (ret)
+		goto err_clk_disable;
+
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+	if (ret)
+		goto err_clk_disable;
+
+	return 0;
+
+err_clk_disable:
+	clk_disable_unprepare(spdif->clk_sys);
+
+	return ret;
+}
+
+static int img_spdif_in_dev_remove(struct platform_device *pdev)
+{
+	struct img_spdif_in *spdif = platform_get_drvdata(pdev);
+
+	clk_disable_unprepare(spdif->clk_sys);
+
+	return 0;
+}
+
+static const struct of_device_id img_spdif_in_of_match[] = {
+	{ .compatible = "img,spdif-in" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, img_spdif_in_of_match);
+
+static struct platform_driver img_spdif_in_driver = {
+	.driver = {
+		.name = "img-spdif-in",
+		.of_match_table = img_spdif_in_of_match
+	},
+	.probe = img_spdif_in_probe,
+	.remove = img_spdif_in_dev_remove
+};
+module_platform_driver(img_spdif_in_driver);
+
+MODULE_AUTHOR("Damien Horsley <Damien.Horsley@imgtec.com>");
+MODULE_DESCRIPTION("IMG SPDIF Input driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/img/img-spdif-out.c b/sound/soc/img/img-spdif-out.c
new file mode 100644
index 0000000..35efde8
--- /dev/null
+++ b/sound/soc/img/img-spdif-out.c
@@ -0,0 +1,449 @@
+/*
+ * IMG SPDIF output controller driver
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/reset.h>
+
+#include <sound/core.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#define IMG_SPDIF_OUT_TX_FIFO		0x0
+
+#define IMG_SPDIF_OUT_CTL		0x4
+#define IMG_SPDIF_OUT_CTL_FS_MASK	BIT(4)
+#define IMG_SPDIF_OUT_CTL_CLK_MASK	BIT(2)
+#define IMG_SPDIF_OUT_CTL_SRT_MASK	BIT(0)
+
+#define IMG_SPDIF_OUT_CSL		0x14
+
+#define IMG_SPDIF_OUT_CSH_UV		0x18
+#define IMG_SPDIF_OUT_CSH_UV_CSH_SHIFT	0
+#define IMG_SPDIF_OUT_CSH_UV_CSH_MASK	0xff
+
+struct img_spdif_out {
+	spinlock_t lock;
+	void __iomem *base;
+	struct clk *clk_sys;
+	struct clk *clk_ref;
+	struct snd_dmaengine_dai_dma_data dma_data;
+	struct device *dev;
+	struct reset_control *rst;
+};
+
+static int img_spdif_out_suspend(struct device *dev)
+{
+	struct img_spdif_out *spdif = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(spdif->clk_ref);
+
+	return 0;
+}
+
+static int img_spdif_out_resume(struct device *dev)
+{
+	struct img_spdif_out *spdif = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_prepare_enable(spdif->clk_ref);
+	if (ret) {
+		dev_err(dev, "clk_enable failed: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static inline void img_spdif_out_writel(struct img_spdif_out *spdif, u32 val,
+				u32 reg)
+{
+	writel(val, spdif->base + reg);
+}
+
+static inline u32 img_spdif_out_readl(struct img_spdif_out *spdif, u32 reg)
+{
+	return readl(spdif->base + reg);
+}
+
+static void img_spdif_out_reset(struct img_spdif_out *spdif)
+{
+	u32 ctl, status_low, status_high;
+
+	ctl = img_spdif_out_readl(spdif, IMG_SPDIF_OUT_CTL) &
+			~IMG_SPDIF_OUT_CTL_SRT_MASK;
+	status_low = img_spdif_out_readl(spdif, IMG_SPDIF_OUT_CSL);
+	status_high = img_spdif_out_readl(spdif, IMG_SPDIF_OUT_CSH_UV);
+
+	reset_control_assert(spdif->rst);
+	reset_control_deassert(spdif->rst);
+
+	img_spdif_out_writel(spdif, ctl, IMG_SPDIF_OUT_CTL);
+	img_spdif_out_writel(spdif, status_low, IMG_SPDIF_OUT_CSL);
+	img_spdif_out_writel(spdif, status_high, IMG_SPDIF_OUT_CSH_UV);
+}
+
+static int img_spdif_out_info(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+
+	return 0;
+}
+
+static int img_spdif_out_get_status_mask(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.iec958.status[0] = 0xff;
+	ucontrol->value.iec958.status[1] = 0xff;
+	ucontrol->value.iec958.status[2] = 0xff;
+	ucontrol->value.iec958.status[3] = 0xff;
+	ucontrol->value.iec958.status[4] = 0xff;
+
+	return 0;
+}
+
+static int img_spdif_out_get_status(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct img_spdif_out *spdif = snd_soc_dai_get_drvdata(cpu_dai);
+	u32 reg;
+	unsigned long flags;
+
+	spin_lock_irqsave(&spdif->lock, flags);
+
+	reg = img_spdif_out_readl(spdif, IMG_SPDIF_OUT_CSL);
+	ucontrol->value.iec958.status[0] = reg & 0xff;
+	ucontrol->value.iec958.status[1] = (reg >> 8) & 0xff;
+	ucontrol->value.iec958.status[2] = (reg >> 16) & 0xff;
+	ucontrol->value.iec958.status[3] = (reg >> 24) & 0xff;
+
+	reg = img_spdif_out_readl(spdif, IMG_SPDIF_OUT_CSH_UV);
+	ucontrol->value.iec958.status[4] =
+		(reg & IMG_SPDIF_OUT_CSH_UV_CSH_MASK) >>
+		IMG_SPDIF_OUT_CSH_UV_CSH_SHIFT;
+
+	spin_unlock_irqrestore(&spdif->lock, flags);
+
+	return 0;
+}
+
+static int img_spdif_out_set_status(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+	struct img_spdif_out *spdif = snd_soc_dai_get_drvdata(cpu_dai);
+	u32 reg;
+	unsigned long flags;
+
+	reg = ((u32)ucontrol->value.iec958.status[3] << 24);
+	reg |= ((u32)ucontrol->value.iec958.status[2] << 16);
+	reg |= ((u32)ucontrol->value.iec958.status[1] << 8);
+	reg |= (u32)ucontrol->value.iec958.status[0];
+
+	spin_lock_irqsave(&spdif->lock, flags);
+
+	img_spdif_out_writel(spdif, reg, IMG_SPDIF_OUT_CSL);
+
+	reg = img_spdif_out_readl(spdif, IMG_SPDIF_OUT_CSH_UV);
+	reg &= ~IMG_SPDIF_OUT_CSH_UV_CSH_MASK;
+	reg |= (u32)ucontrol->value.iec958.status[4] <<
+			IMG_SPDIF_OUT_CSH_UV_CSH_SHIFT;
+	img_spdif_out_writel(spdif, reg, IMG_SPDIF_OUT_CSH_UV);
+
+	spin_unlock_irqrestore(&spdif->lock, flags);
+
+	return 0;
+}
+
+static struct snd_kcontrol_new img_spdif_out_controls[] = {
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READ,
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = SNDRV_CTL_NAME_IEC958("", PLAYBACK, MASK),
+		.info = img_spdif_out_info,
+		.get = img_spdif_out_get_status_mask
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = SNDRV_CTL_NAME_IEC958("", PLAYBACK, DEFAULT),
+		.info = img_spdif_out_info,
+		.get = img_spdif_out_get_status,
+		.put = img_spdif_out_set_status
+	}
+};
+
+static int img_spdif_out_trigger(struct snd_pcm_substream *substream, int cmd,
+			struct snd_soc_dai *dai)
+{
+	struct img_spdif_out *spdif = snd_soc_dai_get_drvdata(dai);
+	u32 reg;
+	unsigned long flags;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		reg = img_spdif_out_readl(spdif, IMG_SPDIF_OUT_CTL);
+		reg |= IMG_SPDIF_OUT_CTL_SRT_MASK;
+		img_spdif_out_writel(spdif, reg, IMG_SPDIF_OUT_CTL);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		spin_lock_irqsave(&spdif->lock, flags);
+		img_spdif_out_reset(spdif);
+		spin_unlock_irqrestore(&spdif->lock, flags);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int img_spdif_out_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct img_spdif_out *spdif = snd_soc_dai_get_drvdata(dai);
+	unsigned int channels;
+	long pre_div_a, pre_div_b, diff_a, diff_b, rate, clk_rate;
+	u32 reg;
+	snd_pcm_format_t format;
+
+	rate = params_rate(params);
+	format = params_format(params);
+	channels = params_channels(params);
+
+	dev_dbg(spdif->dev, "hw_params rate %ld channels %u format %u\n",
+			rate, channels, format);
+
+	if (format != SNDRV_PCM_FORMAT_S32_LE)
+		return -EINVAL;
+
+	if (channels != 2)
+		return -EINVAL;
+
+	pre_div_a = clk_round_rate(spdif->clk_ref, rate * 256);
+	if (pre_div_a < 0)
+		return pre_div_a;
+	pre_div_b = clk_round_rate(spdif->clk_ref, rate * 384);
+	if (pre_div_b < 0)
+		return pre_div_b;
+
+	diff_a = abs((pre_div_a / 256) - rate);
+	diff_b = abs((pre_div_b / 384) - rate);
+
+	/* If diffs are equal, use lower clock rate */
+	if (diff_a > diff_b)
+		clk_set_rate(spdif->clk_ref, pre_div_b);
+	else
+		clk_set_rate(spdif->clk_ref, pre_div_a);
+
+	/*
+	 * Another driver (eg machine driver) may have rejected the above
+	 * change. Get the current rate and set the register bit according to
+	 * the new min diff
+	 */
+	clk_rate = clk_get_rate(spdif->clk_ref);
+
+	diff_a = abs((clk_rate / 256) - rate);
+	diff_b = abs((clk_rate / 384) - rate);
+
+	reg = img_spdif_out_readl(spdif, IMG_SPDIF_OUT_CTL);
+	if (diff_a <= diff_b)
+		reg &= ~IMG_SPDIF_OUT_CTL_CLK_MASK;
+	else
+		reg |= IMG_SPDIF_OUT_CTL_CLK_MASK;
+	img_spdif_out_writel(spdif, reg, IMG_SPDIF_OUT_CTL);
+
+	return 0;
+}
+
+static int img_spdif_out_start_at_abort(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *cpu_dai)
+{
+	struct img_spdif_out *spdif = snd_soc_dai_get_drvdata(cpu_dai);
+	unsigned long flags;
+
+	spin_lock_irqsave(&spdif->lock, flags);
+	img_spdif_out_reset(spdif);
+	spin_unlock_irqrestore(&spdif->lock, flags);
+
+	return 0;
+}
+
+
+static const struct snd_soc_dai_ops img_spdif_out_dai_ops = {
+	.trigger = img_spdif_out_trigger,
+	.hw_params = img_spdif_out_hw_params,
+	.start_at_abort = img_spdif_out_start_at_abort
+};
+
+static int img_spdif_out_dai_probe(struct snd_soc_dai *dai)
+{
+	struct img_spdif_out *spdif = snd_soc_dai_get_drvdata(dai);
+
+	snd_soc_dai_init_dma_data(dai, &spdif->dma_data, NULL);
+
+	snd_soc_add_dai_controls(dai, img_spdif_out_controls,
+			ARRAY_SIZE(img_spdif_out_controls));
+
+	return 0;
+}
+
+static struct snd_soc_dai_driver img_spdif_out_dai = {
+	.probe = img_spdif_out_dai_probe,
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_192000,
+		.formats = SNDRV_PCM_FMTBIT_S32_LE
+	},
+	.ops = &img_spdif_out_dai_ops
+};
+
+static const struct snd_soc_component_driver img_spdif_out_component = {
+	.name = "img-spdif-out"
+};
+
+static int img_spdif_out_probe(struct platform_device *pdev)
+{
+	struct img_spdif_out *spdif;
+	struct resource *res;
+	void __iomem *base;
+	int ret;
+
+	spdif = devm_kzalloc(&pdev->dev, sizeof(*spdif), GFP_KERNEL);
+	if (!spdif)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, spdif);
+
+	spdif->dev = &pdev->dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	spdif->base = base;
+
+	spdif->rst = devm_reset_control_get(&pdev->dev, "rst");
+	if (IS_ERR(spdif->rst)) {
+		dev_err(&pdev->dev, "No top level reset found\n");
+		return PTR_ERR(spdif->rst);
+	}
+
+	spdif->clk_sys = devm_clk_get(&pdev->dev, "sys");
+	if (IS_ERR(spdif->clk_sys))
+		return PTR_ERR(spdif->clk_sys);
+
+	spdif->clk_ref = devm_clk_get(&pdev->dev, "ref");
+	if (IS_ERR(spdif->clk_ref))
+		return PTR_ERR(spdif->clk_ref);
+
+	ret = clk_prepare_enable(spdif->clk_sys);
+	if (ret)
+		return ret;
+
+	img_spdif_out_writel(spdif, IMG_SPDIF_OUT_CTL_FS_MASK,
+				IMG_SPDIF_OUT_CTL);
+
+	img_spdif_out_reset(spdif);
+
+	pm_runtime_enable(&pdev->dev);
+	if (!pm_runtime_enabled(&pdev->dev)) {
+		ret = img_spdif_out_resume(&pdev->dev);
+		if (ret)
+			goto err_pm_disable;
+	}
+
+	spin_lock_init(&spdif->lock);
+
+	spdif->dma_data.addr = res->start + IMG_SPDIF_OUT_TX_FIFO;
+	spdif->dma_data.addr_width = 4;
+	spdif->dma_data.maxburst = 4;
+
+	ret = devm_snd_soc_register_component(&pdev->dev,
+			&img_spdif_out_component,
+			&img_spdif_out_dai, 1);
+	if (ret)
+		goto err_suspend;
+
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL,
+			SND_DMAENGINE_PCM_FLAG_EARLY_START);
+	if (ret)
+		goto err_suspend;
+
+	dev_dbg(&pdev->dev, "Probe successful\n");
+
+	return 0;
+
+err_suspend:
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		img_spdif_out_suspend(&pdev->dev);
+err_pm_disable:
+	pm_runtime_disable(&pdev->dev);
+	clk_disable_unprepare(spdif->clk_sys);
+
+	return ret;
+}
+
+static int img_spdif_out_dev_remove(struct platform_device *pdev)
+{
+	struct img_spdif_out *spdif = platform_get_drvdata(pdev);
+
+	pm_runtime_disable(&pdev->dev);
+	if (!pm_runtime_status_suspended(&pdev->dev))
+		img_spdif_out_suspend(&pdev->dev);
+
+	clk_disable_unprepare(spdif->clk_sys);
+
+	return 0;
+}
+
+static const struct of_device_id img_spdif_out_of_match[] = {
+	{ .compatible = "img,spdif-out" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, img_spdif_out_of_match);
+
+static const struct dev_pm_ops img_spdif_out_pm_ops = {
+	SET_RUNTIME_PM_OPS(img_spdif_out_suspend,
+			   img_spdif_out_resume, NULL)
+};
+
+static struct platform_driver img_spdif_out_driver = {
+	.driver = {
+		.name = "img-spdif-out",
+		.of_match_table = img_spdif_out_of_match,
+		.pm = &img_spdif_out_pm_ops
+	},
+	.probe = img_spdif_out_probe,
+	.remove = img_spdif_out_dev_remove
+};
+module_platform_driver(img_spdif_out_driver);
+
+MODULE_AUTHOR("Damien Horsley <Damien.Horsley@imgtec.com>");
+MODULE_DESCRIPTION("IMG SPDIF Output driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/img/pistachio-event-timer.c b/sound/soc/img/pistachio-event-timer.c
new file mode 100644
index 0000000..366e3e0
--- /dev/null
+++ b/sound/soc/img/pistachio-event-timer.c
@@ -0,0 +1,887 @@
+/*
+ * Pistachio event timer driver
+ *
+ * Copyright (C) 2014 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/hrtimer.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/of_irq.h>
+#include <linux/clk-provider.h>
+#include <linux/of_address.h>
+#include <linux/delay.h>
+#include <linux/clocksource.h>
+#include <linux/timecounter.h>
+
+#ifdef CONFIG_ATU
+#include <linux/atu_clk.h>
+#endif /* CONFIG_ATU */
+
+#include "pistachio-event-timer.h"
+
+#define PISTACHIO_EVT_COUNTER			0x0
+#define PISTACHIO_EVT_COUNTER_MASK		0x3fffffff
+#define PISTACHIO_EVT_COUNTER_ENABLE_MASK	0x80000000
+
+#define PISTACHIO_EVT_TIMESTAMP_STS		0x4
+
+#define PISTACHIO_EVT_TIMESTAMP_CLR		0x8
+
+#define PISTACHIO_EVT_CLKSRC_SELECT		0xc
+#define PISTACHIO_EVT_CLKSRC_SELECT_SHIFT	0
+#define PISTACHIO_EVT_CLKSRC_SELECT_WIDTH	1
+
+#define PISTACHIO_EVT_SOURCE_INTERNAL_START	0x10
+#define PISTACHIO_EVT_SOURCE_INTERNAL_MASK	0xf
+
+#define PISTACHIO_EVT_TIMESTAMP_START		0x40
+#define PISTACHIO_EVT_TIMESTAMP_MASK		PISTACHIO_EVT_COUNTER_MASK
+
+#define PISTACHIO_EVT_TIMER_ENABLE		0x100
+#define PISTACHIO_EVT_TIMER_ENABLE_MASK		0x1
+
+#define PISTACHIO_EVT_EVENT_CTL			0x120
+#define PISTACHIO_EVT_EVENT_CTL_MASK		0x3
+#define PISTACHIO_EVT_EVENT_CTL_WIDTH		2
+
+#define PISTACHIO_EVT_TB			0x130
+#define PISTACHIO_EVT_TIME_REG(en)		(PISTACHIO_EVT_TB + (0x4 * en))
+
+#define PISTACHIO_EVT_TIMESTAMP_SRC_START	0x190
+#define PISTACHIO_EVT_TIMESTAMP_SRC_MASK	0xff
+#define PISTACHIO_EVT_TIMESTAMP_SRC_WIDTH	8
+
+#define	PISTACHIO_EVT_MIN_EVENT_DELTA_NS	100000
+
+struct pistachio_evt_callback {
+	u64 trigger_time;
+	u32 cyc;
+	void (*callback)(void *context);
+	void *context;
+};
+
+struct pistachio_evt_data {
+	spinlock_t lock;
+	struct device *dev;
+	void __iomem *base;
+	struct clk *clk_sys;
+	struct clk *clk_ref_internal;
+	struct clk *clk_ref_a;
+	struct clk *clk_ref_b;
+	const char *ref_names[2];
+	struct cyclecounter cc;
+	struct timecounter tc;
+	struct notifier_block evt_clk_notifier;
+	struct hrtimer poll_timer;
+	ktime_t quarter_rollover;
+	unsigned long rate;
+	struct pistachio_evt_callback trigger_cbs[PISTACHIO_EVT_NUM_ENABLES];
+};
+unsigned long evt_timer_rate;
+
+static inline u32 pistachio_evt_readl(struct pistachio_evt_data *evt, u32 reg)
+{
+	return readl(evt->base + reg);
+}
+
+static inline void pistachio_evt_writel(struct pistachio_evt_data *evt,
+					u32 val, u32 reg)
+{
+	writel(val, evt->base + reg);
+}
+
+static inline void pistachio_evt_stop_count(struct pistachio_evt_data *evt)
+{
+	u32 reg = pistachio_evt_readl(evt, PISTACHIO_EVT_COUNTER);
+	reg &= ~PISTACHIO_EVT_COUNTER_ENABLE_MASK;
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_COUNTER);
+}
+
+static inline void pistachio_evt_start_count(struct pistachio_evt_data *evt)
+{
+	u32 reg = pistachio_evt_readl(evt, PISTACHIO_EVT_COUNTER);
+	reg |= PISTACHIO_EVT_COUNTER_ENABLE_MASK;
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_COUNTER);
+}
+
+static inline int pistachio_evt_get_count(struct pistachio_evt_data *evt)
+{
+	u32 reg = pistachio_evt_readl(evt, PISTACHIO_EVT_COUNTER);
+	return reg & PISTACHIO_EVT_COUNTER_MASK;
+}
+
+static inline void pistachio_evt_set_count(struct pistachio_evt_data *evt,
+					int count)
+{
+	u32 reg = pistachio_evt_readl(evt, PISTACHIO_EVT_COUNTER);
+	reg = (reg & ~PISTACHIO_EVT_COUNTER_MASK) |
+		(count & PISTACHIO_EVT_COUNTER_MASK);
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_COUNTER);
+}
+
+static cycle_t pistachio_evt_cc_read(const struct cyclecounter *cc)
+{
+	struct pistachio_evt_data *evt;
+
+	evt = container_of(cc, struct pistachio_evt_data, cc);
+
+	return (cycle_t)pistachio_evt_get_count(evt);
+}
+
+static u64 _pistachio_evt_read_ns(struct pistachio_evt_data *evt, u32 *cyc)
+{
+	u64 ret;
+
+	ret = timecounter_read(&evt->tc);
+	if (cyc)
+		*cyc = evt->tc.cycle_last;
+
+	return ret;
+}
+
+static u64 pistachio_evt_read_ns(struct pistachio_evt_data *evt, u32 *cyc)
+{
+	unsigned long flags;
+	u64 ret;
+
+	spin_lock_irqsave(&evt->lock, flags);
+	ret = _pistachio_evt_read_ns(evt, cyc);
+	spin_unlock_irqrestore(&evt->lock, flags);
+
+	return ret;
+}
+
+void pistachio_evt_read(struct platform_device *pdev,
+				struct timespec *ts)
+{
+	u64 tmp;
+#ifndef	CONFIG_ATU
+	struct pistachio_evt_data *evt = platform_get_drvdata(pdev);
+#endif
+
+#ifdef	CONFIG_ATU
+	tmp = atu_get_current_time();
+#else
+	tmp = pistachio_evt_read_ns(evt, NULL);
+#endif
+
+	ts->tv_nsec = do_div(tmp, NSEC_PER_SEC);
+	ts->tv_sec = tmp;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_read);
+
+static inline bool pistachio_evt_bad_event(enum pistachio_evt_enable event)
+{
+	switch (event) {
+	case PISTACHIO_EVT_ENABLE_PARALLEL_OUT:
+	case PISTACHIO_EVT_ENABLE_I2S_OUT:
+	case PISTACHIO_EVT_ENABLE_SPDIF_OUT:
+	case PISTACHIO_EVT_ENABLE_EXTERNAL:
+		return false;
+	default:
+		return true;
+	}
+}
+
+static struct pistachio_evt_callback *pistachio_evt_get_next_trigger(
+		struct pistachio_evt_data *evt, u64 *p_next_trigger)
+{
+	u64 next_trigger, tmp;
+	int i;
+	struct pistachio_evt_callback *cbr = NULL, *cb;
+
+	cb = &evt->trigger_cbs[0];
+	next_trigger = ULLONG_MAX;
+
+	for (i = 0; i < PISTACHIO_EVT_NUM_ENABLES; i++) {
+		if (!pistachio_evt_bad_event(i)) {
+			tmp = cb->trigger_time;
+			if (tmp && (tmp < next_trigger)) {
+				next_trigger = tmp;
+				cbr = cb;
+			}
+		}
+		cb++;
+	}
+
+	*p_next_trigger = next_trigger;
+
+	return cbr;
+}
+
+void _pistachio_evt_disable_event(struct platform_device *pdev,
+		enum pistachio_evt_enable event)
+{
+	u32 reg;
+	struct pistachio_evt_data *evt = platform_get_drvdata(pdev);
+
+	dev_dbg(evt->dev, "Disable event %u\n", (unsigned int)event);
+
+	if (pistachio_evt_bad_event(event)) {
+		dev_err(evt->dev, "Disable event %u failed (bad event %u)\n", (unsigned int)event, (unsigned int)event);
+		return;
+	}
+
+	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_EVENT_CTL);
+
+	reg &= ~(PISTACHIO_EVT_EVENT_CTL_MASK <<
+		(PISTACHIO_EVT_EVENT_CTL_WIDTH * event));
+
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_EVENT_CTL);
+
+	evt->trigger_cbs[event].trigger_time = 0;
+}
+EXPORT_SYMBOL_GPL(_pistachio_evt_disable_event);
+
+void pistachio_evt_disable_event(struct platform_device *pdev,
+		enum pistachio_evt_enable event)
+{
+	unsigned long flags;
+	struct pistachio_evt_data *evt = platform_get_drvdata(pdev);
+
+	spin_lock_irqsave(&evt->lock, flags);
+	_pistachio_evt_disable_event(pdev, event);
+	spin_unlock_irqrestore(&evt->lock, flags);
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_disable_event);
+
+int pistachio_evt_set_event(struct platform_device *pdev,
+		enum pistachio_evt_enable event, enum pistachio_evt_type type,
+		struct timespec *ts,
+		void (*event_trigger_callback)(void *context), void *context)
+{
+	u32 reg, cyc, event_reg_addr, irq_reg_addr;
+	u64 trigger_time, next_trigger;
+	unsigned long flags;
+	struct pistachio_evt_data *evt = platform_get_drvdata(pdev);
+	struct pistachio_evt_callback *cb;
+#ifdef	CONFIG_ATU
+	int ret;
+#else
+	u64 tmp;
+#endif
+
+	dev_dbg(evt->dev, "Set event %u type %u time %u,%u\n", (unsigned int)event, (unsigned int)type, (unsigned int)ts->tv_sec, (unsigned int)ts->tv_nsec);
+
+	if (pistachio_evt_bad_event(event)) {
+		dev_err(evt->dev, "Set event %u failed (bad event %u)\n", (unsigned int)event, (unsigned int)event);
+		return -EINVAL;
+	}
+
+	switch(type) {
+	case PISTACHIO_EVT_TYPE_LEVEL:
+	case PISTACHIO_EVT_TYPE_PULSE:
+		break;
+	default:
+		dev_err(evt->dev, "Set event %u failed (bad event type %u)\n", (unsigned int)event, (unsigned int)type);
+		return -EINVAL;
+	}
+
+	if (!ts) {
+		dev_err(evt->dev, "Set event %u failed (ts == NULL)\n", (unsigned int)event);
+		return -EINVAL;
+	}
+
+	event_reg_addr = PISTACHIO_EVT_TIME_REG(event);
+	irq_reg_addr = PISTACHIO_EVT_TIME_REG(PISTACHIO_EVT_ENABLE_IRQ_0);
+
+	trigger_time = (u64)ts->tv_sec * NSEC_PER_SEC + ts->tv_nsec;
+
+	spin_lock_irqsave(&evt->lock, flags);
+
+	/* Trigger already pending for this event? */
+	if (evt->trigger_cbs[event].trigger_time) {
+		dev_err(evt->dev, "Set event %u failed (trigger already pending at %lldns)\n", (unsigned int)event, evt->trigger_cbs[event].trigger_time);
+		spin_unlock_irqrestore(&evt->lock, flags);
+		return -EINVAL;
+	}
+
+	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_EVENT_CTL);
+
+	/* Disable event first */
+	reg &= ~(PISTACHIO_EVT_EVENT_CTL_MASK <<
+		(PISTACHIO_EVT_EVENT_CTL_WIDTH * event));
+
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_EVENT_CTL);
+
+	reg |= (type << (PISTACHIO_EVT_EVENT_CTL_WIDTH * event));
+
+#ifdef	CONFIG_ATU
+	ret = atu_to_frc(trigger_time, &cyc, PISTACHIO_EVT_MIN_EVENT_DELTA_NS);
+	if(ret) {
+		spin_unlock_irqrestore(&evt->lock, flags);
+		return ret;
+	}
+#else
+	tmp = _pistachio_evt_read_ns(evt, &cyc);
+
+	/* Trigger in the past or too close to current time? */
+	if (trigger_time < (tmp + PISTACHIO_EVT_MIN_EVENT_DELTA_NS)) {
+		if (trigger_time < tmp)
+			dev_dbg(evt->dev, "Set event %u failed (1) (trigger in the past: -%lluns)\n", (unsigned int)event, (tmp - trigger_time));
+		else
+			dev_dbg(evt->dev, "Set event %u failed (1) (trigger too close to expiry: +%lluns)\n", (unsigned int)event, (trigger_time - tmp));
+		spin_unlock_irqrestore(&evt->lock, flags);
+		return -ETIME;
+	}
+
+	/*
+	 * Convert ns difference between current time and trigger time
+	 * to event timer cycles
+	 */
+	tmp = (trigger_time - tmp) << evt->cc.shift;
+	do_div(tmp, evt->cc.mult);
+
+	/* Trigger too far into the future (cyc value would be ambiguous)? */
+	if (tmp > PISTACHIO_EVT_COUNTER_MASK) {
+		dev_dbg(evt->dev, "Set event %u failed (trigger too far into the future: %lluns)\n", (unsigned int)event, trigger_time);
+		spin_unlock_irqrestore(&evt->lock, flags);
+		return -ETIME;
+	}
+
+	/* Calculate cycle value for trigger */
+	cyc = (cyc + tmp) & PISTACHIO_EVT_COUNTER_MASK;
+
+	cb = pistachio_evt_get_next_trigger(evt, &next_trigger);
+
+	/* Final time check before fast write operations */
+	tmp = _pistachio_evt_read_ns(evt, NULL);
+
+	if (trigger_time < (tmp + PISTACHIO_EVT_MIN_EVENT_DELTA_NS)) {
+		if (trigger_time < tmp)
+			dev_dbg(evt->dev, "Set event %u failed (2) (trigger in the past: -%lluns)\n", (unsigned int)event, (tmp - trigger_time));
+		else
+			dev_dbg(evt->dev, "Set event %u failed (2) (trigger too close to expiry: +%lluns)\n", (unsigned int)event, (trigger_time - tmp));
+		spin_unlock_irqrestore(&evt->lock, flags);
+		return -ETIME;
+	}
+#endif
+
+	pistachio_evt_writel(evt, cyc, event_reg_addr);
+
+	/*
+	 * No irq trigger currently set or the new trigger time is
+	 * earlier than the current trigger time?
+	 */
+	if (!cb || (next_trigger > trigger_time)) {
+		pistachio_evt_writel(evt, cyc, irq_reg_addr);
+		reg |= PISTACHIO_EVT_TYPE_LEVEL <<
+			(PISTACHIO_EVT_EVENT_CTL_WIDTH *
+			PISTACHIO_EVT_ENABLE_IRQ_0);
+	}
+
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_EVENT_CTL);
+
+	evt->trigger_cbs[event].callback = event_trigger_callback;
+	evt->trigger_cbs[event].trigger_time = trigger_time;
+	evt->trigger_cbs[event].cyc = cyc;
+	evt->trigger_cbs[event].context = context;
+
+	spin_unlock_irqrestore(&evt->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_set_event);
+
+static bool pistachio_evt_retrigger(struct pistachio_evt_data *evt,
+				struct pistachio_evt_callback * cb)
+{
+	u32 reg, trig_reg_addr;
+	u64 cur_time;
+
+	trig_reg_addr = PISTACHIO_EVT_TIME_REG(PISTACHIO_EVT_ENABLE_IRQ_0);
+
+	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_EVENT_CTL);
+
+	reg |= (PISTACHIO_EVT_TYPE_LEVEL <<
+		(PISTACHIO_EVT_EVENT_CTL_WIDTH * PISTACHIO_EVT_ENABLE_IRQ_0));
+
+	pistachio_evt_writel(evt, cb->cyc, trig_reg_addr);
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_EVENT_CTL);
+
+#ifdef	CONFIG_ATU
+	cur_time = atu_get_current_time();
+#else
+	cur_time = _pistachio_evt_read_ns(evt, NULL);
+#endif
+
+	/* Trigger passed while writing? */
+	if (cb->trigger_time < cur_time)
+		return false;
+
+	return true;
+}
+
+static irqreturn_t pistachio_evt_trigger_0_irq(int irq, void *dev_id)
+{
+	struct pistachio_evt_data *evt = (struct pistachio_evt_data *)dev_id;
+	u64 next_trigger, cur_time;
+	struct pistachio_evt_callback *cb;
+	unsigned long flags;
+	u32 reg;
+
+	dev_dbg(evt->dev, "Trigger IRQ\n");
+
+	spin_lock_irqsave(&evt->lock, flags);
+
+	while (1) {
+		cb = pistachio_evt_get_next_trigger(evt, &next_trigger);
+
+		/* Disable the irq trigger */
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_EVENT_CTL);
+		reg &= ~(PISTACHIO_EVT_EVENT_CTL_MASK <<
+			(PISTACHIO_EVT_EVENT_CTL_WIDTH *
+			PISTACHIO_EVT_ENABLE_IRQ_0));
+		pistachio_evt_writel(evt, reg, PISTACHIO_EVT_EVENT_CTL);
+
+		if (!cb)
+			break;
+
+#ifdef	CONFIG_ATU
+		cur_time = atu_get_current_time();
+#else
+		cur_time = _pistachio_evt_read_ns(evt, NULL);
+#endif
+
+		if (cur_time >= next_trigger) {
+			if (cb->callback)
+				cb->callback(cb->context);
+			cb->trigger_time = 0;
+		} else if (pistachio_evt_retrigger(evt, cb)) {
+			break;
+		} else {
+			if (cb->callback)
+				cb->callback(cb->context);
+			cb->trigger_time = 0;
+		}
+	}
+
+	spin_unlock_irqrestore(&evt->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+int pistachio_evt_set_timestamp_source(struct platform_device *pdev,
+		unsigned int ts_module_index, unsigned int interrupt_source)
+{
+	u32 timestamps_per_reg, reg_addr, reg, shift;
+	struct pistachio_evt_data *evt = platform_get_drvdata(pdev);
+	unsigned long flags;
+
+	dev_dbg(evt->dev, "Set timestamp source module index %u source %u\n", (unsigned int)ts_module_index, (unsigned int)interrupt_source);
+
+	if (ts_module_index >= PISTACHIO_EVT_NUM_TIMESTAMP_MODULES) {
+		dev_err(evt->dev, "Set timestamp source module index %u failed (bad timestamp module index %u)\n", (unsigned int)ts_module_index, ts_module_index);
+		return -EINVAL;
+	}
+
+	timestamps_per_reg = (32 / PISTACHIO_EVT_TIMESTAMP_SRC_WIDTH);
+	reg_addr = PISTACHIO_EVT_TIMESTAMP_SRC_START +
+		((ts_module_index / timestamps_per_reg) * 4);
+
+	shift = ts_module_index % timestamps_per_reg;
+	shift *= PISTACHIO_EVT_TIMESTAMP_SRC_WIDTH;
+
+	spin_lock_irqsave(&evt->lock, flags);
+
+	reg = pistachio_evt_readl(evt, reg_addr);
+
+	reg &= ~(PISTACHIO_EVT_TIMESTAMP_SRC_MASK << shift);
+
+	reg |= (interrupt_source & PISTACHIO_EVT_TIMESTAMP_SRC_MASK) << shift;
+
+	pistachio_evt_writel(evt, reg, reg_addr);
+
+	pistachio_evt_writel(evt, 1 << ts_module_index,
+			PISTACHIO_EVT_TIMESTAMP_CLR);
+
+	spin_unlock_irqrestore(&evt->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_set_timestamp_source);
+
+int pistachio_evt_get_timestamp(struct platform_device *pdev,
+		unsigned int ts_module_index, struct timespec *timestamp)
+{
+	u32 reg, cyc, ts;
+	u64 tmp;
+	struct pistachio_evt_data *evt = platform_get_drvdata(pdev);
+	unsigned long flags;
+
+	dev_dbg(evt->dev, "Get timestamp module index %u\n", (unsigned int)ts_module_index);
+
+	if (ts_module_index >= PISTACHIO_EVT_NUM_TIMESTAMP_MODULES) {
+		dev_err(evt->dev, "Set timestamp source module index %u failed (bad timestamp module index %u)\n", (unsigned int)ts_module_index, ts_module_index);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&evt->lock, flags);
+
+	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_TIMESTAMP_STS);
+
+	/* No new timestamp available? */
+	if (!(reg & (1 << ts_module_index))) {
+		dev_dbg(evt->dev, "Get timestamp module index %u failed (no new timestamp)\n", (unsigned int)ts_module_index);
+		spin_unlock_irqrestore(&evt->lock, flags);
+		return -EBUSY;
+	}
+
+	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_TIMESTAMP_START +
+		(ts_module_index * 0x4));
+
+	pistachio_evt_writel(evt, 1 << ts_module_index,
+			PISTACHIO_EVT_TIMESTAMP_CLR);
+
+	tmp = _pistachio_evt_read_ns(evt, &cyc);
+
+	ts = reg & PISTACHIO_EVT_COUNTER_MASK;
+
+	/*
+	 * This currently assumes that the period of time between the
+	 * timestamped event and the current time is less than the period
+	 * of the counter. Maybe timestamps should be checked in the poll
+	 * function that ensures the tc doesnt overflow...
+	 */
+
+	/* Get the cycle difference */
+	cyc = (cyc - ts) & PISTACHIO_EVT_COUNTER_MASK;
+
+	/* Calculate the ns difference and the ns timestamp value */
+	tmp -= ((u64)cyc * evt->cc.mult) >> evt->cc.shift;
+
+	spin_unlock_irqrestore(&evt->lock, flags);
+
+	timestamp->tv_nsec = do_div(tmp, NSEC_PER_SEC);
+	timestamp->tv_sec = tmp;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_get_timestamp);
+
+enum hrtimer_restart pistachio_evt_poll(struct hrtimer *tmr)
+{
+	struct pistachio_evt_data *evt;
+	u64 tmp, nsec;
+
+	evt = container_of(tmr, struct pistachio_evt_data, poll_timer);
+
+	tmp = pistachio_evt_read_ns(evt, NULL);
+	nsec = do_div(tmp, NSEC_PER_SEC);
+
+	//dev_dbg(evt->dev, "poll time = %u,%u\n", (unsigned int)tmp, (unsigned int)nsec);
+
+	hrtimer_forward(&evt->poll_timer,
+			hrtimer_get_expires(&evt->poll_timer),
+			evt->quarter_rollover);
+
+	return HRTIMER_RESTART;
+}
+
+static void pistachio_evt_clk_rate_change(struct pistachio_evt_data *evt)
+{
+	u64 tmp;
+	unsigned long flags;
+	unsigned long rate;
+	ktime_t quarter_rollover;
+	u32 mult, shift, mask;
+
+	dev_dbg(evt->dev, "pistachio_evt_clk_rate_change()\n");
+
+	mask = PISTACHIO_EVT_COUNTER_MASK;
+
+	rate = clk_get_rate(evt->clk_ref_internal);
+
+	tmp = ((u64)mask + 1) * NSEC_PER_SEC;
+	do_div(tmp, rate);
+	tmp >>= 2;
+	quarter_rollover.tv64 = tmp;
+
+	clocks_calc_mult_shift(&mult, &shift, rate,
+			NSEC_PER_SEC, DIV_ROUND_UP(mask, rate));
+
+	spin_lock_irqsave(&evt->lock, flags);
+	evt->rate = rate;
+	evt->quarter_rollover = quarter_rollover;
+	evt->cc.mult = mult;
+	evt->cc.shift = shift;
+	spin_unlock_irqrestore(&evt->lock, flags);
+
+	evt_timer_rate = rate;
+
+	dev_dbg(evt->dev, "rate %ld cc mult %u shift %u\n", rate, evt->cc.mult,
+			evt->cc.shift);
+}
+
+#ifndef	CONFIG_ATU
+static void pistachio_evt_start_poll_timer(struct pistachio_evt_data *evt)
+{
+	ktime_t ks;
+
+	dev_dbg(evt->dev, "pistachio_evt_start_poll_timer()\n");
+
+	ks = ktime_get();
+	ks = ktime_add(ks, evt->quarter_rollover);
+
+	hrtimer_start(&evt->poll_timer, ks, HRTIMER_MODE_ABS);
+}
+
+static int pistachio_evt_clk_notifier_cb(struct notifier_block *nb,
+		unsigned long event, void *data)
+{
+	struct pistachio_evt_data *evt;
+
+	evt = container_of(nb, struct pistachio_evt_data, evt_clk_notifier);
+
+	dev_dbg(evt->dev, "pistachio_evt_clk_notifier_cb()\n");
+
+	switch (event) {
+	case PRE_RATE_CHANGE:
+		pistachio_evt_read_ns(evt, NULL);
+		return NOTIFY_OK;
+	case POST_RATE_CHANGE:
+		hrtimer_cancel(&evt->poll_timer);
+		pistachio_evt_clk_rate_change(evt);
+		pistachio_evt_read_ns(evt, NULL);
+		pistachio_evt_start_poll_timer(evt);
+		return NOTIFY_OK;
+	case ABORT_RATE_CHANGE:
+		return NOTIFY_OK;
+	default:
+		return NOTIFY_DONE;
+	}
+}
+#endif
+
+static int pistachio_evt_driver_probe(struct platform_device *pdev)
+{
+	struct pistachio_evt_data *evt;
+	int ret, i, irq;
+	struct device_node *np = pdev->dev.of_node;
+	u32 clk_select, rate;
+	struct resource iomem;
+	struct device *dev = &pdev->dev;
+
+	evt = devm_kzalloc(&pdev->dev, sizeof(*evt), GFP_KERNEL);
+	if (!evt)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, evt);
+
+	evt->dev = dev;
+
+	spin_lock_init(&evt->lock);
+
+	ret = of_address_to_resource(np, 0, &iomem);
+	if (ret) {
+		dev_err(dev, "Could not get IO memory\n");
+		return ret;
+	}
+
+	evt->base = devm_ioremap_resource(dev, &iomem);
+	if (IS_ERR(evt->base))
+		return PTR_ERR(evt->base);
+
+	irq = platform_get_irq(pdev, 3);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "can't get trigger 0 irq\n");
+		return irq;
+	}
+
+	ret = devm_request_irq(&pdev->dev, irq, pistachio_evt_trigger_0_irq,
+				0, pdev->name, evt);
+	if (ret) {
+		dev_err(&pdev->dev, "can't request irq %d\n", irq);
+		return ret;
+	}
+
+	if (of_property_read_u32(np, "img,clk-select", &clk_select)) {
+		dev_err(&pdev->dev, "No img,clk-select property\n");
+		return -EINVAL;
+	}
+
+	if (clk_select > 1)
+		return -EINVAL;
+
+	if (of_property_read_u32(np, "img,clk-rate", &rate))
+		rate = 0;
+
+	evt->clk_ref_a = devm_clk_get(&pdev->dev, "ref0");
+	if (IS_ERR(evt->clk_ref_a))
+		return PTR_ERR(evt->clk_ref_a);
+
+	ret = clk_prepare_enable(evt->clk_ref_a);
+	if (ret)
+		return ret;
+
+	evt->clk_ref_b = devm_clk_get(&pdev->dev, "ref1");
+	if (IS_ERR(evt->clk_ref_b)) {
+		ret = PTR_ERR(evt->clk_ref_b);
+		goto err_ref_a;
+	}
+
+	ret = clk_prepare_enable(evt->clk_ref_b);
+	if (ret)
+		goto err_ref_a;
+
+	evt->clk_sys = devm_clk_get(&pdev->dev, "sys");
+	if (IS_ERR(evt->clk_sys)) {
+		ret = PTR_ERR(evt->clk_sys);
+		goto err_ref_b;
+	}
+
+	ret = clk_prepare_enable(evt->clk_sys);
+	if (ret)
+		goto err_ref_b;
+
+	evt->ref_names[0] = __clk_get_name(evt->clk_ref_a);
+	evt->ref_names[1] = __clk_get_name(evt->clk_ref_b);
+
+	evt->clk_ref_internal = clk_register_mux(NULL, "event_timer_internal",
+		evt->ref_names, 2, CLK_SET_RATE_PARENT |
+		CLK_SET_RATE_NO_REPARENT,
+		evt->base + PISTACHIO_EVT_CLKSRC_SELECT,
+		PISTACHIO_EVT_CLKSRC_SELECT_SHIFT,
+		PISTACHIO_EVT_CLKSRC_SELECT_WIDTH,
+		0, NULL);
+
+	if (IS_ERR(evt->clk_ref_internal)) {
+		ret = PTR_ERR(evt->clk_ref_internal);
+		goto err_sys;
+	}
+
+	ret = of_clk_add_provider(np, of_clk_src_simple_get,
+			evt->clk_ref_internal);
+	if (ret)
+		goto err_mux;
+
+	if (clk_select == 0)
+		ret = clk_set_parent(evt->clk_ref_internal, evt->clk_ref_a);
+	else
+		ret = clk_set_parent(evt->clk_ref_internal, evt->clk_ref_b);
+
+	if (ret)
+		goto err_clkp;
+
+	if (rate) {
+		ret = clk_set_rate(evt->clk_ref_internal, rate);
+		if (ret)
+			goto err_clkp;
+	}
+
+	hrtimer_init(&evt->poll_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
+	evt->poll_timer.function = pistachio_evt_poll;
+
+	evt->cc.mask = PISTACHIO_EVT_COUNTER_MASK;
+	evt->cc.read = pistachio_evt_cc_read;
+
+	pistachio_evt_writel(evt, PISTACHIO_EVT_TIMER_ENABLE_MASK,
+			PISTACHIO_EVT_TIMER_ENABLE);
+
+	pistachio_evt_start_count(evt);
+
+	pistachio_evt_clk_rate_change(evt);
+
+	timecounter_init(&evt->tc, (const struct cyclecounter *)&evt->cc, 0);
+
+#ifdef CONFIG_ATU
+	ret = atu_cyclecounter_register(&evt->cc, NULL);
+	if(ret)
+		goto err_count;
+#else
+	pistachio_evt_start_poll_timer(evt);
+
+	evt->evt_clk_notifier.notifier_call = pistachio_evt_clk_notifier_cb;
+	ret = clk_notifier_register(evt->clk_ref_internal,
+			&evt->evt_clk_notifier);
+	if (ret)
+		goto err_count;
+#endif
+
+	/*
+	 * 2nd layer of muxing for event timer sources.
+	 * Not useful, use identity mapping
+	 */
+	for (i = 0; i < 12; i++) {
+		pistachio_evt_writel(evt, i,
+			PISTACHIO_EVT_SOURCE_INTERNAL_START + (i * 0x4));
+	}
+
+	return 0;
+
+err_count:
+#ifndef	CONFIG_ATU
+	hrtimer_cancel(&evt->poll_timer);
+#endif
+	pistachio_evt_stop_count(evt);
+	pistachio_evt_writel(evt, 0, PISTACHIO_EVT_TIMER_ENABLE);
+err_clkp:
+	of_clk_del_provider(np);
+err_mux:
+	clk_unregister(evt->clk_ref_internal);
+err_sys:
+	clk_disable_unprepare(evt->clk_sys);
+err_ref_b:
+	clk_disable_unprepare(evt->clk_ref_b);
+err_ref_a:
+	clk_disable_unprepare(evt->clk_ref_a);
+
+	return ret;
+}
+
+static const struct of_device_id pistachio_evt_of_match[] = {
+	{ .compatible = "img,pistachio-event-timer" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, pistachio_evt_of_match);
+
+static int pistachio_evt_driver_remove(struct platform_device *pdev)
+{
+	struct pistachio_evt_data *evt = platform_get_drvdata(pdev);
+
+#ifdef CONFIG_ATU
+	atu_cyclecounter_unregister(&evt->cc);
+#else
+	clk_notifier_unregister(evt->clk_ref_internal, &evt->evt_clk_notifier);
+	hrtimer_cancel(&evt->poll_timer);
+#endif
+	of_clk_del_provider(evt->dev->of_node);
+	pistachio_evt_stop_count(evt);
+	pistachio_evt_writel(evt, 0, PISTACHIO_EVT_TIMER_ENABLE);
+	clk_unregister(evt->clk_ref_internal);
+	clk_disable_unprepare(evt->clk_sys);
+	clk_disable_unprepare(evt->clk_ref_b);
+	clk_disable_unprepare(evt->clk_ref_a);
+
+	return 0;
+}
+
+static struct platform_driver pistachio_evt_driver = {
+	.driver = {
+		.name = "pistachio-event-timer",
+		.of_match_table = pistachio_evt_of_match,
+	},
+	.probe = pistachio_evt_driver_probe,
+	.remove = pistachio_evt_driver_remove,
+};
+module_platform_driver(pistachio_evt_driver);
+
+MODULE_DESCRIPTION("Event Timer driver");
+MODULE_AUTHOR("Damien Horsley");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/img/pistachio-event-timer.h b/sound/soc/img/pistachio-event-timer.h
new file mode 100644
index 0000000..458807f
--- /dev/null
+++ b/sound/soc/img/pistachio-event-timer.h
@@ -0,0 +1,54 @@
+/*
+ * Imagination Technologies Pistachio Event Timer Header
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#ifndef __IMG_PISTACHIO_EVT_H__
+#define __IMG_PISTACHIO_EVT_H__
+
+enum pistachio_evt_enable {
+	PISTACHIO_EVT_ENABLE_PARALLEL_OUT = 0,
+	PISTACHIO_EVT_ENABLE_I2S_OUT,
+	PISTACHIO_EVT_ENABLE_SPDIF_OUT,
+	PISTACHIO_EVT_ENABLE_IRQ_0,
+	PISTACHIO_EVT_ENABLE_IRQ_1,
+	PISTACHIO_EVT_ENABLE_EXTERNAL,
+	PISTACHIO_EVT_NUM_ENABLES
+};
+
+enum pistachio_evt_type {
+	PISTACHIO_EVT_TYPE_NONE = 0,
+	PISTACHIO_EVT_TYPE_PULSE,
+	PISTACHIO_EVT_TYPE_LEVEL
+};
+
+#define	PISTACHIO_EVT_NUM_TIMESTAMP_MODULES	12
+
+extern void pistachio_evt_read(struct platform_device *pdev,
+				struct timespec *ts);
+
+extern void pistachio_evt_disable_event(struct platform_device *pdev,
+		enum pistachio_evt_enable event);
+
+extern void _pistachio_evt_disable_event(struct platform_device *pdev,
+		enum pistachio_evt_enable event);
+
+extern int pistachio_evt_set_event(struct platform_device *pdev,
+		enum pistachio_evt_enable event, enum pistachio_evt_type type,
+		struct timespec *ts,
+		void (*event_trigger_callback)(void *context), void *context);
+
+extern int pistachio_evt_set_timestamp_source(struct platform_device *pdev,
+		unsigned int ts_module_index, unsigned int interrupt_source);
+
+extern int pistachio_evt_get_timestamp(struct platform_device *pdev,
+		unsigned int ts_module_index, struct timespec *timestamp);
+
+#endif
diff --git a/sound/soc/soc-generic-dmaengine-pcm.c b/sound/soc/soc-generic-dmaengine-pcm.c
index 6fd1906..1cc5483 100644
--- a/sound/soc/soc-generic-dmaengine-pcm.c
+++ b/sound/soc/soc-generic-dmaengine-pcm.c
@@ -35,6 +35,7 @@ struct dmaengine_pcm {
 	const struct snd_dmaengine_pcm_config *config;
 	struct snd_soc_platform platform;
 	unsigned int flags;
+	bool dma_pre_started;
 };
 
 static struct dmaengine_pcm *soc_platform_to_pcm(struct snd_soc_platform *p)
@@ -318,14 +319,90 @@ static snd_pcm_uframes_t dmaengine_pcm_pointer(
 		return snd_dmaengine_pcm_pointer(substream);
 }
 
+int dmaengine_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct dmaengine_pcm *pcm = soc_platform_to_pcm(rtd->platform);
+	struct dma_chan *dma_chan = snd_dmaengine_pcm_get_chan(substream);
+	int ret;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		if(!pcm->dma_pre_started) {
+			ret = dmaengine_pcm_prepare_and_submit(substream);
+			if (ret)
+				return ret;
+			dma_async_issue_pending(dma_chan);
+		}
+		break;
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->runtime->hw.info & SNDRV_PCM_INFO_RESUME)
+			dmaengine_resume(dma_chan);
+		else
+			return -ENOSYS;
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->runtime->hw.info & SNDRV_PCM_INFO_PAUSE)
+			dmaengine_pause(dma_chan);
+		else
+			dmaengine_terminate_all(dma_chan);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		dmaengine_terminate_all(dma_chan);
+		pcm->dma_pre_started = false;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int dmaengine_start_at(struct snd_pcm_substream *substream,
+	int audio_clock_type, const struct timespec *ts)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct dmaengine_pcm *pcm = soc_platform_to_pcm(rtd->platform);
+	struct dma_chan *dma_chan = snd_dmaengine_pcm_get_chan(substream);
+	int ret;
+
+	if(pcm->flags & SND_DMAENGINE_PCM_FLAG_EARLY_START) {
+		ret = dmaengine_pcm_prepare_and_submit(substream);
+		if (ret)
+			return ret;
+		dma_async_issue_pending(dma_chan);
+		pcm->dma_pre_started = true;
+	}
+
+	return 0;
+}
+
+static int dmaengine_start_at_abort(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct dmaengine_pcm *pcm = soc_platform_to_pcm(rtd->platform);
+	struct dma_chan *dma_chan = snd_dmaengine_pcm_get_chan(substream);
+
+	if(pcm->dma_pre_started) {
+		dmaengine_terminate_all(dma_chan);
+		pcm->dma_pre_started = false;
+	}
+
+	return 0;
+}
+
 static const struct snd_pcm_ops dmaengine_pcm_ops = {
 	.open		= dmaengine_pcm_open,
 	.close		= snd_dmaengine_pcm_close,
 	.ioctl		= snd_pcm_lib_ioctl,
 	.hw_params	= dmaengine_pcm_hw_params,
 	.hw_free	= snd_pcm_lib_free_pages,
-	.trigger	= snd_dmaengine_pcm_trigger,
+	.trigger	= dmaengine_pcm_trigger,
 	.pointer	= dmaengine_pcm_pointer,
+	.start_at	= dmaengine_start_at,
+	.start_at_abort = dmaengine_start_at_abort
 };
 
 static const struct snd_soc_platform_driver dmaengine_pcm_platform = {
diff --git a/sound/soc/soc-pcm.c b/sound/soc/soc-pcm.c
index 65b936e..dc00de9 100644
--- a/sound/soc/soc-pcm.c
+++ b/sound/soc/soc-pcm.c
@@ -1072,6 +1072,91 @@ static int soc_pcm_bespoke_trigger(struct snd_pcm_substream *substream,
 	}
 	return 0;
 }
+
+static int soc_pcm_start_at(struct snd_pcm_substream *substream,
+	int audio_clock_type, const struct timespec *start_time)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_platform *platform = rtd->platform;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai;
+	int i, ret;
+
+	for (i = 0; i < rtd->num_codecs; i++) {
+		codec_dai = rtd->codec_dais[i];
+		if (codec_dai->driver->ops &&
+		    codec_dai->driver->ops->start_at) {
+			ret = codec_dai->driver->ops->start_at(substream,
+				codec_dai, audio_clock_type, start_time);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	if (platform->driver->ops && platform->driver->ops->start_at) {
+		ret = platform->driver->ops->start_at(substream,
+					audio_clock_type, start_time);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (cpu_dai->driver->ops && cpu_dai->driver->ops->start_at) {
+		ret = cpu_dai->driver->ops->start_at(substream,
+			cpu_dai, audio_clock_type, start_time);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (rtd->dai_link->ops && rtd->dai_link->ops->start_at) {
+		ret = rtd->dai_link->ops->start_at(substream,
+			audio_clock_type, start_time);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int soc_pcm_start_at_abort(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_platform *platform = rtd->platform;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai;
+	int i, ret;
+
+	for (i = 0; i < rtd->num_codecs; i++) {
+		codec_dai = rtd->codec_dais[i];
+		if (codec_dai->driver->ops &&
+		    codec_dai->driver->ops->start_at_abort) {
+			ret = codec_dai->driver->ops->start_at_abort(
+				substream, codec_dai);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	if (platform->driver->ops && platform->driver->ops->start_at_abort) {
+		ret = platform->driver->ops->start_at_abort(substream);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (cpu_dai->driver->ops && cpu_dai->driver->ops->start_at_abort) {
+		ret = cpu_dai->driver->ops->start_at_abort(substream, cpu_dai);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (rtd->dai_link->ops && rtd->dai_link->ops->start_at_abort) {
+		ret = rtd->dai_link->ops->start_at_abort(substream);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
 /*
  * soc level wrapper for pointer callback
  * If cpu_dai, codec_dai, platform driver has the delay callback, than
@@ -2617,6 +2702,8 @@ int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num)
 		rtd->ops.close		= dpcm_fe_dai_close;
 		rtd->ops.pointer	= soc_pcm_pointer;
 		rtd->ops.ioctl		= soc_pcm_ioctl;
+		rtd->ops.start_at	= soc_pcm_start_at;
+		rtd->ops.start_at_abort	= soc_pcm_start_at_abort;
 	} else {
 		rtd->ops.open		= soc_pcm_open;
 		rtd->ops.hw_params	= soc_pcm_hw_params;
@@ -2626,6 +2713,8 @@ int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num)
 		rtd->ops.close		= soc_pcm_close;
 		rtd->ops.pointer	= soc_pcm_pointer;
 		rtd->ops.ioctl		= soc_pcm_ioctl;
+		rtd->ops.start_at	= soc_pcm_start_at;
+		rtd->ops.start_at_abort	= soc_pcm_start_at_abort;
 	}
 
 	if (platform->driver->ops) {
-- 
2.6.2

