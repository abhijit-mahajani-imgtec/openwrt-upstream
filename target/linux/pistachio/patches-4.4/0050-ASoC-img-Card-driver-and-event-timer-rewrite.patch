From 340e222fb5fc4d8481c88a71f8daab8c3d5f8cd1 Mon Sep 17 00:00:00 2001
From: "Damien.Horsley" <Damien.Horsley@imgtec.com>
Date: Fri, 7 Aug 2015 16:55:12 +0100
Subject: ASoC: img: Card driver and event timer rewrite

Card driver and event timer driver rewritten to support
the range of Pistachio boards that now exist.

Change-Id: I3d079bd75456e548fb65433fe1e6680c10322d3d
Signed-off-by: Damien.Horsley <Damien.Horsley@imgtec.com>
---
 .../bindings/sound/img,pistachio-bub-audio.txt     |  331 +-
 .../bindings/sound/img,pistachio-event-timer.txt   |   18 +-
 include/dt-bindings/sound/pistachio-bub-audio.h    |    8 +-
 sound/soc/img/Kconfig                              |   33 +-
 sound/soc/img/Makefile                             |    5 +-
 sound/soc/img/pistachio-bub.c                      | 3179 ++++++++++++--------
 sound/soc/img/pistachio-event-timer-atu.c          |   68 +
 sound/soc/img/pistachio-event-timer-internal.h     |   69 +
 sound/soc/img/pistachio-event-timer-local.c        |  186 ++
 sound/soc/img/pistachio-event-timer.c              |  778 ++---
 sound/soc/img/pistachio-event-timer.h              |   58 +-
 11 files changed, 2881 insertions(+), 1852 deletions(-)
 create mode 100644 sound/soc/img/pistachio-event-timer-atu.c
 create mode 100644 sound/soc/img/pistachio-event-timer-internal.h
 create mode 100644 sound/soc/img/pistachio-event-timer-local.c

diff --git a/Documentation/devicetree/bindings/sound/img,pistachio-bub-audio.txt b/Documentation/devicetree/bindings/sound/img,pistachio-bub-audio.txt
index 9003887..9024641 100644
--- a/Documentation/devicetree/bindings/sound/img,pistachio-bub-audio.txt
+++ b/Documentation/devicetree/bindings/sound/img,pistachio-bub-audio.txt
@@ -1,10 +1,8 @@
-Imagination Technologies Pistachio Bring-Up Board (BuB) Audio Card Driver
-
-
+Imagination Technologies Pistachio Audio Card Driver
 
 Required properties:
 
-  - compatible : Compatible list, must contain "img,pistachio-bub-audio"
+  - compatible : Compatible list, must contain "img,pistachio-audio"
 
   - clocks : Contains an entry for each entry in clock-names
 
@@ -13,253 +11,242 @@ Required properties:
         "i2s_mclk"   The i2s reference clock
                      Also connected to i2s_out_0_mclk output
         "dac_clk"    Dac reference clock. Connected to i2s_dac_clk output
-        "evt_clk"    Event timer internal clock
-
-  - img,daughterboard : Contains daughterboard type. Valid identifiers
-                        (dt-bindings/sound/pistachio-bub-audio.h):
-
-        PISTACHIO_DAUGHTERBOARD_NONE       No daughterboard is connected, or
-                                           CN20 is not bridged
-        PISTACHIO_DAUGHTERBOARD_CODEC      The codec daughterboard is connected
-                                           and CN20 is bridged
-        PISTACHIO_DAUGHTERBOARD_BREAKOUT   The breakout daughterboard is
-                                           connected and CN20 is bridged
-
-  - img,mclk : Contains the mclk (master clock) source used by any codecs or
-               other external components.
-               Valid identifiers (dt-bindings/sound/pistachio-bub-audio.h):
-
-        PISTACHIO_MCLK_NONE      No mclk is required, or mclk is provided
-                                 externally with no software intervention
-                                 required to compenstate for differing sample
-                                 rates
 
-        PISTACHIO_MCLK_I2S       mclk is provided by the i2s_out_0_mclk output
-                                 from pistachio SoC. This clock is shared with
-                                 the internal i2s out controller
-
-        PISTACHIO_MCLK_DAC_CLK   mclk is provided by the i2s_dac_clk output
-                                 from pistachio SoC
-
-  - img,cr-periph : Must contain a phandle to the peripheral control syscon
+  - img,cr-periph : phandle of the peripheral control syscon
                     node which contains the i2s loopback control registers
 
-  - img,cr-top : Must contain a phandle to the top level control syscon
-                    node which contains the internal dac control registers
-
-  - img,event-timer : Must contain a reference to the event timer device node
+  - img,event-timer : phandle of event timer
 
 Optional properties:
 
-  - img,mclk-max : Contains a max constraint for the mclk rate. By default,
-                   the max rate is set to ULONG_MAX when the breakout board is
-                   used, else the max frequency supported by the pcm3060 and
-                   pcm3168a codecs (36.864Mhz)
+  - img,widgets : Please refer to widgets.txt
 
-  - widgets : Please refer to widgets.txt
-
-  - routing : A list of the connections between audio components.
+  - img,routing : A list of the connections between audio components.
               Each entry is a pair of strings, the first being the
               connection's sink, the second being the connection's
               source
 
+  - img,mute-gpio : phandle of the mute gpio
+
+  - img,hp-det-gpio : phandle of headphone detect gpio
+
+  - img,i2s-clk-loopback : LRCLK+BCLK signals for i2s out and i2s in
+			   controllers are connected internally
+
 Optional subnodes:
 
-  - spdif_out : Contains spdif out information
+  - spdif-out : Contains spdif out information
 
-  - spdif_in : Contains spdif in information
+  - spdif-in : Contains spdif in information
 
-  - parallel_out : Contains parallel out information
+  - parallel-out : Contains parallel out information
 
-  - i2s_out : Contais i2s out information
+  - i2s-out : Contains i2s out information
 
-  - i2s_in : Contains i2s in information
+  - i2s-in : Contains i2s in information
 
-Required spdif_out subnode properties:
+Required spdif-out subnode properties:
 
   - cpu-dai : phandle of spdif out cpu dai
 
-Required spdif_in subnode properties:
+Required spdif-in subnode properties:
 
   - cpu-dai : phandle of spdif in cpu dai
 
-Required parallel_out subnode properties:
+Required parallel-out subnode properties:
 
   - cpu-dai : phandle of parallel out cpu dai
 
-Optional parallel_out subnode properties:
-
-  - tpa6130a2 : phandle of the tpa6130a2 codec. Can be omitted
-                if the codec is bypassed
+  - sound-dai : phandle of internal dac
 
-Required i2s_out subnode properties:
+Required i2s-out subnode properties:
 
   - cpu-dai : phandle of i2s out cpu dai
 
-  - cpu-format : i2s out cpu format. "i2s" and "left_j" are supported by
-                 the pistachio BuB iteration of the img i2s out controller
-
-Optional i2s_out subnode properties:
-
-  - cpu-bitclock-inversion : i2s out cpu BCLK inversion
-
-  - cpu-frame-inversion : i2s out cpu LRCLK inversion
+  - format : I2S out format. "i2s" and "left_j" are supported by
+		     the Pistachio iteration of the i2s out controller
 
-  - cpu-continuous-clock : i2s out BCLK and LRCLK always active
+Optional i2s-out subnode properties:
 
-  - pcm3060 : phandle to pcm3060 codec (DAC). This should be present if
-              img,daughterboard is set to PISTACHIO_DAUGHTERBOARD_NONE and
-              the main board switches are set to I2C or SPI control for the
-              pcm3060. Do not include this if hardware control is selected
-              for the pcm3060 codec. This codec is connected to i2s out
-              channel 0
+  - bitclock-inversion : i2s out BCLK inversion
 
-  - pcm3060-format : i2s format. "i2s", "left_j" and "right_j" are supported
-                     by the pcm3060
+  - frame-inversion : i2s out LRCLK inversion
 
-  - pcm3060-bitclock-inversion : i2s BCLK inversion used by pcm3060
+  - continuous-clock : i2s out BCLK and LRCLK always active
 
-  - pcm3060-frame-inversion : i2s LRCLK inversion used by pcm3060
+Optional i2s-out subnodes:
 
-  - pcm3168a-1 : phandle to 1st pcm3168a codec (DAC). This should be present if
-              img,daughterboard is set to PISTACHIO_DAUGHTERBOARD_CODEC and
-              the codec daughterboard switches are set to I2C or SPI control
-              for the pcm3168a codecs. Do not include this if hardware control
-              is selected for the pcm3168a codecs. This codec is connected to
-              i2s out channels 0,1,2
+  - <codec-name> : Contains codec information. <codec-name> will be used as
+		   the prefix for the codec. This name must be unique for
+		   each individual codec (unique codec device node), and
+		   cannot be equal to "internal-dac". The name
+		   should be short to avoid control name truncation
 
-  - pcm3168a-1-format : i2s format. "i2s", "left_j", "right_j", "dsp_a" and
-                        "dsp_b" are supported by the pcm3168a
+Required i2s-in subnode properties:
 
-  - pcm3168a-1-bitclock-inversion : i2s BCLK inversion used by pcm3168a-1
+  - cpu-dai : phandle of i2s in cpu dai
 
-  - pcm3168a-1-frame-inversion : i2s LRCLK inversion used by pcm3168a-1
+  - format : i2s in format. "i2s" and "left_j" are supported by
+	     the Pistachio iteration of the i2s in controller
 
-  - pcm3168a-2 : phandle to 2nd pcm3168a codec (DAC). This should be present if
-              img,daughterboard is set to PISTACHIO_DAUGHTERBOARD_CODEC and
-              the codec daughterboard switches are set to I2C or SPI control
-              for the pcm3168a codecs. Do not include this if hardware control
-              is selected for the pcm3168a codecs. This codec is connected to
-              i2s out channels 3,4,5
+Optional i2s-in subnode properties:
 
-  - pcm3168a-2-format : i2s format. "i2s", "left_j", "right_j", "dsp_a" and
-                        "dsp_b" are supported by the pcm3168a
+  - bitclock-inversion : i2s out BCLK inversion
 
-  - pcm3168a-2-bitclock-inversion : i2s BCLK inversion used by pcm3168a-2
+  - frame-inversion : i2s out LRCLK inversion
 
-  - pcm3168a-2-frame-inversion : i2s LRCLK inversion used by pcm3168a-2
+  - continuous-clock : i2s out BCLK and LRCLK always active
 
-  - clock-master : phandle of the i2s out BCLK and LRCLK master. If these
-                   clocks are not required, or provided externally under
-                   hardware control, this may be omitted
+Optional i2s-in subnodes:
 
-Required i2s_out subnode properties:
+  - <codec-name> : Contains codec information. <codec-name> will be used as
+		   the prefix for the codec. This name must be unique for
+		   each individual codec (unique codec device node), and
+		   cannot be equal to "internal-dac". The name
+		   should be short to avoid control name truncation
 
-  - cpu-dai : phandle of i2s in cpu dai
+Required <codec-name> subnode properties:
 
-  - cpu-format : i2s in cpu format. "i2s" and "left_j" are supported by
-                 the pistachio BuB iteration of the img i2s in controller
+  - mclk : Contains the mclk (master clock) used by the DAC/ADC.
+	   Valid identifiers (dt-bindings/sound/pistachio-audio.h):
 
-Optional i2s_out subnode properties:
+	       PISTACHIO_MCLK_NONE      No mclk is required, or mclk is
+					provided externally with no software
+					intervention required to compenstate
+					for differing sample rates
 
-  - cpu-bitclock-inversion : i2s in cpu BCLK inversion
+	       PISTACHIO_MCLK_I2S       mclk is provided by the i2s_out_0_mclk
+					output from pistachio SoC. This clock
+					is shared with the internal i2s out
+					controller
 
-  - cpu-frame-inversion : i2s in cpu LRCLK inversion
+	       PISTACHIO_MCLK_DAC_CLK   mclk is provided by the i2s_dac_clk
+					output from pistachio SoC
 
-  - pcm3060 : phandle to pcm3060 codec (ADC). This should be present if
-              img,daughterboard is set to PISTACHIO_DAUGHTERBOARD_NONE and
-              the main board switches are set to I2C or SPI control for the
-              pcm3060. Do not include this if hardware control is selected
-              for the pcm3060 codec. This codec is connected to i2s in
-              channel 0
+Required <codec-name> subnode properties if mclk is not PISTACHIO_MCLK_NONE:
 
-  - pcm3060-format : i2s format. "i2s", "left_j" and "right_j" are supported
-                     by the pcm3060
+  - mclk-fs : Contains the set of fs ratios the DAC/ADC accepts (Nfs for
+	      sample rate r specifies the master clock input to the DAC is
+	      N times r). It is assumed this set of ratios is applicable to
+	      any given sample rate where this does not lead to a violation
+	      of the minimum/maximum frequencies specified by mclk-min-freq
+	      and mclk-max-freq respectively
 
-  - pcm3060-bitclock-inversion : i2s BCLK inversion used by pcm3060
+  - mclk-min-freq : Contains the minimum frequency the DAC/ADC accepts for
+		    its master clock input
 
-  - pcm3060-frame-inversion : i2s LRCLK inversion used by pcm3060
+  - mclk-max-freq : Contains the maximum frequency the DAC/ADC accepts for
+		    its master clock input
 
-  - pcm3168a-1 : phandle to 1st pcm3168a codec (ADC). This should be present if
-              img,daughterboard is set to PISTACHIO_DAUGHTERBOARD_CODEC and
-              the codec daughterboard switches are set to I2C or SPI control
-              for the pcm3168a codecs. Do not include this if hardware control
-              is selected for the pcm3168a codecs. This codec is connected to
-              i2s in channels 0,1,2
+Optional <codec-name> subnode properties:
 
-  - pcm3168a-1-format : i2s format. "i2s", "left_j", "right_j", "dsp_a" and
-                        "dsp_b" are supported by the pcm3168a
+  - sound-dai : phandle of the codec. If the codec does not accept/require
+		software configuration, this can be omitted
 
-  - pcm3168a-1-bitclock-inversion : i2s BCLK inversion used by pcm3168a-1
+  - mclk-index : Index of the mclk, used for snd_soc_dai_set_sysclk call.
+		 0 is used if this property is omitted
 
-  - pcm3168a-1-frame-inversion : i2s LRCLK inversion used by pcm3168a-1
+  - frame-master : Indicates this codec is the LRCLK master
 
-  - pcm3168a-2 : phandle to 2nd pcm3168a codec (ADC). This should be present if
-              img,daughterboard is set to PISTACHIO_DAUGHTERBOARD_CODEC and
-              the codec daughterboard switches are set to I2C or SPI control
-              for the pcm3168a codecs. Do not include this if hardware control
-              is selected for the pcm3168a codecs. This codec is connected to
-              i2s in channels 3,4,5
+  - bitclock-master : Indicates this codec is the BCLK master
 
-  - pcm3168a-2-format : i2s format. "i2s", "left_j", "right_j", "dsp_a" and
-                        "dsp_b" are supported by the pcm3168a
+  frame-master and bitclock-master cannot exist in more than one of the codec
+  subnodes
 
-  - pcm3168a-2-bitclock-inversion : i2s BCLK inversion used by pcm3168a-2
+  frame-master and bitclock-master cannot be used within i2s out codec subnodes
+  as the Pistachio iteration of the i2s out controller accepts master mode
+  only
 
-  - pcm3168a-2-frame-inversion : i2s LRCLK inversion used by pcm3168a-2
+  frame-master and bitclock-master can be omitted if img,i2s-clk-loopback is
+  used, or if LRCLK/BCLK generation does not require software intervention (eg
+  a codec operating in hardware-mode)
 
-  - clock-master : phandle of the i2s in BCLK and LRCLK master. If these
-                   clocks are not required, or provided externally under
-                   hardware control, this may be omitted. There is an internal
-                   loopback available that allows the i2s out BCLK/LRCLK to be
-                   used for the i2s in block. Link to the i2s out cpu node
-                   to use this
+Example 1 (Pistachio Bring-Up Board With Codec Daughterboard Inserted):
 
-Example:
+All audio components present on board. 2x pcm3168a codecs provide 3 i2s in
+and out channels each. dac_clk provides the single master clock to both
+codecs. The Pistachio i2s out controller is the LRCLK+BCLK master for the DAC
+path. The second pcm3168a codec is the LRCLK+BCLK master for the ADC path
 
 pistachio_audio_card {
-	compatible = "img,pistachio-bub-audio";
+	compatible = "img,pistachio-audio";
 
-	clocks = <&clk_core CLK_AUDIO_PLL &clk_core CLK_I2S_DIV
-	          &clk_core CLK_AUDIO &event_timer>;
-	clock-names = "audio_pll", "i2s_mclk", "dac_clk", "evt_clk";
+	clocks = <&clk_core CLK_AUDIO_PLL>,
+		 <&clk_core CLK_I2S_DIV>,
+		 <&clk_core CLK_AUDIO>;
+	clock-names = "audio_pll", "i2s_mclk", "dac_clk";
 
-	img,daughterboard = <PISTACHIO_DAUGHTERBOARD_CODEC>;
-	img,mclk = <PISTACHIO_MCLK_DAC_CLK>;
 	img,cr-periph = <&cr_periph>;
-	img,cr-top = <&cr_top>;
 	img,event-timer = <&event_timer>;
 
-	spdif_out: spdif_out {
-		cpu-dai = <&spdif_out_cpu>;
+	img,mute-gpio = <&gpio5 1 GPIO_ACTIVE_LOW>;
+	img,hp-det-gpio = <&gpio5 3 GPIO_ACTIVE_LOW>;
+
+	img,widgets = "Headphone", "Headphones",
+		      "Speaker", "Speakers",
+		      "Line", "RCA Out";
+
+	img,routing = "Headphones", "internal-dac AOUTL",
+		      "Headphones", "internal-dac AOUTR",
+		      "Speakers", "internal-dac AOUTL",
+		      "Speakers", "internal-dac AOUTR",
+		      "RCA Out", "internal-dac AOUTL",
+		      "RCA Out", "internal-dac AOUTR";
+
+	spdif-out {
+		cpu-dai = <&spdif_out>;
 	};
 
-	spdif_in: spdif_in {
-		cpu-dai = <&spdif_in_cpu>;
+	spdif-in {
+		cpu-dai = <&spdif_in>;
 	};
 
-	parallel_out: parallel_out {
-		cpu-dai = <&parallel_out_cpu>;
-		tpa6130a2 = <&tpa6130a2>;
+	parallel-out {
+		cpu-dai = <&parallel_out>;
+		sound-dai = <&internal_dac>;
 	};
 
-	i2s_out: i2s_out {
-		cpu-dai = <&i2s_out_cpu>;
-		cpu-format = "i2s";
-		pcm3168a-1 = <&pcm3168a_1 0>;
-		pcm3168a-1-format = "i2s";
-		pcm3168a-2 = <&pcm3168a_2 0>;
-		pcm3168a-2-format = "i2s";
-		clock-master = <&i2s_out_cpu>;
+	i2s-out {
+		cpu-dai = <&i2s_out>;
+		format = "i2s";
+
+		pcm3168a-1 {
+			mclk = <PISTACHIO_MCLK_DAC_CLK>;
+			mclk-fs = <128 192 256 384 512 768>;
+			mclk-min-freq = <2048000>;
+			mclk-max-freq = <36864000>;
+			sound-dai = <&pcm3168a_1 0>;
+		};
+
+		pcm3168a-2 {
+			mclk = <PISTACHIO_MCLK_DAC_CLK>;
+			mclk-fs = <128 192 256 384 512 768>;
+			mclk-min-freq = <2048000>;
+			mclk-max-freq = <36864000>;
+			sound-dai = <&pcm3168a_2 0>;
+		};
 	};
 
-	i2s_in: i2s_in {
-		cpu-dai = <&i2s_in_cpu>;
-		cpu-format = "i2s";
-		pcm3168a-1 = <&pcm3168a_1 1>;
-		pcm3168a-1-format = "i2s";
-		pcm3168a-2 = <&pcm3168a_2 1>;
-		pcm3168a-2-format = "i2s";
-		clock-master = <&pcm3168a_2 1>;
+	i2s-in {
+		cpu-dai = <&i2s_in>;
+		format = "i2s";
+
+		pcm3168a-1 {
+			mclk = <PISTACHIO_MCLK_DAC_CLK>;
+			mclk-fs = <256 384 512 768>;
+			mclk-min-freq = <2048000>;
+			mclk-max-freq = <36864000>;
+			sound-dai = <&pcm3168a_1 1>;
+		};
+
+		pcm3168a-2 {
+			mclk = <PISTACHIO_MCLK_DAC_CLK>;
+			mclk-fs = <256 384 512 768>;
+			mclk-min-freq = <2048000>;
+			mclk-max-freq = <36864000>;
+			sound-dai = <&pcm3168a_2 1>;
+			frame-master;
+			bitclock-master;
+		};
 	};
 };
diff --git a/Documentation/devicetree/bindings/sound/img,pistachio-event-timer.txt b/Documentation/devicetree/bindings/sound/img,pistachio-event-timer.txt
index 7341132..2e5e493 100644
--- a/Documentation/devicetree/bindings/sound/img,pistachio-event-timer.txt
+++ b/Documentation/devicetree/bindings/sound/img,pistachio-event-timer.txt
@@ -24,13 +24,18 @@ Required properties:
 	"sys"	The system clock
 	"ref0"	Reference clock 0
 	"ref1"	Reference clock 1
-
-		If ATU (in adjustable pll mode) is to be used, the
-		following is required:
 	"pll"	Audio PLL
 
   - img,clk-select : Reference select
 
+  - img,cr-periph : phandle of the peripheral control syscon node which
+		    contains the event timer external source bank select
+		    register
+
+  - img,ext-src-bank : GPIO bank selection for external source. For this source
+		       to function correctly, no other input gpios must be used
+		       within the selected GPIO bank
+
 Optional properties:
 
   - img,clk-rate : Initial internal clock rate
@@ -48,8 +53,11 @@ event_timer: event_timer@18102300 {
 		     <GIC_SHARED 56 IRQ_TYPE_LEVEL_HIGH>,
 		     <GIC_SHARED 57 IRQ_TYPE_LEVEL_HIGH>;
 	#clock-cells = <0>;
-	clocks = <&clk_core SYS_CLK_EVENT_TIMER &clk_core CLK_AUDIO &clk_core CLK_EVENT_TIMER>;
-	clock-names = "sys","ref0","ref1";
+	clocks = <&clk_core SYS_CLK_EVENT_TIMER>,
+		 <&clk_core CLK_AUDIO>,
+		 <&clk_core CLK_EVENT_TIMER>,
+		 <&clk_core CLK_AUDIO_PLL>;
+	clock-names = "sys","ref0","ref1", "pll";
 	img,clk-select = <1>;
 	img,clk-rate = <12288000>;
 };
diff --git a/include/dt-bindings/sound/pistachio-bub-audio.h b/include/dt-bindings/sound/pistachio-bub-audio.h
index 173020b..77ee75a 100644
--- a/include/dt-bindings/sound/pistachio-bub-audio.h
+++ b/include/dt-bindings/sound/pistachio-bub-audio.h
@@ -1,14 +1,8 @@
 #ifndef __PISTACHIO_BUB_AUDIO_H
 #define __PISTACHIO_BUB_AUDIO_H
 
-#define PISTACHIO_DAUGHTERBOARD_NONE		0
-#define PISTACHIO_DAUGHTERBOARD_CODEC		1
-#define PISTACHIO_DAUGHTERBOARD_BREAKOUT	2
-#define PISTACHIO_DAUGHTERBOARD_MAX		2
-
 #define PISTACHIO_MCLK_NONE		0
 #define PISTACHIO_MCLK_I2S		1
-#define PISTACHIO_MCLK_DAC_CLK		2
-#define PISTACHIO_MCLK_MAX		2
+#define PISTACHIO_MCLK_DAC		2
 
 #endif
diff --git a/sound/soc/img/Kconfig b/sound/soc/img/Kconfig
index e3d342c..35b11f0 100644
--- a/sound/soc/img/Kconfig
+++ b/sound/soc/img/Kconfig
@@ -47,7 +47,30 @@ config SND_SOC_IMG_SPDIF_OUT
 
 config SND_SOC_IMG_PISTACHIO_EVENT_TIMER
 	tristate "Support for Pistachio SoC Event Timer Driver"
+	depends on SND_SOC_IMG_PISTACHIO_EVENT_TIMER_ATU || SND_SOC_IMG_PISTACHIO_EVENT_TIMER_LOCAL
+	help
+	  Say Y or M if you want to add support for Pistachio event timer
+	  driver for Imagination Technologies Pistachio event timer device.
+
+choice
+	prompt "Pistachio Event Timer Time Units"
 	depends on SND_SOC_IMG
+	default SND_SOC_IMG_PISTACHIO_EVENT_TIMER_ATU if ATU
+	help
+	  Selects the time units used by the Pistachio Event Timer
+
+config SND_SOC_IMG_PISTACHIO_EVENT_TIMER_ATU
+	bool "Pistachio SoC Event Timer uses ATU units"
+	depends on ATU
+	help
+	  ATU units are used (atu time maintained by ATU driver)
+
+config SND_SOC_IMG_PISTACHIO_EVENT_TIMER_LOCAL
+	bool "Pistachio SoC Event Timer uses local units"
+	help
+	  Local units are used (nanoseconds since event timer probe)
+
+endchoice
 
 config SND_SOC_IMG_PISTACHIO_INTERNAL_DAC
 	tristate "Support for Pistachio SoC Internal DAC Driver"
@@ -57,8 +80,8 @@ config SND_SOC_IMG_PISTACHIO_INTERNAL_DAC
 	  driver for Imagination Technologies Pistachio internal DAC device.
 
 
-config SND_SOC_IMG_PISTACHIO_BUB
-	tristate "Audio support for Pistachio Bring-Up Board"
+config SND_SOC_IMG_PISTACHIO
+	tristate "Audio support for Pistachio SoC"
 	depends on SND_SOC_IMG
 	select SND_SOC_IMG_I2S_IN
 	select SND_SOC_IMG_I2S_OUT
@@ -66,6 +89,12 @@ config SND_SOC_IMG_PISTACHIO_BUB
 	select SND_SOC_IMG_SPDIF_IN
 	select SND_SOC_IMG_SPDIF_OUT
 	select SND_SOC_IMG_PISTACHIO_EVENT_TIMER
+	select SND_SOC_IMG_PISTACHIO_INTERNAL_DAC
+
+config SND_SOC_IMG_PISTACHIO_BUB
+	tristate "Audio support for Pistachio Bring-Up Board"
+	depends on SND_SOC_IMG
+	select SND_SOC_IMG_PISTACHIO
 	select SND_SOC_PCM3168A_I2C
 	select SND_SOC_PCM3168A_SPI
 	select SND_SOC_PCM3060_I2C
diff --git a/sound/soc/img/Makefile b/sound/soc/img/Makefile
index f1e8ad1..07cda66 100644
--- a/sound/soc/img/Makefile
+++ b/sound/soc/img/Makefile
@@ -5,5 +5,8 @@ obj-$(CONFIG_SND_SOC_IMG_SPDIF_IN) += img-spdif-in.o
 obj-$(CONFIG_SND_SOC_IMG_SPDIF_OUT) += img-spdif-out.o
 
 obj-$(CONFIG_SND_SOC_IMG_PISTACHIO_EVENT_TIMER) += pistachio-event-timer.o
+obj-$(CONFIG_SND_SOC_IMG_PISTACHIO_EVENT_TIMER_ATU) += pistachio-event-timer-atu.o
+obj-$(CONFIG_SND_SOC_IMG_PISTACHIO_EVENT_TIMER_LOCAL) += pistachio-event-timer-local.o
+obj-$(CONFIG_SND_SOC_IMG_PISTACHIO_INTERNAL_DAC) += pistachio-internal-dac.o
 
-obj-$(CONFIG_SND_SOC_IMG_PISTACHIO_BUB) += pistachio-bub.o
+obj-$(CONFIG_SND_SOC_IMG_PISTACHIO) += pistachio-bub.o
diff --git a/sound/soc/img/pistachio-bub.c b/sound/soc/img/pistachio-bub.c
index 27cfb26..2d906ff 100644
--- a/sound/soc/img/pistachio-bub.c
+++ b/sound/soc/img/pistachio-bub.c
@@ -1,7 +1,7 @@
 /*
- * Pistachio Bring-Up Board audio card driver
+ * Pistachio audio card driver
  *
- * Copyright (C) 2014 Imagination Technologies Ltd.
+ * Copyright (C) 2015 Imagination Technologies Ltd.
  *
  * Author: Damien Horsley <Damien.Horsley@imgtec.com>
  *
@@ -10,628 +10,826 @@
  * version 2, as published by the Free Software Foundation.
  */
 
-//#define	DEBUG
-//#define	VERBOSE_DEBUG
-
 #include <linux/clk.h>
-#include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/module.h>
+#include <linux/notifier.h>
 #include <linux/of_gpio.h>
-#include <linux/platform_device.h>
 #include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
 
 #include <linux/mfd/syscon.h>
-#include <linux/regmap.h>
 
 #include <sound/jack.h>
 #include <sound/soc.h>
 
-#include "../codecs/tpa6130a2.h"
-
 #include <dt-bindings/sound/pistachio-bub-audio.h>
 
 #include "pistachio-event-timer.h"
 
-extern void snd_pcm_startat_register(struct snd_pcm_substream *substream,
-	int clock_class, int clock_type, const struct timespec *start_time,
-	void *data);
-void snd_pcm_startat_unregister(struct snd_pcm_substream *substream);
-
-#define PISTACHIO_LINK_SPDIF_OUT	0
-#define PISTACHIO_LINK_SPDIF_IN		1
-#define PISTACHIO_LINK_PRL_OUT		2
-#define PISTACHIO_LINK_I2S_OUT		3
-#define PISTACHIO_LINK_I2S_IN		4
-
-#define PISTACHIO_CODEC_TPA6130A2	0
-#define PISTACHIO_CODEC_PCM3060_DAC	1
-#define PISTACHIO_CODEC_PCM3060_ADC	2
-#define PISTACHIO_CODEC_PCM3168A_1_DAC	3
-#define PISTACHIO_CODEC_PCM3168A_1_ADC	4
-#define PISTACHIO_CODEC_PCM3168A_2_DAC	5
-#define PISTACHIO_CODEC_PCM3168A_2_ADC	6
-#define PISTACHIO_CPU_I2S_OUT		7
-#define PISTACHIO_FRAME_EXTERNAL	8
-
-#define PISTACHIO_MAX_LINKS		5
-
-#define PISTACHIO_MAX_CODECS		7
-#define PISTACHIO_MAX_CODEC_DT_NODES	4
-
-static const unsigned int pistachio_clk_ratios[] = {
-	768,
-	512,
-	384,
-	256,
-	192,
-	128
+#define	PLL_RATE_8000_16000_32000_48000_96000_192000	147456000
+#define	PLL_RATE_11025_22050_44100_64000_88200_176400	135475200
+#define	PISTACHIO_MAX_DIV				256
+#define	PISTACHIO_MIN_MCLK_FREQ				(135475200 / 256)
+
+#define	PISTACHIO_CLOCK_MASTER_EXT	-1
+#define	PISTACHIO_CLOCK_MASTER_LOOPBACK	-2
+
+#define	PISTACHIO_MAX_I2S_CODECS	12
+
+#define	PISTACHIO_MAX_FS_RATES	20
+
+#define	PISTACHIO_I2S_MCLK_MAX_FREQ	200000000
+#define	PISTACHIO_DAC_MCLK_MAX_FREQ	200000000
+
+#define	PISTACHIO_INTERNAL_DAC_PREFIX	"internal-dac"
+
+#define PISTACHIO_I2S_LOOPBACK_REG		0x88
+#define PISTACHIO_I2S_LOOPBACK_CLK_MASK		0x3
+#define PISTACHIO_I2S_LOOPBACK_CLK_SHIFT	0
+
+#define PISTACHIO_I2S_LOOPBACK_CLK_NONE		0
+#define PISTACHIO_I2S_LOOPBACK_CLK_MFIO		1
+#define PISTACHIO_I2S_LOOPBACK_CLK_LOCAL	2
+
+struct pistachio_start_at {
+	enum pistachio_evt_enable enable;
+	spinlock_t lock;
+	struct snd_pcm_substream *substream;
+	unsigned int dummy_frames;
 };
 
-#define PCM1368A_PCM3060_MAX_MCLK			36864000
-#define PCM3168A_PCM3060_NUM_MCLK_RATIOS_DAC		6
-#define PCM3168A_PCM3060_NUM_MCLK_RATIOS_ADC		4
-#define PISTACHIO_I2S_MCLK_RATIO_START			2
-#define PISTACHIO_I2S_MCLK_NUM_RATIOS			2
+struct pistachio_output {
+	struct pistachio_start_at start_at;
+	unsigned int active_rate;
+};
 
-struct pistachio_codec {
-	unsigned int fmt;
+struct pistachio_parallel_out {
+	struct pistachio_output output;
+	struct snd_soc_dai_link_component internal_dac;
+};
+
+struct pistachio_mclk {
+	struct clk *mclk;
+	unsigned int cur_rate;
+	unsigned int min_rate;
+	unsigned int max_rate;
+};
+
+struct pistachio_i2s_mclk {
+	struct pistachio_mclk *mclk;
+	unsigned int *fs_rates;
+	unsigned int num_fs_rates;
+};
+
+struct pistachio_codec_i2s {
+	struct pistachio_mclk *mclk;
 	struct snd_soc_dai *dai;
+	unsigned int mclk_index;
+};
+
+struct pistachio_i2s {
+	struct pistachio_i2s_mclk mclk_a;
+	struct pistachio_i2s_mclk mclk_b;
+	struct pistachio_codec_i2s *codecs;
+	struct snd_soc_dai_link_component *components;
+	unsigned int num_codecs;
+};
+
+struct pistachio_i2s_out {
+	struct pistachio_i2s i2s;
+	struct pistachio_output output;
+	struct device *cpu_dev;
+};
+
+struct pistachio_i2s_in {
+	struct pistachio_i2s i2s;
+	unsigned int active_rate;
+	unsigned int fmt;
+	int frame_master;
+	int bitclock_master;
+	struct device *cpu_dev;
+};
+
+struct pistachio_i2s_codec_info_s {
+	const char *prefix;
+	const char *dai_name;
 	struct device_node *np;
+	struct pistachio_mclk *mclk;
+	unsigned int mclk_index;
+};
+
+struct pistachio_i2s_codec_info {
+	unsigned int total_codecs;
+	unsigned int unique_codecs;
+	int bitclock_master_idx;
+	int frame_master_idx;
+	struct pistachio_i2s_codec_info_s codecs[PISTACHIO_MAX_I2S_CODECS];
+};
+
+struct pistachio_i2s_mclk_fs_info {
+	unsigned int fs_rates[PISTACHIO_MAX_FS_RATES];
+	unsigned int num_fs_rates;
 };
 
-struct pistachio_card_data {
+struct pistachio_card {
+	struct pistachio_output *spdif_out;
+	struct pistachio_parallel_out *parallel_out;
+	struct pistachio_i2s_out *i2s_out;
+	struct pistachio_i2s_in *i2s_in;
+	bool spdif_in;
+	struct device_node *event_timer_np;
+	struct pistachio_evt *event_timer;
 	struct snd_soc_card card;
-	struct snd_soc_dai_link dai_links_st[PISTACHIO_MAX_LINKS];
-	struct snd_soc_dai_link *dai_links[PISTACHIO_MAX_LINKS];
-	struct snd_soc_dai_link_component codec_st[PISTACHIO_MAX_CODECS];
-	struct snd_soc_codec_conf codec_conf[PISTACHIO_MAX_CODEC_DT_NODES];
-	struct pistachio_codec codecs[PISTACHIO_MAX_CODECS];
-	unsigned int i2s_out_cpu_fmt;
-	unsigned int i2s_in_cpu_fmt;
 	struct snd_soc_jack hp_jack;
 	struct snd_soc_jack_pin hp_jack_pin;
 	struct snd_soc_jack_gpio hp_jack_gpio;
-	unsigned int i2s_out_master;
-	unsigned int i2s_in_master;
-	spinlock_t spdif_out_lock;
-	unsigned int spdif_out_active_rate;
-	struct snd_pcm_substream *spdif_out_start_at_substream;
-	spinlock_t parallel_out_lock;
-	unsigned int parallel_out_active_rate;
-	struct snd_pcm_substream *parallel_out_start_at_substream;
-	spinlock_t i2s_out_lock;
-	unsigned int i2s_out_active_rate;
-	struct snd_pcm_substream *i2s_out_start_at_substream;
-	unsigned int i2s_in_active_rate;
+	unsigned int mute_gpio;
+	bool mute_gpio_inverted;
+	struct mutex rate_mutex;
 	struct clk *audio_pll;
-	unsigned long audio_pll_rate;
-	struct clk *i2s_mclk;
-	unsigned long i2s_mclk_rate;
-	u32 db;
-	u32 mclk_source;
-	struct clk *dac_clk;
-	unsigned long dac_clk_rate;
-	struct clk *evt_clk;
-	unsigned long evt_clk_rate;
-	u32 mclk_max;
+	unsigned int audio_pll_rate;
+	struct pistachio_mclk i2s_mclk;
+	struct pistachio_mclk dac_mclk;
 	struct regmap *periph_regs;
-	struct regmap *top_regs;
 	struct notifier_block i2s_clk_notifier;
-	struct platform_device *event_timer;
-
+	struct snd_ctl_elem_id *sample_rate_ids[PISTACHIO_EVT_MAX_SOURCES];
+	struct snd_ctl_elem_id *phase_difference_id;
 };
 
-int pistachio_card_get_best_clk_rate(struct pistachio_card_data *pbc,
-		long rate, bool is_mclk, unsigned int ratios_start,
-		unsigned int num_ratios, long cur_rate,
-		unsigned long *new_clk_rate)
+static void pistachio_card_set_mclk_codecs(struct pistachio_i2s *i2s,
+			struct pistachio_mclk *mclk, unsigned int rate)
 {
 	int i;
-	long pre_div_rate, temp, diff, best_diff = LONG_MAX;
-	unsigned long best_pre_div_rate, clk_max;
-	bool change = false;
-	struct device *dev = pbc->card.dev;
-
-	clk_max = (is_mclk) ? pbc->mclk_max : ULONG_MAX;
-
-	dev_dbg(dev, "pistachio_card_get_best_clk_rate()\n");
-	dev_dbg(dev, "clk_ratios_start %u num_clk_ratios %u\n",
-		ratios_start, num_ratios);
-
-	for (i = ratios_start; i < (ratios_start + num_ratios); i++) {
-		temp = cur_rate / pistachio_clk_ratios[i];
-		diff = abs(temp - rate);
-		if (!diff)
-			break;
-		if (diff < best_diff)
-			best_diff = diff;
-	}
+	struct pistachio_codec_i2s *codec;
 
-	if (i != (ratios_start + num_ratios)) {
-		dev_dbg(dev, "current clk rate is optimal (zero diff)\n");
-		return 0;
-	}
-
-	dev_dbg(dev, "current clk rate may not be optimal, checking...\n");
-
-	for (i = ratios_start; i < (ratios_start + num_ratios); i++) {
-		pre_div_rate = rate * pistachio_clk_ratios[i];
-		temp = (pbc->audio_pll_rate + (pre_div_rate / 2)) / pre_div_rate;
-		if(temp > 256)
-			temp = 256;
-		pre_div_rate = (pbc->audio_pll_rate + (temp / 2)) / temp;
-
-		diff = abs((pre_div_rate / pistachio_clk_ratios[i]) - rate);
-		if ((diff < best_diff) && (pre_div_rate <= clk_max)) {
-			best_diff = diff;
-			best_pre_div_rate = pre_div_rate;
-			change = true;
+	for (i = 0; i < i2s->num_codecs; i++) {
+		codec = &i2s->codecs[i];
+		if (codec->mclk == mclk) {
+			snd_soc_dai_set_sysclk(codec->dai, codec->mclk_index,
+						rate, SND_SOC_CLOCK_IN);
 		}
 	}
-
-	if (!change) {
-		dev_dbg(dev, "current clk rate is optimal (diff %ld)\n",
-			best_diff);
-		return 0;
-	}
-
-	dev_dbg(dev, "New clk rate %lu (diff %ld)\n",
-		best_pre_div_rate, best_diff);
-
-	*new_clk_rate = best_pre_div_rate;
-
-	return 1;
 }
 
-int pistachio_card_update_codec_sysclks(struct pistachio_card_data *pbc,
-				unsigned long new_rate)
+static int pistachio_card_set_mclk(struct pistachio_card *pbc,
+		struct pistachio_mclk *mclk, unsigned int rate)
 {
-	struct pistachio_codec *codec;
 	int ret;
-
-	codec = &pbc->codecs[PISTACHIO_CODEC_PCM3060_DAC];
-	if (codec->dai) {
-		ret = snd_soc_dai_set_sysclk(codec->dai, 0, new_rate, 0);
-		if (ret)
-			return ret;
-	}
-
-	codec = &pbc->codecs[PISTACHIO_CODEC_PCM3060_ADC];
-	if (codec->dai) {
-		ret = snd_soc_dai_set_sysclk(codec->dai, 0, new_rate, 0);
-		if (ret)
+	unsigned int old_rate = mclk->cur_rate;
+
+	if (mclk->cur_rate != rate) {
+		/*
+		 * Set cur_rate before the clk_set_rate call to stop the i2s
+		 * mclk rate change callback rejecting the change
+		 */
+		mclk->cur_rate = rate;
+		ret = clk_set_rate(mclk->mclk, rate);
+		if (ret) {
+			mclk->cur_rate = old_rate;
 			return ret;
+		}
 	}
 
-	codec = &pbc->codecs[PISTACHIO_CODEC_PCM3168A_1_DAC];
-	if (!codec->dai)
-		codec = &pbc->codecs[PISTACHIO_CODEC_PCM3168A_1_ADC];
-	if (codec->dai) {
-		ret = snd_soc_dai_set_sysclk(codec->dai, 0, new_rate, 0);
-		if (ret)
-			return ret;
-	}
+	if (pbc->i2s_out)
+		pistachio_card_set_mclk_codecs(&pbc->i2s_out->i2s, mclk, rate);
 
-	codec = &pbc->codecs[PISTACHIO_CODEC_PCM3168A_2_DAC];
-	if (!codec->dai)
-		codec = &pbc->codecs[PISTACHIO_CODEC_PCM3168A_2_ADC];
-	if (codec->dai) {
-		ret = snd_soc_dai_set_sysclk(codec->dai, 0, new_rate, 0);
-		if (ret)
-			return ret;
-	}
+	if (pbc->i2s_in)
+		pistachio_card_set_mclk_codecs(&pbc->i2s_in->i2s, mclk, rate);
 
 	return 0;
 }
 
-int pistachio_card_set_dac_clk(struct pistachio_card_data *pbc,
-				long rate, bool dac)
+static int pistachio_card_set_pll_rate(struct pistachio_card *pbc,
+					unsigned int rate)
 {
-	int num_ratios, ret;
-	unsigned long new_rate;
-
-	num_ratios = (dac) ? (PCM3168A_PCM3060_NUM_MCLK_RATIOS_DAC) :
-			(PCM3168A_PCM3060_NUM_MCLK_RATIOS_ADC);
+	int ret;
+	unsigned int old_i2s_rate;
 
-	ret = pistachio_card_get_best_clk_rate(pbc, rate, true, 0, num_ratios,
-			pbc->dac_clk_rate, &new_rate);
-	if (ret <= 0)
-		return ret;
+	/*
+	 * If any active streams are currently using a clock derived
+	 * from the audio pll, a pll rate change cannot take place
+	 */
+	if ((pbc->spdif_out && pbc->spdif_out->active_rate) ||
+	(pbc->parallel_out && pbc->parallel_out->output.active_rate) ||
+	(pbc->i2s_out && pbc->i2s_out->output.active_rate) ||
+	(pbc->i2s_in && pbc->i2s_in->active_rate &&
+	pbc->i2s_in->i2s.mclk_a.mclk))
+		return -EBUSY;
 
-	if (dac && pbc->i2s_in_active_rate) {
-		dev_dbg(pbc->card.dev,
-			"Cannot change dclk rate, i2s in active\n");
-		return -EINVAL;
-	} else if (!dac && pbc->i2s_out_active_rate) {
-		dev_dbg(pbc->card.dev,
-			"Cannot change dclk rate, i2s out active\n");
-		return -EINVAL;
-	}
+	/*
+	 * Set cur_rate before the clk_set_rate call to stop the i2s
+	 * mclk rate change callback rejecting the change
+	 */
+	old_i2s_rate = pbc->i2s_mclk.cur_rate;
+	pbc->i2s_mclk.cur_rate = rate / (pbc->audio_pll_rate / old_i2s_rate);
 
-	ret = clk_set_rate(pbc->dac_clk, new_rate);
-	if (ret)
-		return ret;
+	ret = clk_set_rate(pbc->audio_pll, rate);
 
-	pbc->dac_clk_rate = new_rate;
+	if (ret) {
+		pbc->i2s_mclk.cur_rate = old_i2s_rate;
+	} else {
+		pbc->audio_pll_rate = rate;
+		pbc->dac_mclk.cur_rate = rate / (pbc->audio_pll_rate /
+						 pbc->dac_mclk.cur_rate);
+		pistachio_card_set_mclk(pbc, &pbc->i2s_mclk,
+				pbc->i2s_mclk.cur_rate);
+		pistachio_card_set_mclk(pbc, &pbc->dac_mclk,
+				pbc->dac_mclk.cur_rate);
+	}
 
-	return pistachio_card_update_codec_sysclks(pbc, new_rate);
+	return ret;
 }
 
-#define CR_AUDIO_DAC_CTRL		0x40
-#define CR_AUDIO_DAC_CTRL_MUTE_MASK	0x4
-#define CR_AUDIO_DAC_CTRL_PWR_SEL_MASK	0x2
-#define CR_AUDIO_DAC_CTRL_PWR_MASK	0x1
+static void pistachio_card_rate_err(struct pistachio_card *pbc,
+	struct pistachio_i2s_mclk *mclk_a, struct pistachio_i2s_mclk *mclk_b,
+	unsigned int rate_a, unsigned int rate_b)
+{
+	char *mclk_name, *dir_a, *dir_b;
 
-#define CR_AUDIO_DAC_RESET		0x44
-#define CR_AUDIO_DAC_RESET_SR_MASK	0x1
+	if (mclk_a->mclk == &pbc->i2s_mclk)
+		mclk_name = "i2s";
+	else
+		mclk_name = "dac";
 
-#define CR_AUDIO_DAC_GTI_CTRL			0x48
-#define CR_AUDIO_DAC_GTI_CTRL_ADDR_SHIFT	0
-#define CR_AUDIO_DAC_GTI_CTRL_ADDR_MASK		0xFFF
-#define CR_AUDIO_DAC_GTI_CTRL_WE_MASK		0x1000
-#define CR_AUDIO_DAC_GTI_CTRL_WDATA_SHIFT	13
-#define CR_AUDIO_DAC_GTI_CTRL_WDATA_MASK	0x1FE000
+	if (pbc->i2s_out && ((mclk_a == &pbc->i2s_out->i2s.mclk_a) ||
+			(mclk_a == &pbc->i2s_out->i2s.mclk_b))) {
+		dir_a = "I2S out";
+		dir_b = "I2S in";
+	} else {
+		dir_a = "I2S in";
+		dir_b = "I2S out";
+	}
 
-#define CR_AUDIO_DAC_GTI_OUT			0x4C
-#define CR_AUDIO_DAC_GTI_OUT_RDATA_SHIFT	0
-#define CR_AUDIO_DAC_GTI_OUT_RDATA_MASK		0xFF
+	if (!mclk_b) {
+		dev_err(pbc->card.dev,
+			"No valid rate for mclk %s (%s sample rate %u)\n",
+			mclk_name, dir_a, rate_a);
+	} else {
+		dev_err(pbc->card.dev,
+			"No valid rate for mclk %s (%s sample rate %u, %s sample rate %u)\n",
+			mclk_name, dir_a, rate_a, dir_b, rate_b);
+	}
+}
 
-static int pistachio_card_prl_out_link_init(struct snd_soc_pcm_runtime *rtd)
+static int pistachio_card_get_optimal_mclk_rate(struct pistachio_card *pbc,
+	struct pistachio_i2s_mclk *mclk_a, struct pistachio_i2s_mclk *mclk_b,
+	unsigned int rate_a, unsigned int rate_b, unsigned int *p_mclk_rate)
 {
-	struct pistachio_card_data *pbc = snd_soc_card_get_drvdata(rtd->card);
-	int ret;
-	struct pistachio_codec *pc;
+	int i, j;
+	unsigned int div, total_div, mclk_rate;
 
-	pc = &pbc->codecs[PISTACHIO_CODEC_TPA6130A2];
+	/*
+	 * If the current system clock rate has zero difference, do not
+	 * change the rate. This ensures a rate set using the "I2S Rates"
+	 * control will not be erroneously overridden by a hw_params call
+	 */
+	for (i = 0; i < mclk_a->num_fs_rates; i++)
+		if ((mclk_a->mclk->cur_rate / mclk_a->fs_rates[i]) == rate_a)
+			break;
+	if (i != mclk_a->num_fs_rates) {
+		if (mclk_b) {
+			for (i = 0; i < mclk_b->num_fs_rates; i++)
+				if ((mclk_b->mclk->cur_rate /
+						mclk_b->fs_rates[i]) == rate_b)
+					break;
+			if (i != mclk_b->num_fs_rates) {
+				*p_mclk_rate = mclk_a->mclk->cur_rate;
+				return 0;
+			}
+		} else {
+			*p_mclk_rate = mclk_a->mclk->cur_rate;
+			return 0;
+		}
+	}
 
-	if (pc->np && (pc->np == rtd->codec_dais[0]->dev->of_node)) {
-		pc->dai = rtd->codec_dais[0];
+	total_div = pbc->audio_pll_rate / rate_a;
 
-		ret = tpa6130a2_stereo_enable(pc->dai->codec, 1);
-	}
+	for (i = 0; i < mclk_a->num_fs_rates; i++) {
+		div = total_div / mclk_a->fs_rates[i];
+		if (div > PISTACHIO_MAX_DIV)
+			continue;
+		mclk_rate = pbc->audio_pll_rate / div;
+		if ((mclk_rate < mclk_a->mclk->min_rate) ||
+				(mclk_rate > mclk_a->mclk->max_rate))
+			continue;
+		if ((rate_a * mclk_a->fs_rates[i] * div) != pbc->audio_pll_rate)
+			continue;
 
-	regmap_update_bits(pbc->top_regs, CR_AUDIO_DAC_CTRL,
-			CR_AUDIO_DAC_CTRL_PWR_MASK, 1);
+		if (!mclk_b)
+			break;
 
-	msleep(10);
+		for (j = 0; j < mclk_b->num_fs_rates; j++) {
+			if ((rate_b * mclk_b->fs_rates[j] * div) ==
+					pbc->audio_pll_rate)
+				break;
+		}
+		if (j != mclk_b->num_fs_rates)
+			break;
+	}
 
-	regmap_update_bits(pbc->top_regs, CR_AUDIO_DAC_GTI_CTRL,
-			CR_AUDIO_DAC_GTI_CTRL_ADDR_MASK,
-			1 << CR_AUDIO_DAC_GTI_CTRL_ADDR_SHIFT);
+	if (i == mclk_a->num_fs_rates) {
+		pistachio_card_rate_err(pbc, mclk_a, mclk_b, rate_a, rate_b);
+		return -EINVAL;
+	}
 
-	regmap_update_bits(pbc->top_regs, CR_AUDIO_DAC_GTI_CTRL,
-			CR_AUDIO_DAC_GTI_CTRL_WDATA_MASK,
-			1 << CR_AUDIO_DAC_GTI_CTRL_WDATA_SHIFT);
+	*p_mclk_rate = mclk_rate;
 
-	regmap_update_bits(pbc->top_regs, CR_AUDIO_DAC_GTI_CTRL,
-			CR_AUDIO_DAC_GTI_CTRL_WE_MASK,
-			CR_AUDIO_DAC_GTI_CTRL_WE_MASK);
+	return 0;
+}
 
-	regmap_update_bits(pbc->top_regs, CR_AUDIO_DAC_GTI_CTRL,
-			CR_AUDIO_DAC_GTI_CTRL_WE_MASK, 0);
+static bool pistachio_card_mclk_active(struct pistachio_card *pbc,
+					struct pistachio_mclk *mclk)
+{
+	if (pbc->i2s_out && pbc->i2s_out->output.active_rate) {
+		if (pbc->i2s_out->i2s.mclk_a.mclk == mclk)
+			return true;
+		if (pbc->i2s_out->i2s.mclk_b.mclk == mclk)
+			return true;
+	}
 
-	regmap_update_bits(pbc->top_regs, CR_AUDIO_DAC_CTRL,
-			CR_AUDIO_DAC_CTRL_PWR_MASK, 0);
+	if (pbc->i2s_in && pbc->i2s_in->active_rate) {
+		if (pbc->i2s_in->i2s.mclk_a.mclk == mclk)
+			return true;
+		if (pbc->i2s_in->i2s.mclk_b.mclk == mclk)
+			return true;
+	}
 
-	return ret;
+	return false;
 }
 
-static int pistachio_card_parallel_out_startup(struct snd_pcm_substream *st)
+static int pistachio_card_update_mclk(struct pistachio_card *pbc,
+	struct pistachio_i2s_mclk *mclk_a, struct pistachio_i2s_mclk *mclk_b,
+	unsigned int rate_a, unsigned int rate_b)
 {
-	struct snd_soc_pcm_runtime *rtd = st->private_data;
-	struct pistachio_card_data *pbc = snd_soc_card_get_drvdata(rtd->card);
-	unsigned long flags;
+	unsigned int mclk_rate;
+	int ret;
+
+	ret = pistachio_card_get_optimal_mclk_rate(pbc, mclk_a, mclk_b, rate_a,
+							rate_b, &mclk_rate);
+	if (ret)
+		return ret;
 
-	spin_lock_irqsave(&pbc->parallel_out_lock, flags);
-	pbc->parallel_out_active_rate = 0;
-	spin_unlock_irqrestore(&pbc->parallel_out_lock, flags);
+	if (mclk_a->mclk->cur_rate != mclk_rate) {
+		if (pistachio_card_mclk_active(pbc, mclk_a->mclk))
+			return -EBUSY;
+		return pistachio_card_set_mclk(pbc, mclk_a->mclk, mclk_rate);
+	}
 
 	return 0;
 }
 
-static void pistachio_card_parallel_out_shutdown(struct snd_pcm_substream *st)
+static int pistachio_card_update_mclk_single(struct pistachio_card *pbc,
+		struct pistachio_i2s_mclk *mclk, unsigned int rate)
 {
-	struct snd_soc_pcm_runtime *rtd = st->private_data;
-	struct pistachio_card_data *pbc = snd_soc_card_get_drvdata(rtd->card);
-	unsigned long flags;
-
-	spin_lock_irqsave(&pbc->parallel_out_lock, flags);
-	pbc->parallel_out_active_rate = 0;
-	spin_unlock_irqrestore(&pbc->parallel_out_lock, flags);
+	return pistachio_card_update_mclk(pbc, mclk, NULL, rate, 0);
 }
 
-static int pistachio_card_parallel_out_hw_params(struct snd_pcm_substream *st,
-				struct snd_pcm_hw_params *params)
+static inline int pistachio_card_get_pll_rate(unsigned int rate)
 {
-	struct snd_soc_pcm_runtime *rtd = st->private_data;
-	struct pistachio_card_data *pbc = snd_soc_card_get_drvdata(rtd->card);
-
-	pbc->parallel_out_active_rate = params_rate(params);
-
-	return 0;
+	switch (rate) {
+	case 8000:
+	case 16000:
+	case 32000:
+	case 48000:
+	case 96000:
+	case 192000:
+		return PLL_RATE_8000_16000_32000_48000_96000_192000;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 64000:
+	case 88200:
+	case 176400:
+		return PLL_RATE_11025_22050_44100_64000_88200_176400;
+	default:
+		return -EINVAL;
+	}
 }
 
-static void pistachio_card_parallel_out_start_cb(void *context)
+static int _pistachio_card_change_rate(struct pistachio_card *pbc,
+			unsigned int rate, struct pistachio_i2s *i2s)
 {
-	struct pistachio_card_data *pbc;
-	unsigned long flags;
-	struct snd_pcm_substream *st;
-	//int ret;
-
-	pbc = (struct pistachio_card_data *)context;
+	int ret = 0;
+	unsigned int pll_rate;
 
-	spin_lock_irqsave(&pbc->parallel_out_lock, flags);
+	ret = pistachio_card_get_pll_rate(rate);
+	if (ret < 0)
+		return ret;
 
-	st = pbc->parallel_out_start_at_substream;
+	pll_rate = ret;
 
-	if (!st) {
-		spin_unlock_irqrestore(&pbc->parallel_out_lock, flags);
-		return;
+	if (pbc->audio_pll_rate != pll_rate) {
+		ret = pistachio_card_set_pll_rate(pbc, pll_rate);
+		if (ret)
+			return ret;
 	}
 
-	snd_pcm_stream_lock(st);
+	/*
+	 * Nothing more to do if an mclk is not used. The individual
+	 * cpu-dai drivers will make the required clock changes
+	 */
+	if (!i2s)
+		return 0;
 
-	snd_pcm_startat_unregister(st);
+	ret = pistachio_card_update_mclk_single(pbc, &i2s->mclk_a, rate);
+	if (ret)
+		return ret;
 
-	if(!snd_pcm_do_start(st, SNDRV_PCM_STATE_RUNNING))
-		snd_pcm_post_start(st, SNDRV_PCM_STATE_RUNNING);
+	if (!i2s->mclk_b.mclk)
+		return 0;
 
-	snd_pcm_stream_unlock(st);
+	return pistachio_card_update_mclk_single(pbc, &i2s->mclk_b, rate);
+}
 
-	_pistachio_evt_disable_event(pbc->event_timer,
-			PISTACHIO_EVT_ENABLE_PARALLEL_OUT);
+static int pistachio_card_change_rate(struct pistachio_card *pbc,
+			unsigned int rate, struct pistachio_i2s *i2s,
+			unsigned int *active_rate)
+{
+	int ret;
 
-	pbc->parallel_out_start_at_substream = NULL;
+	mutex_lock(&pbc->rate_mutex);
+	ret = _pistachio_card_change_rate(pbc, rate, i2s);
+	if (!ret)
+		*active_rate = rate;
+	mutex_unlock(&pbc->rate_mutex);
 
-	spin_unlock_irqrestore(&pbc->parallel_out_lock, flags);
+	return ret;
 }
 
-static int pistachio_card_parallel_out_start_at(struct snd_pcm_substream *st,
-		int clock_type, const struct timespec *ts)
+static void pistachio_card_start_at_cb(struct pistachio_evt *evt,
+					void *context)
 {
-	struct snd_soc_pcm_runtime *rtd = st->private_data;
-	struct pistachio_card_data *pbc = snd_soc_card_get_drvdata(rtd->card);
-	int ret;
+	struct pistachio_start_at *sa = context;
 	unsigned long flags;
 
-	ret = snd_pcm_pre_start(st, SNDRV_PCM_STATE_PREPARED);
-	if (ret)
-		return ret;
-
-	spin_lock_irqsave(&pbc->parallel_out_lock, flags);
+	spin_lock_irqsave(&sa->lock, flags);
 
-	ret = pistachio_evt_set_event(pbc->event_timer,
-		PISTACHIO_EVT_ENABLE_PARALLEL_OUT,
-		PISTACHIO_EVT_TYPE_LEVEL, (struct timespec *)ts,
-		pistachio_card_parallel_out_start_cb, pbc);
-	if (ret) {
-		spin_unlock_irqrestore(&pbc->parallel_out_lock, flags);
-		return ret;
+	if (!sa->substream) {
+		spin_unlock_irqrestore(&sa->lock, flags);
+		return;
 	}
 
-	snd_pcm_startat_register(st, SNDRV_PCM_CLOCK_CLASS_AUDIO,
-		clock_type, ts, NULL);
+	snd_pcm_start_at_trigger(sa->substream);
 
-	pbc->parallel_out_start_at_substream = st;
+	_pistachio_evt_disable_event(evt, sa->enable);
 
-	spin_unlock_irqrestore(&pbc->parallel_out_lock, flags);
+	sa->substream = NULL;
 
-	return 0;
+	spin_unlock_irqrestore(&sa->lock, flags);
 }
 
-static int pistachio_card_parallel_out_start_at_abort(
-		struct snd_pcm_substream *st)
+static int pistachio_card_start_at(struct pistachio_output *output,
+		struct pistachio_evt *evt, struct snd_pcm_substream *st,
+		const struct timespec *ts)
 {
-	struct snd_soc_pcm_runtime *rtd = st->private_data;
-	struct pistachio_card_data *pbc = snd_soc_card_get_drvdata(rtd->card);
+	int ret;
 	unsigned long flags;
+	struct timespec ts_sub, ts_new;
+	struct pistachio_start_at *sa = &output->start_at;
+	u64 temp;
 
-	spin_lock_irqsave(&pbc->parallel_out_lock, flags);
+	/* Adjust start time to account for dummy frames output at start */
+	temp = (u64)NSEC_PER_SEC * sa->dummy_frames;
+	ts_sub.tv_sec = 0;
+	ts_sub.tv_nsec = DIV_ROUND_CLOSEST_ULL(temp, output->active_rate);
+	ts_new = timespec_sub(*ts, ts_sub);
 
-	if (!pbc->parallel_out_start_at_substream) {
-		/* Already started */
-		spin_unlock_irqrestore(&pbc->parallel_out_lock, flags);
-		return -EINVAL;
-	}
+	spin_lock_irqsave(&sa->lock, flags);
 
-	snd_pcm_startat_unregister(st);
+	ret = pistachio_evt_set_event(evt, sa->enable,
+		PISTACHIO_EVT_TYPE_LEVEL, &ts_new,
+		pistachio_card_start_at_cb, sa);
+	if (!ret)
+		sa->substream = st;
 
-	pbc->parallel_out_start_at_substream = NULL;
+	spin_unlock_irqrestore(&sa->lock, flags);
 
-	spin_unlock_irqrestore(&pbc->parallel_out_lock, flags);
+	return ret;
+}
 
-	pistachio_evt_disable_event(pbc->event_timer,
-		PISTACHIO_EVT_ENABLE_PARALLEL_OUT);
+static int pistachio_card_start_at_abort(struct pistachio_start_at *sa,
+		struct pistachio_evt *evt, struct snd_pcm_substream *st)
+{
+	unsigned long flags;
 
-	return 0;
-}
+	if (spin_trylock_irqsave(&sa->lock, flags)) {
+		if (!sa->substream) {
+			/* Already started */
+			spin_unlock_irqrestore(&sa->lock, flags);
+			return -EINVAL;
+		}
 
-static struct snd_soc_ops pistachio_card_parallel_out_ops = {
-	.startup = pistachio_card_parallel_out_startup,
-	.shutdown = pistachio_card_parallel_out_shutdown,
-	.hw_params = pistachio_card_parallel_out_hw_params,
-	.start_at = pistachio_card_parallel_out_start_at,
-	.start_at_abort = pistachio_card_parallel_out_start_at_abort
-};
+		snd_pcm_start_at_cleanup(st);
 
-static int pistachio_card_parse_of_parallel_out(struct device_node *node,
-		struct pistachio_card_data *pbc, struct snd_soc_dai_link *link,
-		struct snd_soc_dai_link_component *components)
-{
-	struct device_node *np;
+		sa->substream = NULL;
 
-	link->name = link->stream_name = "pistachio-parallel-out";
-	np = of_parse_phandle(node, "cpu-dai", 0);
-	if (!np)
-		return -EINVAL;
-	link->cpu_of_node = np;
-	link->platform_of_node = np;
-	np = of_parse_phandle(node, "tpa6130a2", 0);
-	if (np) {
-		link->codecs = components;
-		link->codecs[0].of_node = np;
-		link->codecs[0].dai_name = "tpa6130a2";
-		pbc->codecs[PISTACHIO_CODEC_TPA6130A2].np = np;
-		link->num_codecs = 1;
+		spin_unlock_irqrestore(&sa->lock, flags);
 
+		pistachio_evt_disable_event(evt, sa->enable);
 	} else {
-		link->codec_dai_name = "snd-soc-dummy-dai";
-		link->codec_name = "snd-soc-dummy";
+		/* In the process of being started */
+		spin_unlock_irqrestore(&sa->lock, flags);
+		return -EINVAL;
 	}
-	link->init = pistachio_card_prl_out_link_init;
-	link->ops = &pistachio_card_parallel_out_ops;
 
-	return link->num_codecs;
+	return 0;
 }
 
-static int pistachio_card_spdif_out_startup(struct snd_pcm_substream *st)
+static int pistachio_card_i2s_link_init(struct pistachio_i2s *i2s,
+					struct snd_soc_pcm_runtime *rtd)
 {
-	struct snd_soc_pcm_runtime *rtd = st->private_data;
-	struct pistachio_card_data *pbc = snd_soc_card_get_drvdata(rtd->card);
-	unsigned long flags;
-
-	spin_lock_irqsave(&pbc->spdif_out_lock, flags);
-	pbc->spdif_out_active_rate = 0;
-	spin_unlock_irqrestore(&pbc->spdif_out_lock, flags);
+	int ret, i, id;
+	unsigned long rate;
+	struct pistachio_codec_i2s *codec;
+
+	for (i = 0; i < i2s->num_codecs; i++) {
+		codec = &i2s->codecs[i];
+		codec->dai = rtd->codec_dais[i];
+		if (codec->mclk) {
+			rate = codec->mclk->cur_rate;
+			id = codec->mclk_index;
+			ret = snd_soc_dai_set_sysclk(codec->dai, id, rate, 0);
+			if (ret)
+				return ret;
+		}
+	}
 
 	return 0;
 }
 
-static void pistachio_card_spdif_out_shutdown(struct snd_pcm_substream *st)
+static void pistachio_card_parallel_out_shutdown(struct snd_pcm_substream *st)
 {
 	struct snd_soc_pcm_runtime *rtd = st->private_data;
-	struct pistachio_card_data *pbc = snd_soc_card_get_drvdata(rtd->card);
-	unsigned long flags;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
 
-	spin_lock_irqsave(&pbc->spdif_out_lock, flags);
-	pbc->spdif_out_active_rate = 0;
-	spin_unlock_irqrestore(&pbc->spdif_out_lock, flags);
+	pbc->parallel_out->output.active_rate = 0;
 }
 
-static int pistachio_card_spdif_out_hw_params(struct snd_pcm_substream *st,
+static int pistachio_card_parallel_out_hw_params(struct snd_pcm_substream *st,
 				struct snd_pcm_hw_params *params)
 {
 	struct snd_soc_pcm_runtime *rtd = st->private_data;
-	struct pistachio_card_data *pbc = snd_soc_card_get_drvdata(rtd->card);
-
-	pbc->spdif_out_active_rate = params_rate(params);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
 
-	return 0;
+	return pistachio_card_change_rate(pbc, params_rate(params), NULL,
+				&pbc->parallel_out->output.active_rate);
 }
 
-static void pistachio_card_spdif_out_start_cb(void *context)
+static int pistachio_card_parallel_out_start_at(struct snd_pcm_substream *st,
+		int clock_type, const struct timespec *ts)
 {
-	struct pistachio_card_data *pbc;
-	unsigned long flags;
-	struct snd_pcm_substream *st;
-	//int ret;
-
-	pbc = (struct pistachio_card_data *)context;
-
-	spin_lock_irqsave(&pbc->spdif_out_lock, flags);
-
-	st = pbc->spdif_out_start_at_substream;
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
 
-	if (!st) {
-		spin_unlock_irqrestore(&pbc->spdif_out_lock, flags);
-		return;
-	}
+	return pistachio_card_start_at(&pbc->parallel_out->output,
+					pbc->event_timer, st, ts);
+}
 
-	snd_pcm_stream_lock(st);
+static int pistachio_card_parallel_out_start_at_abort(
+			struct snd_pcm_substream *st)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
 
-	snd_pcm_startat_unregister(st);
+	return pistachio_card_start_at_abort(
+					&pbc->parallel_out->output.start_at,
+					pbc->event_timer, st);
+}
 
-	if(!snd_pcm_do_start(st, SNDRV_PCM_STATE_RUNNING))
-		snd_pcm_post_start(st, SNDRV_PCM_STATE_RUNNING);
+static struct snd_soc_ops pistachio_card_parallel_out_ops = {
+	.shutdown = pistachio_card_parallel_out_shutdown,
+	.hw_params = pistachio_card_parallel_out_hw_params,
+	.start_at = pistachio_card_parallel_out_start_at,
+	.start_at_abort = pistachio_card_parallel_out_start_at_abort
+};
 
-	snd_pcm_stream_unlock(st);
+static void pistachio_card_spdif_out_shutdown(struct snd_pcm_substream *st)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
 
-	_pistachio_evt_disable_event(pbc->event_timer,
-			PISTACHIO_EVT_ENABLE_SPDIF_OUT);
+	pbc->spdif_out->active_rate = 0;
+}
 
-	pbc->spdif_out_start_at_substream = NULL;
+static int pistachio_card_spdif_out_hw_params(struct snd_pcm_substream *st,
+					struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
 
-	spin_unlock_irqrestore(&pbc->spdif_out_lock, flags);
+	return pistachio_card_change_rate(pbc, params_rate(params), NULL,
+					&pbc->spdif_out->active_rate);
 }
 
 static int pistachio_card_spdif_out_start_at(struct snd_pcm_substream *st,
 		int clock_type, const struct timespec *ts)
 {
 	struct snd_soc_pcm_runtime *rtd = st->private_data;
-	struct pistachio_card_data *pbc = snd_soc_card_get_drvdata(rtd->card);
-	int ret;
-	unsigned long flags;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
 
-	ret = snd_pcm_pre_start(st, SNDRV_PCM_STATE_PREPARED);
-	if (ret)
-		return ret;
+	return pistachio_card_start_at(pbc->spdif_out, pbc->event_timer,
+					st, ts);
+}
 
-	spin_lock_irqsave(&pbc->spdif_out_lock, flags);
+static int pistachio_card_spdif_out_start_at_abort(
+		struct snd_pcm_substream *st)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
 
-	ret = pistachio_evt_set_event(pbc->event_timer,
-		PISTACHIO_EVT_ENABLE_SPDIF_OUT,
-		PISTACHIO_EVT_TYPE_LEVEL, (struct timespec *)ts,
-		pistachio_card_spdif_out_start_cb, pbc);
-	if (ret) {
-		spin_unlock_irqrestore(&pbc->spdif_out_lock, flags);
-		return ret;
+	return pistachio_card_start_at_abort(&pbc->spdif_out->start_at,
+						pbc->event_timer, st);
+}
+
+static struct snd_soc_ops pistachio_card_spdif_out_ops = {
+	.shutdown = pistachio_card_spdif_out_shutdown,
+	.hw_params = pistachio_card_spdif_out_hw_params,
+	.start_at = pistachio_card_spdif_out_start_at,
+	.start_at_abort = pistachio_card_spdif_out_start_at_abort
+};
+
+static int pistachio_card_i2s_clk_cb(struct notifier_block *nb,
+					unsigned long event, void *data)
+{
+	struct clk_notifier_data *ndata = data;
+	struct pistachio_card *pbc;
+	unsigned int diff;
+	u64 cur_rate;
+	u64 tolerance;
+
+	pbc = container_of(nb, struct pistachio_card, i2s_clk_notifier);
+
+	cur_rate = pbc->i2s_mclk.cur_rate;
+
+	switch (event) {
+	case PRE_RATE_CHANGE:
+		diff = abs(ndata->new_rate - cur_rate);
+		tolerance = DIV_ROUND_CLOSEST_ULL(cur_rate * 5, 100);
+		if (diff < tolerance) {
+			/*
+			 * Fractional adjustment made by atu, or new rate set
+			 * by card driver if diff is zero
+			 */
+			return NOTIFY_OK;
+		} else {
+			/* Significant change made by i2s cpu dai driver */
+			return NOTIFY_STOP;
+		}
+	case POST_RATE_CHANGE:
+	case ABORT_RATE_CHANGE:
+		return NOTIFY_OK;
+	default:
+		return NOTIFY_DONE;
 	}
+}
 
-	snd_pcm_startat_register(st, SNDRV_PCM_CLOCK_CLASS_AUDIO,
-		clock_type, ts, NULL);
+static int pistachio_card_i2s_out_link_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
 
-	pbc->spdif_out_start_at_substream = st;
+	pbc->i2s_out->cpu_dev = rtd->cpu_dai->dev;
 
-	spin_unlock_irqrestore(&pbc->spdif_out_lock, flags);
+	return pistachio_card_i2s_link_init(&pbc->i2s_out->i2s, rtd);
+}
 
-	return 0;
+static void pistachio_card_i2s_out_shutdown(struct snd_pcm_substream *st)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	pbc->i2s_out->output.active_rate = 0;
 }
 
-static int pistachio_card_spdif_out_start_at_abort(
+static int pistachio_card_i2s_out_hw_params(struct snd_pcm_substream *st,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	return pistachio_card_change_rate(pbc, params_rate(params),
+		&pbc->i2s_out->i2s, &pbc->i2s_out->output.active_rate);
+}
+
+static int pistachio_card_i2s_out_start_at(struct snd_pcm_substream *st,
+		int clock_type, const struct timespec *ts)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	return pistachio_card_start_at(&pbc->i2s_out->output,
+					pbc->event_timer, st, ts);
+}
+
+static int pistachio_card_i2s_out_start_at_abort(
 		struct snd_pcm_substream *st)
 {
 	struct snd_soc_pcm_runtime *rtd = st->private_data;
-	struct pistachio_card_data *pbc = snd_soc_card_get_drvdata(rtd->card);
-	unsigned long flags;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
 
-	spin_lock_irqsave(&pbc->spdif_out_lock, flags);
+	return pistachio_card_start_at_abort(&pbc->i2s_out->output.start_at,
+						pbc->event_timer, st);
+}
 
-	if (!pbc->spdif_out_start_at_substream) {
-		/* Already started */
-		spin_unlock_irqrestore(&pbc->spdif_out_lock, flags);
-		return -EINVAL;
-	}
+static struct snd_soc_ops pistachio_card_i2s_out_ops = {
+	.shutdown = pistachio_card_i2s_out_shutdown,
+	.hw_params = pistachio_card_i2s_out_hw_params,
+	.start_at = pistachio_card_i2s_out_start_at,
+	.start_at_abort = pistachio_card_i2s_out_start_at_abort
+};
+
+static int pistachio_card_i2s_in_link_init(struct snd_soc_pcm_runtime *rtd)
+{
+	int ret, i;
+	unsigned int fmt;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+	u32 val;
+
+	pbc->i2s_in->cpu_dev = rtd->cpu_dai->dev;
+
+	ret = pistachio_card_i2s_link_init(&pbc->i2s_in->i2s, rtd);
+	if (ret)
+		return ret;
+
+	fmt = pbc->i2s_in->fmt | SND_SOC_DAIFMT_CBM_CFM;
+	ret = snd_soc_dai_set_fmt(rtd->cpu_dai, fmt);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < pbc->i2s_in->i2s.num_codecs; i++) {
+		fmt = pbc->i2s_in->fmt;
 
-	snd_pcm_startat_unregister(st);
+		if (i == pbc->i2s_in->frame_master)
+			if (i == pbc->i2s_in->bitclock_master)
+				fmt |= SND_SOC_DAIFMT_CBM_CFM;
+			else
+				fmt |= SND_SOC_DAIFMT_CBS_CFM;
+		else
+			if (i == pbc->i2s_in->bitclock_master)
+				fmt |= SND_SOC_DAIFMT_CBM_CFS;
+			else
+				fmt |= SND_SOC_DAIFMT_CBS_CFS;
 
-	pbc->spdif_out_start_at_substream = NULL;
+		ret = snd_soc_dai_set_fmt(rtd->codec_dais[i], fmt);
+		if (ret)
+			return ret;
+	}
 
-	spin_unlock_irqrestore(&pbc->spdif_out_lock, flags);
+	if (pbc->i2s_in->frame_master == PISTACHIO_CLOCK_MASTER_LOOPBACK)
+		val = PISTACHIO_I2S_LOOPBACK_CLK_LOCAL;
+	else
+		val = PISTACHIO_I2S_LOOPBACK_CLK_NONE;
 
-	pistachio_evt_disable_event(pbc->event_timer,
-		PISTACHIO_EVT_ENABLE_SPDIF_OUT);
+	regmap_update_bits(pbc->periph_regs, PISTACHIO_I2S_LOOPBACK_REG,
+				PISTACHIO_I2S_LOOPBACK_CLK_MASK, val);
 
 	return 0;
 }
 
-static struct snd_soc_ops pistachio_card_spdif_out_ops = {
-	.startup = pistachio_card_spdif_out_startup,
-	.shutdown = pistachio_card_spdif_out_shutdown,
-	.hw_params = pistachio_card_spdif_out_hw_params,
-	.start_at = pistachio_card_spdif_out_start_at,
-	.start_at_abort = pistachio_card_spdif_out_start_at_abort
+static void pistachio_card_i2s_in_shutdown(struct snd_pcm_substream *st)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	pbc->i2s_in->active_rate = 0;
+}
+
+static int pistachio_card_i2s_in_hw_params(struct snd_pcm_substream *st,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	return pistachio_card_change_rate(pbc, params_rate(params),
+		&pbc->i2s_in->i2s, &pbc->i2s_in->active_rate);
+}
+
+static struct snd_soc_ops pistachio_card_i2s_in_ops = {
+	.shutdown = pistachio_card_i2s_in_shutdown,
+	.hw_params = pistachio_card_i2s_in_hw_params
 };
 
 static int pistachio_card_parse_of_spdif_out(struct device_node *node,
-		struct pistachio_card_data *pbc, struct snd_soc_dai_link *link)
+		struct pistachio_card *pbc, struct snd_soc_dai_link *link)
 {
 	struct device_node *np;
 
+	pbc->spdif_out = devm_kzalloc(pbc->card.dev, sizeof(*pbc->spdif_out),
+					GFP_KERNEL);
+	if (!pbc->spdif_out)
+		return -ENOMEM;
+
+	pbc->spdif_out->start_at.enable = PISTACHIO_EVT_ENABLE_SPDIF_OUT;
+	pbc->spdif_out->start_at.dummy_frames = 1;
+	spin_lock_init(&pbc->spdif_out->start_at.lock);
+
 	link->name = link->stream_name = "pistachio-spdif-out";
+
 	np = of_parse_phandle(node, "cpu-dai", 0);
 	if (!np)
 		return -EINVAL;
+
 	link->cpu_of_node = np;
 	link->platform_of_node = np;
 	link->codec_dai_name = "snd-soc-dummy-dai";
@@ -642,14 +840,18 @@ static int pistachio_card_parse_of_spdif_out(struct device_node *node,
 }
 
 static int pistachio_card_parse_of_spdif_in(struct device_node *node,
-		struct pistachio_card_data *pbc, struct snd_soc_dai_link *link)
+		struct pistachio_card *pbc, struct snd_soc_dai_link *link)
 {
 	struct device_node *np;
 
+	pbc->spdif_in = true;
+
 	link->name = link->stream_name = "pistachio-spdif-in";
+
 	np = of_parse_phandle(node, "cpu-dai", 0);
 	if (!np)
 		return -EINVAL;
+
 	link->cpu_of_node = np;
 	link->platform_of_node = np;
 	link->codec_dai_name = "snd-soc-dummy-dai";
@@ -658,1059 +860,1433 @@ static int pistachio_card_parse_of_spdif_in(struct device_node *node,
 	return 0;
 }
 
-static int pistachio_card_find_codec_i2s(struct pistachio_card_data *pbc,
-		struct snd_soc_dai *codec, bool i2s_out)
+static int pistachio_card_parse_of_parallel_out(struct device_node *node,
+		struct pistachio_card *pbc, struct snd_soc_dai_link *link)
 {
-	int i;
 	struct device_node *np;
-
-	for (i = 0; i < PISTACHIO_MAX_CODECS; i++) {
-		np = pbc->codecs[i].np;
-		if (np && (np == codec->dev->of_node)) {
-			switch (i) {
-			case PISTACHIO_CODEC_PCM3060_DAC:
-			case PISTACHIO_CODEC_PCM3060_ADC:
-				if (i2s_out)
-					return PISTACHIO_CODEC_PCM3060_DAC;
-				else
-					return PISTACHIO_CODEC_PCM3060_ADC;
-			case PISTACHIO_CODEC_PCM3168A_1_DAC:
-			case PISTACHIO_CODEC_PCM3168A_1_ADC:
-				if (i2s_out)
-					return PISTACHIO_CODEC_PCM3168A_1_DAC;
-				else
-					return PISTACHIO_CODEC_PCM3168A_1_ADC;
-			case PISTACHIO_CODEC_PCM3168A_2_DAC:
-			case PISTACHIO_CODEC_PCM3168A_2_ADC:
-				if (i2s_out)
-					return PISTACHIO_CODEC_PCM3168A_2_DAC;
-				else
-					return PISTACHIO_CODEC_PCM3168A_2_ADC;
-			default:
-				return -1;
-			}
-		}
-	}
-
-	return -1;
-}
-
-static int pistachio_card_i2s_mclk_setup(struct pistachio_card_data *pbc,
-		unsigned int rate, bool i2s_out_mclk_shared, bool i2s_out)
-{
 	int ret;
-	unsigned int ratio_start, num_ratios;
-	unsigned long new_rate, temp;
 
-	if (i2s_out) {
-		ratio_start = PISTACHIO_I2S_MCLK_RATIO_START;
-		num_ratios = PISTACHIO_I2S_MCLK_NUM_RATIOS;
-	} else {
-		ratio_start = 0;
-		num_ratios = PCM3168A_PCM3060_NUM_MCLK_RATIOS_ADC;
-	}
+	pbc->parallel_out = devm_kzalloc(pbc->card.dev,
+			sizeof(*pbc->parallel_out), GFP_KERNEL);
+	if (!pbc->parallel_out)
+		return -ENOMEM;
 
-	ret = pistachio_card_get_best_clk_rate(pbc, rate, i2s_out_mclk_shared,
-			ratio_start, num_ratios, pbc->i2s_mclk_rate, &new_rate);
-	if (ret <= 0)
-		return ret;
+	pbc->parallel_out->output.start_at.enable =
+			PISTACHIO_EVT_ENABLE_PARALLEL_OUT;
+	pbc->parallel_out->output.start_at.dummy_frames = 2;
+	spin_lock_init(&pbc->parallel_out->output.start_at.lock);
 
-	if (i2s_out_mclk_shared) {
-		if (i2s_out && pbc->i2s_in_active_rate) {
-			dev_dbg(pbc->card.dev,
-				"Cannot change mclk rate, i2s in active\n");
-			return -EINVAL;
-		} else if (!i2s_out && pbc->i2s_out_active_rate) {
-			dev_dbg(pbc->card.dev,
-				"Cannot change mclk rate, i2s out active\n");
-			return -EINVAL;
-		}
-	}
+	link->name = link->stream_name = "pistachio-parallel-out";
 
-	temp = pbc->i2s_mclk_rate;
-	pbc->i2s_mclk_rate = new_rate;
+	np = of_parse_phandle(node, "cpu-dai", 0);
+	if (!np)
+		return -EINVAL;
 
-	ret = clk_set_rate(pbc->i2s_mclk, new_rate);
-	if (ret) {
-		pbc->i2s_mclk_rate = temp;
+	link->cpu_of_node = np;
+	link->platform_of_node = np;
+	link->codecs = &pbc->parallel_out->internal_dac;
+	np = of_parse_phandle(node, "sound-dai", 0);
+	if (!np)
+		return -EINVAL;
+	link->codecs[0].of_node = np;
+	link->num_codecs = 1;
+	ret = snd_soc_of_get_dai_name(node, &link->codecs[0].dai_name);
+	if (ret)
 		return ret;
-	}
 
-	if (i2s_out_mclk_shared)
-		return pistachio_card_update_codec_sysclks(pbc, new_rate);
+	link->ops = &pistachio_card_parallel_out_ops;
 
 	return 0;
 }
 
-static int pistachio_card_i2s_clk_notifier_cb(struct notifier_block *nb,
-		unsigned long event, void *data)
+static int pistachio_card_parse_of_i2s_mclk(struct device_node *np,
+	struct pistachio_mclk *mclk, struct pistachio_i2s_mclk_fs_info *fs)
 {
-	struct clk_notifier_data *ndata = data;
-	struct pistachio_card_data *pbc;
-	int diff;
-	u64 tolerance;
+	int ret, i, j, k, num_fs_rates;
+	u32 min_freq, max_freq, fs_rates[PISTACHIO_MAX_FS_RATES];
+
+	ret = of_property_read_u32(np, "mclk-min-freq", &min_freq);
+	if (ret)
+		return ret;
+	ret = of_property_read_u32(np, "mclk-max-freq", &max_freq);
+	if (ret)
+		return ret;
 
-	pbc = container_of(nb, struct pistachio_card_data, i2s_clk_notifier);
+	if (max_freq < PISTACHIO_MIN_MCLK_FREQ)
+		return -EINVAL;
+	if (min_freq > mclk->min_rate)
+		mclk->min_rate = min_freq;
+	if (max_freq < mclk->max_rate)
+		mclk->max_rate = max_freq;
+	if (mclk->min_rate > mclk->max_rate)
+		return -EINVAL;
 
-	switch (event) {
-	case PRE_RATE_CHANGE:
-		diff = abs((int)ndata->new_rate - (int)pbc->i2s_mclk_rate);
+	num_fs_rates = of_property_count_u32_elems(np, "mclk-fs");
+	if (num_fs_rates < 0)
+		return num_fs_rates;
+	if (!num_fs_rates || (num_fs_rates > PISTACHIO_MAX_FS_RATES))
+		return -EINVAL;
 
-		tolerance = ((u64)pbc->i2s_mclk_rate * 5) + 50;
-		do_div(tolerance, 100);
+	ret = of_property_read_u32_array(np, "mclk-fs", fs_rates,
+						num_fs_rates);
+	if (ret)
+		return ret;
 
-		if (diff < (int)tolerance) {
-			dev_dbg(pbc->card.dev,
-				"rate change OK (%lu)\n", ndata->new_rate);
-			return NOTIFY_OK;
-		} else {
-			dev_dbg(pbc->card.dev,
-				"rate change DENIED (%lu)\n", ndata->new_rate);
-			return NOTIFY_STOP;
+	/*
+	 * If this is the first fs-rates list for this combination
+	 * of {i2s direction, mclk}, this list defines the
+	 * current fs-rate list for this combination. Else, this list
+	 * subtracts any fs-rates that are not present in both lists from the
+	 * current list for this combination
+	 */
+	if (!fs->num_fs_rates) {
+		for (i = 0; i < num_fs_rates; i++)
+			fs->fs_rates[i] = fs_rates[i];
+		fs->num_fs_rates = num_fs_rates;
+	} else {
+		for (j = 0; j < fs->num_fs_rates; j++) {
+			for (i = 0; i < num_fs_rates; i++)
+				if (fs->fs_rates[j] == fs_rates[i])
+					break;
+			if (i == num_fs_rates) {
+				for (k = j; k < (fs->num_fs_rates - 1); k++)
+					fs->fs_rates[k] = fs->fs_rates[k + 1];
+				fs->num_fs_rates--;
+				if (!fs->num_fs_rates)
+					return -EINVAL;
+				j--;
+			}
 		}
-	case POST_RATE_CHANGE:
-	case ABORT_RATE_CHANGE:
-		return NOTIFY_OK;
-	default:
-		return NOTIFY_DONE;
 	}
+
+	return 0;
 }
 
-static int pistachio_card_i2s_hw_params(struct pistachio_card_data *pbc,
-				unsigned int rate, bool out)
+static int pistachio_card_parse_of_i2s_codecs(struct device_node *np,
+			struct pistachio_card *pbc,
+			struct pistachio_i2s_codec_info *codec_info,
+			struct pistachio_i2s_mclk_fs_info *i2s_fs_info,
+			struct pistachio_i2s_mclk_fs_info *dac_fs_info)
 {
-	bool i2s_out_mclk_shared, use_dac_clk;
-	int ret;
-
-	i2s_out_mclk_shared = (pbc->mclk_source == PISTACHIO_MCLK_I2S);
-	use_dac_clk = (pbc->mclk_source == PISTACHIO_MCLK_DAC_CLK);
-
-	if (out) {
-		ret = pistachio_card_i2s_mclk_setup(pbc, rate,
-				i2s_out_mclk_shared, true);
+	int i, j, ret;
+	struct device_node *subnode, *codec;
+	struct pistachio_i2s_codec_info_s *info;
+	u32 mclk_id;
+	struct pistachio_mclk *mclk;
+	struct pistachio_i2s_mclk_fs_info *fs_info;
+
+	j = 0;
+	for_each_child_of_node(np, subnode) {
+		ret = of_property_read_u32(subnode, "mclk", &mclk_id);
 		if (ret)
 			return ret;
 
-		if (use_dac_clk) {
-			ret = pistachio_card_set_dac_clk(pbc, rate, true);
-			if (ret)
-				return ret;
+		switch (mclk_id) {
+		case PISTACHIO_MCLK_I2S:
+			mclk = &pbc->i2s_mclk;
+			fs_info = i2s_fs_info;
+			break;
+		case PISTACHIO_MCLK_DAC:
+			mclk = &pbc->dac_mclk;
+			fs_info = dac_fs_info;
+			break;
+		case PISTACHIO_MCLK_NONE:
+			mclk = NULL;
+			break;
+		default:
+			ret = -EINVAL;
+			goto err_subnode;
 		}
-	} else {
-		if (i2s_out_mclk_shared) {
-			ret = pistachio_card_i2s_mclk_setup(pbc, rate,
-				i2s_out_mclk_shared, false);
-			if (ret)
-				return ret;
-		} else if (use_dac_clk) {
-			ret = pistachio_card_set_dac_clk(pbc, rate, false);
+		if (mclk) {
+			ret = pistachio_card_parse_of_i2s_mclk(subnode, mclk,
+								fs_info);
 			if (ret)
-				return ret;
+				goto err_subnode;
+		}
+
+		codec = of_parse_phandle(subnode, "sound-dai", 0);
+		if (!codec)
+			continue;
+		if (codec_info->total_codecs == PISTACHIO_MAX_I2S_CODECS) {
+			ret = -EINVAL;
+			of_node_put(codec);
+			goto err_subnode;
+		}
+		for (i = 0; i < codec_info->total_codecs; i++)
+			if (codec_info->codecs[i].np == codec)
+				break;
+		if (i == codec_info->total_codecs)
+			codec_info->unique_codecs++;
+		info = &codec_info->codecs[codec_info->total_codecs++];
+		info->np = codec;
+		info->prefix = subnode->name;
+		ret = snd_soc_of_get_dai_name(subnode, &info->dai_name);
+		if (ret)
+			goto err_subnode;
+		info->mclk = mclk;
+		ret = of_property_read_u32(subnode, "mclk-index",
+						&info->mclk_index);
+		if (ret)
+			info->mclk_index = 0;
+		if (of_property_read_bool(subnode, "frame-master")) {
+			if (codec_info->frame_master_idx != -1) {
+				ret = -EINVAL;
+				goto err_subnode;
+			}
+			codec_info->frame_master_idx = j;
+		}
+		if (of_property_read_bool(subnode, "bitclock-master")) {
+			if (codec_info->bitclock_master_idx != -1) {
+				ret = -EINVAL;
+				goto err_subnode;
+			}
+			codec_info->bitclock_master_idx = j;
 		}
+		j++;
 	}
 
 	return 0;
+
+err_subnode:
+	of_node_put(subnode);
+	return ret;
 }
 
-static int pistachio_card_get_i2s_out_master(struct pistachio_card_data *pbc,
-					struct device_node *i2s_out_master)
+static int pistachio_card_parse_of_i2s_common(struct device_node *node,
+	struct pistachio_card *pbc, struct pistachio_i2s *i2s,
+	struct snd_soc_dai_link *link,
+	struct pistachio_i2s_codec_info *codec_info,
+	struct pistachio_i2s_mclk_fs_info *i2s_mclk_info,
+	struct pistachio_i2s_mclk_fs_info *dac_mclk_info)
 {
-	struct pistachio_codec *codec;
-	struct snd_soc_dai_link *link = pbc->dai_links[PISTACHIO_LINK_I2S_OUT];
-	bool found = false;
+	int ret, i;
+	unsigned int initial_codecs = codec_info->total_codecs, size;
+	struct pistachio_i2s_codec_info_s *codecs;
+	struct pistachio_i2s_mclk *mclk;
 
-	if (!link)
-		return 0;
+	codecs = &codec_info->codecs[initial_codecs];
 
-	if (IS_ERR(i2s_out_master))
-		return PTR_ERR(i2s_out_master);
+	ret = pistachio_card_parse_of_i2s_codecs(node, pbc, codec_info,
+					i2s_mclk_info, dac_mclk_info);
+	i2s->num_codecs = codec_info->total_codecs - initial_codecs;
+	if (ret)
+		goto err_codec_info;
+
+	mclk = &i2s->mclk_a;
+
+	if (i2s_mclk_info->num_fs_rates) {
+		mclk->mclk = &pbc->i2s_mclk;
+		mclk->num_fs_rates = i2s_mclk_info->num_fs_rates;
+		size = sizeof(*mclk->fs_rates) * mclk->num_fs_rates;
+		mclk->fs_rates = devm_kzalloc(pbc->card.dev, size,
+							GFP_KERNEL);
+		if (!mclk->fs_rates) {
+			ret = -ENOMEM;
+			goto err_codec_info;
+		}
+		memcpy(mclk->fs_rates, i2s_mclk_info->fs_rates, size);
+		mclk = &i2s->mclk_b;
+	}
+
+	if (dac_mclk_info->num_fs_rates) {
+		mclk->mclk = &pbc->dac_mclk;
+		mclk->num_fs_rates = dac_mclk_info->num_fs_rates;
+		size = sizeof(*mclk->fs_rates) * mclk->num_fs_rates;
+		mclk->fs_rates = devm_kzalloc(pbc->card.dev, size,
+							GFP_KERNEL);
+		if (!mclk->fs_rates) {
+			ret = -ENOMEM;
+			goto err_codec_info;
+		}
+		memcpy(mclk->fs_rates, dac_mclk_info->fs_rates, size);
+	}
 
-	pbc->i2s_out_cpu_fmt &= ~SND_SOC_DAIFMT_MASTER_MASK;
-	if (i2s_out_master && (i2s_out_master == link->cpu_of_node)) {
-		pbc->i2s_out_master = PISTACHIO_CPU_I2S_OUT;
-		pbc->i2s_out_cpu_fmt |= SND_SOC_DAIFMT_CBS_CFS;
-		found = true;
-	} else {
-		pbc->i2s_out_cpu_fmt |= SND_SOC_DAIFMT_CBM_CFM;
+	if (!i2s->num_codecs) {
+		link->codec_dai_name = "snd-soc-dummy-dai";
+		link->codec_name = "snd-soc-dummy";
+		return 0;
 	}
 
-	codec =  &pbc->codecs[PISTACHIO_CODEC_PCM3060_DAC];
-	codec->fmt &= ~SND_SOC_DAIFMT_MASTER_MASK;
-	if (i2s_out_master && (i2s_out_master == codec->np)) {
-		pbc->i2s_out_master = PISTACHIO_CODEC_PCM3060_DAC;
-		codec->fmt |= SND_SOC_DAIFMT_CBM_CFM;
-		found = true;
-	} else {
-		codec->fmt |= SND_SOC_DAIFMT_CBS_CFS;
+	i2s->codecs = devm_kzalloc(pbc->card.dev,
+		sizeof(*i2s->codecs) * i2s->num_codecs, GFP_KERNEL);
+	if (!i2s->codecs) {
+		ret = -ENOMEM;
+		goto err_codec_info;
 	}
 
-	codec =  &pbc->codecs[PISTACHIO_CODEC_PCM3168A_1_DAC];
-	codec->fmt &= ~SND_SOC_DAIFMT_MASTER_MASK;
-	if (i2s_out_master && (i2s_out_master == codec->np)) {
-		pbc->i2s_out_master = PISTACHIO_CODEC_PCM3168A_1_DAC;
-		codec->fmt |= SND_SOC_DAIFMT_CBM_CFM;
-		found = true;
-	} else {
-		codec->fmt |= SND_SOC_DAIFMT_CBS_CFS;
+	for (i = 0; i < i2s->num_codecs; i++) {
+		i2s->codecs[i].mclk = codecs[i].mclk;
+		i2s->codecs[i].mclk_index = codecs[i].mclk_index;
 	}
 
-	codec =  &pbc->codecs[PISTACHIO_CODEC_PCM3168A_2_DAC];
-	codec->fmt &= ~SND_SOC_DAIFMT_MASTER_MASK;
-	if (i2s_out_master && (i2s_out_master == codec->np)) {
-		pbc->i2s_out_master = PISTACHIO_CODEC_PCM3168A_2_DAC;
-		codec->fmt |= SND_SOC_DAIFMT_CBM_CFM;
-		found = true;
-	} else {
-		codec->fmt |= SND_SOC_DAIFMT_CBS_CFS;
+	i2s->components = devm_kzalloc(pbc->card.dev,
+		sizeof(*i2s->components) * i2s->num_codecs, GFP_KERNEL);
+	if (!i2s->components) {
+		ret = -ENOMEM;
+		goto err_codec_info;
 	}
 
-	if (!found)
-		pbc->i2s_out_master = PISTACHIO_FRAME_EXTERNAL;
+	for (i = 0; i < i2s->num_codecs; i++) {
+		i2s->components[i].dai_name = codecs[i].dai_name;
+		i2s->components[i].of_node = codecs[i].np;
+	}
+
+	link->codecs = i2s->components;
+	link->num_codecs = i2s->num_codecs;
 
 	return 0;
+
+err_codec_info:
+	for (i = 0; i < i2s->num_codecs; i++)
+		of_node_put(codecs[i].np);
+
+	return ret;
 }
 
-static int pistachio_card_i2s_out_link_init(struct snd_soc_pcm_runtime *rtd)
+static int pistachio_card_parse_of_i2s(struct device_node *i2s_out_np,
+	struct device_node *i2s_in_np, struct pistachio_card *pbc,
+	struct snd_soc_dai_link *links,
+	struct pistachio_i2s_codec_info *codec_info,
+	bool i2s_loopback)
 {
-	struct pistachio_card_data *pbc = snd_soc_card_get_drvdata(rtd->card);
-	struct snd_soc_dai *codec, *cpu = rtd->cpu_dai;
-	int ret, i, j;
-	unsigned long sysclk;
+	int ret;
+	struct device *dev = pbc->card.dev;
+	unsigned int fmt;
+	struct device_node *np;
+	struct pistachio_i2s_mclk_fs_info i2s_mclk_info, dac_mclk_info;
 
-	ret = snd_soc_dai_set_fmt(cpu, pbc->i2s_out_cpu_fmt);
-	if (ret)
-		return ret;
+	pbc->i2s_mclk.max_rate = PISTACHIO_I2S_MCLK_MAX_FREQ;
+	pbc->dac_mclk.max_rate = PISTACHIO_DAC_MCLK_MAX_FREQ;
 
-	for (i = 0; i < rtd->num_codecs; i++) {
-		codec = rtd->codec_dais[i];
-		j = pistachio_card_find_codec_i2s(pbc, codec, true);
-		if (j < 0)
-			continue;
-		pbc->codecs[j].dai = codec;
-		ret = snd_soc_dai_set_fmt(codec, pbc->codecs[j].fmt);
-		if (ret)
-			return ret;
+	codec_info->bitclock_master_idx = -1;
+	codec_info->frame_master_idx = -1;
 
-		if (pbc->mclk_source == PISTACHIO_MCLK_DAC_CLK)
-			sysclk = pbc->dac_clk_rate;
-		else
-			sysclk = pbc->i2s_mclk_rate;
+	if (i2s_out_np) {
+		pbc->i2s_out = devm_kzalloc(dev, sizeof(*pbc->i2s_out),
+						GFP_KERNEL);
+		if (!pbc->i2s_out)
+			return -ENOMEM;
+
+		pbc->i2s_out->output.start_at.enable =
+				PISTACHIO_EVT_ENABLE_I2S_OUT;
+		pbc->i2s_out->output.start_at.dummy_frames = 1;
+		spin_lock_init(&pbc->i2s_out->output.start_at.lock);
+
+		links->name = links->stream_name = "pistachio-i2s-out";
+
+		np = of_parse_phandle(i2s_out_np, "cpu-dai", 0);
+		if (!np)
+			return -EINVAL;
 
-		ret = snd_soc_dai_set_sysclk(codec, 0, sysclk, 0);
+		links->cpu_of_node = np;
+		links->platform_of_node = np;
+
+		fmt = snd_soc_of_parse_daifmt(i2s_out_np, NULL, NULL, NULL);
+		fmt &= ~SND_SOC_DAIFMT_MASTER_MASK;
+		fmt |= SND_SOC_DAIFMT_CBS_CFS;
+		links->dai_fmt = fmt;
+
+		/*
+		 * Internal i2s out controller uses i2s_mclk and
+		 * accepts 256fs,384fs
+		 */
+		i2s_mclk_info.fs_rates[0] = 256;
+		i2s_mclk_info.fs_rates[1] = 384;
+		i2s_mclk_info.num_fs_rates = 2;
+		dac_mclk_info.num_fs_rates = 0;
+
+		ret = pistachio_card_parse_of_i2s_common(i2s_out_np, pbc,
+				&pbc->i2s_out->i2s, links, codec_info,
+				&i2s_mclk_info, &dac_mclk_info);
 		if (ret)
 			return ret;
+
+		links->init = pistachio_card_i2s_out_link_init;
+		links->ops = &pistachio_card_i2s_out_ops;
+
+		links++;
 	}
 
-	return 0;
-}
+	if (i2s_in_np) {
+		pbc->i2s_in = devm_kzalloc(dev, sizeof(*pbc->i2s_in),
+						GFP_KERNEL);
+		if (!pbc->i2s_in)
+			return -ENOMEM;
 
-static int pistachio_card_i2s_out_startup(struct snd_pcm_substream *st)
-{
-	struct snd_soc_pcm_runtime *rtd = st->private_data;
-	struct pistachio_card_data *pbc = snd_soc_card_get_drvdata(rtd->card);
-	unsigned long flags;
+		links->name = links->stream_name = "pistachio-i2s-in";
 
-	spin_lock_irqsave(&pbc->i2s_out_lock, flags);
-	pbc->i2s_out_active_rate = 0;
-	spin_unlock_irqrestore(&pbc->i2s_out_lock, flags);
+		np = of_parse_phandle(i2s_in_np, "cpu-dai", 0);
+		if (!np)
+			return -EINVAL;
 
-	return 0;
-}
+		links->cpu_of_node = np;
+		links->platform_of_node = np;
 
-static void pistachio_card_i2s_out_shutdown(struct snd_pcm_substream *st)
-{
-	struct snd_soc_pcm_runtime *rtd = st->private_data;
-	struct pistachio_card_data *pbc = snd_soc_card_get_drvdata(rtd->card);
-	unsigned long flags;
+		fmt = snd_soc_of_parse_daifmt(i2s_in_np, NULL, NULL, NULL);
+		fmt &= ~SND_SOC_DAIFMT_MASTER_MASK;
+		pbc->i2s_in->fmt = fmt;
 
-	spin_lock_irqsave(&pbc->i2s_out_lock, flags);
-	pbc->i2s_out_active_rate = 0;
-	spin_unlock_irqrestore(&pbc->i2s_out_lock, flags);
-}
+		i2s_mclk_info.num_fs_rates = 0;
+		dac_mclk_info.num_fs_rates = 0;
 
-static int pistachio_card_i2s_out_hw_params(struct snd_pcm_substream *st,
-				struct snd_pcm_hw_params *params)
-{
-	struct snd_soc_pcm_runtime *rtd = st->private_data;
-	struct pistachio_card_data *pbc = snd_soc_card_get_drvdata(rtd->card);
-	unsigned int rate;
+		ret = pistachio_card_parse_of_i2s_common(i2s_in_np, pbc,
+				&pbc->i2s_in->i2s, links, codec_info,
+				&i2s_mclk_info, &dac_mclk_info);
+		if (ret)
+			return ret;
+
+		if (i2s_loopback) {
+			pbc->i2s_in->frame_master =
+					PISTACHIO_CLOCK_MASTER_LOOPBACK;
+			pbc->i2s_in->bitclock_master =
+					PISTACHIO_CLOCK_MASTER_LOOPBACK;
+		} else if ((codec_info->bitclock_master_idx == -1) ||
+				(codec_info->frame_master_idx == -1)) {
+			pbc->i2s_in->frame_master =
+					PISTACHIO_CLOCK_MASTER_EXT;
+			pbc->i2s_in->bitclock_master =
+					PISTACHIO_CLOCK_MASTER_EXT;
+		} else {
+			pbc->i2s_in->frame_master =
+					codec_info->frame_master_idx;
+			pbc->i2s_in->bitclock_master =
+					codec_info->bitclock_master_idx;
+		}
+
+		links->init = pistachio_card_i2s_in_link_init;
 
-	rate = params_rate(params);
-	pbc->i2s_out_active_rate = rate;
+		/*
+		 * If no mclks are used by i2s in, there is nothing for
+		 * the ops callbacks to do, so leave this as NULL
+		 */
+		if (pbc->i2s_in->i2s.mclk_a.mclk)
+			links->ops = &pistachio_card_i2s_in_ops;
+	}
 
-	return pistachio_card_i2s_hw_params(pbc, rate, true);
+	return 0;
 }
 
-static void pistachio_card_i2s_out_start_cb(void *context)
+static int pistachio_card_parse_of_confs(struct pistachio_card *pbc,
+			struct pistachio_i2s_codec_info *codec_info,
+			struct snd_soc_dai_link *parallel_out)
 {
-	struct pistachio_card_data *pbc;
-	unsigned long flags;
-	struct snd_pcm_substream *st;
-	//int ret;
+	int i, j, n;
+	unsigned int size;
+	struct pistachio_i2s_codec_info_s *codecs;
+	struct snd_soc_codec_conf *conf, *c;
+
+	n = codec_info->unique_codecs;
+	if (parallel_out)
+		n++;
+	codecs = codec_info->codecs;
+
+	size = sizeof(*pbc->card.codec_conf) * n;
+	pbc->card.codec_conf = devm_kzalloc(pbc->card.dev, size, GFP_KERNEL);
+	if (!pbc->card.codec_conf)
+		return -ENOMEM;
 
-	pbc = (struct pistachio_card_data *)context;
+	conf = pbc->card.codec_conf;
 
-	spin_lock_irqsave(&pbc->i2s_out_lock, flags);
+	for (i = 0; i < codec_info->total_codecs; i++) {
+		for (j = 0; j < i; j++)
+			if (codecs[j].np == codecs[i].np)
+				break;
+		if (j == i) {
+			conf->of_node = codecs[i].np;
+			conf->name_prefix = codecs[i].prefix;
+			conf++;
+		}
+	}
 
-	st = pbc->i2s_out_start_at_substream;
-
-	if (!st) {
-		spin_unlock_irqrestore(&pbc->i2s_out_lock, flags);
-		return;
+	if (parallel_out) {
+		conf->of_node = parallel_out->codecs[0].of_node;
+		conf->name_prefix = PISTACHIO_INTERNAL_DAC_PREFIX;
 	}
 
-	snd_pcm_stream_lock(st);
-
-	snd_pcm_startat_unregister(st);
-
-	if(!snd_pcm_do_start(st, SNDRV_PCM_STATE_RUNNING))
-		snd_pcm_post_start(st, SNDRV_PCM_STATE_RUNNING);
+	pbc->card.num_configs = n;
 
-	snd_pcm_stream_unlock(st);
-
-	_pistachio_evt_disable_event(pbc->event_timer,
-			PISTACHIO_EVT_ENABLE_I2S_OUT);
-
-	pbc->i2s_out_start_at_substream = NULL;
+	for (i = 0; i < n; i++) {
+		conf = &pbc->card.codec_conf[i];
+		for (j = i + 1; j < n; j++) {
+			c = &pbc->card.codec_conf[j];
+			if (!strcasecmp(conf->name_prefix, c->name_prefix)) {
+				dev_err(pbc->card.dev, "Prefix clash: %s\n",
+						conf->name_prefix);
+				return -EINVAL;
+			}
+		}
+	}
 
-	spin_unlock_irqrestore(&pbc->i2s_out_lock, flags);
+	return 0;
 }
 
-static int pistachio_card_i2s_out_start_at(struct snd_pcm_substream *st,
-		int clock_type, const struct timespec *ts)
+static int pistachio_card_parse_of(struct device_node *node,
+				struct pistachio_card *pbc)
 {
-	struct snd_soc_pcm_runtime *rtd = st->private_data;
-	struct pistachio_card_data *pbc = snd_soc_card_get_drvdata(rtd->card);
-	int ret;
-	unsigned long flags;
-	struct timespec ts_modified = *ts;
-	struct timespec ts_sub;
+	int ret = 0;
+	struct device_node *spdif_out_np, *spdif_in_np, *parallel_out_np;
+	struct device_node *i2s_out_np, *i2s_in_np, *event_np;
+	struct snd_soc_dai_link *link, *prl_out = NULL;
+	enum of_gpio_flags flags;
+	struct pistachio_i2s_codec_info i2s_codec_info;
+	bool i2s_loopback;
+
+	pbc->periph_regs = syscon_regmap_lookup_by_phandle(node,
+						"img,cr-periph");
+	if (IS_ERR(pbc->periph_regs))
+		return PTR_ERR(pbc->periph_regs);
 
-	printk("### pistachio_card_i2s_out_start_at\n");
+	event_np = of_parse_phandle(node, "img,event-timer", 0);
+	if (!event_np)
+		return -EINVAL;
+	pbc->event_timer_np = event_np;
+	pbc->event_timer = pistachio_evt_get(event_np);
+	if (IS_ERR(pbc->event_timer))
+		return PTR_ERR(pbc->event_timer);
 
-	ret = snd_pcm_pre_start(st, SNDRV_PCM_STATE_PREPARED);
-	if (ret)
-		return ret;
+	if (of_property_read_bool(node, "img,widgets")) {
+		ret = snd_soc_of_parse_audio_simple_widgets(&pbc->card,
+					"img,widgets");
+		if (ret)
+			return ret;
+	}
 
-	printk("### pistachio_card_i2s_out_start_at 2\n");
+	if (of_property_read_bool(node, "img,routing")) {
+		ret = snd_soc_of_parse_audio_routing(&pbc->card,
+					"img,routing");
+		if (ret)
+			return ret;
+	}
 
-	spin_lock_irqsave(&pbc->i2s_out_lock, flags);
+	spdif_out_np = of_get_child_by_name(node, "spdif-out");
+	if (spdif_out_np)
+		pbc->card.num_links++;
 
-	/*
-	 * I2S outputs zero samples for the first frame. The first sample
-	 * of audio data from the application is then used in the second
-	 * frame. Subtract a frame from the start time to ensure start_at
-	 * has the same meaning for all interfaces
-	 */
-	ts_sub.tv_sec = 0;
-	ts_sub.tv_nsec = DIV_ROUND_CLOSEST(1000000000,
-			pbc->i2s_out_active_rate);
-	ts_modified = timespec_sub(ts_modified, ts_sub);
-
-	ret = pistachio_evt_set_event(pbc->event_timer,
-		PISTACHIO_EVT_ENABLE_I2S_OUT,
-		PISTACHIO_EVT_TYPE_LEVEL, &ts_modified,
-		pistachio_card_i2s_out_start_cb, pbc);
-	if (ret) {
-		spin_unlock_irqrestore(&pbc->i2s_out_lock, flags);
-		return ret;
-	}
+	spdif_in_np = of_get_child_by_name(node, "spdif-in");
+	if (spdif_in_np)
+		pbc->card.num_links++;
 
-	printk("### pistachio_card_i2s_out_start_at 3\n");
+	parallel_out_np = of_get_child_by_name(node, "parallel-out");
+	if (parallel_out_np)
+		pbc->card.num_links++;
 
-	snd_pcm_startat_register(st, SNDRV_PCM_CLOCK_CLASS_AUDIO,
-		clock_type, ts, NULL);
+	i2s_out_np = of_get_child_by_name(node, "i2s-out");
+	if (i2s_out_np)
+		pbc->card.num_links++;
 
-	pbc->i2s_out_start_at_substream = st;
+	i2s_in_np = of_get_child_by_name(node, "i2s-in");
+	if (i2s_in_np)
+		pbc->card.num_links++;
 
-	spin_unlock_irqrestore(&pbc->i2s_out_lock, flags);
+	i2s_loopback = of_property_read_bool(node, "img,i2s-clk-loopback");
+	if (i2s_loopback && (!i2s_out_np || !i2s_in_np)) {
+		ret = -EINVAL;
+		goto end;
+	}
 
-	return 0;
-}
+	if (!pbc->card.num_links) {
+		ret = -EINVAL;
+		goto end;
+	}
 
-static int pistachio_card_i2s_out_start_at_abort(
-		struct snd_pcm_substream *st)
-{
-	struct snd_soc_pcm_runtime *rtd = st->private_data;
-	struct pistachio_card_data *pbc = snd_soc_card_get_drvdata(rtd->card);
-	unsigned long flags;
+	pbc->card.dai_link = devm_kzalloc(pbc->card.dev,
+		sizeof(*pbc->card.dai_link) * pbc->card.num_links, GFP_KERNEL);
+	if (!pbc->card.dai_link) {
+		ret = -ENOMEM;
+		goto end;
+	}
 
-	spin_lock_irqsave(&pbc->i2s_out_lock, flags);
+	i2s_codec_info.total_codecs = 0;
+	i2s_codec_info.unique_codecs = 0;
 
-	if (!pbc->i2s_out_start_at_substream) {
-		/* Already started */
-		spin_unlock_irqrestore(&pbc->i2s_out_lock, flags);
-		return -EINVAL;
+	link = pbc->card.dai_link;
+
+	if (spdif_out_np) {
+		ret = pistachio_card_parse_of_spdif_out(spdif_out_np, pbc,
+							link);
+		if (ret)
+			goto end;
+		link++;
 	}
 
-	snd_pcm_startat_unregister(st);
+	if (spdif_in_np) {
+		ret = pistachio_card_parse_of_spdif_in(spdif_in_np, pbc,
+							link);
+		if (ret)
+			goto end;
+		link++;
+	}
 
-	pbc->i2s_out_start_at_substream = NULL;
+	if (parallel_out_np) {
+		ret = pistachio_card_parse_of_parallel_out(parallel_out_np,
+								pbc, link);
+		if (ret)
+			goto end;
+		prl_out = link;
+		link++;
+	}
 
-	spin_unlock_irqrestore(&pbc->i2s_out_lock, flags);
+	if (i2s_out_np || i2s_in_np) {
+		ret = pistachio_card_parse_of_i2s(i2s_out_np, i2s_in_np, pbc,
+					link, &i2s_codec_info, i2s_loopback);
+		if (ret)
+			goto end;
+	}
 
-	pistachio_evt_disable_event(pbc->event_timer,
-		PISTACHIO_EVT_ENABLE_I2S_OUT);
+	ret = pistachio_card_parse_of_confs(pbc, &i2s_codec_info, prl_out);
+	if (ret)
+		goto end;
+
+	pbc->hp_jack_gpio.gpio = of_get_named_gpio_flags(node,
+					"img,hp-det-gpio", 0, &flags);
+	pbc->hp_jack_gpio.invert = !!(flags & OF_GPIO_ACTIVE_LOW);
+	if (pbc->hp_jack_gpio.gpio == -EPROBE_DEFER) {
+		ret = -EPROBE_DEFER;
+		goto end;
+	}
+
+	pbc->mute_gpio = of_get_named_gpio_flags(node, "img,mute-gpio", 0,
+						&flags);
+	pbc->mute_gpio_inverted = !!(flags & OF_GPIO_ACTIVE_LOW);
+	if (pbc->mute_gpio_inverted == -EPROBE_DEFER) {
+		ret = -EPROBE_DEFER;
+		goto end;
+	}
+
+end:
+	if (spdif_out_np)
+		of_node_put(spdif_out_np);
+	if (spdif_in_np)
+		of_node_put(spdif_in_np);
+	if (parallel_out_np)
+		of_node_put(parallel_out_np);
+	if (i2s_out_np)
+		of_node_put(i2s_out_np);
+	if (i2s_in_np)
+		of_node_put(i2s_in_np);
 
-	return 0;
+	return ret;
 }
 
-static struct snd_soc_ops pistachio_card_i2s_out_ops = {
-	.startup = pistachio_card_i2s_out_startup,
-	.shutdown = pistachio_card_i2s_out_shutdown,
-	.hw_params = pistachio_card_i2s_out_hw_params,
-	.start_at = pistachio_card_i2s_out_start_at,
-	.start_at_abort = pistachio_card_i2s_out_start_at_abort
-};
-
-static int pistachio_card_parse_of_i2s_out(struct device_node *node,
-		struct pistachio_card_data *pbc, struct snd_soc_dai_link *link,
-		struct snd_soc_dai_link_component *components,
-		struct device_node **i2s_out_master)
+static void pistachio_card_unref(struct pistachio_card *pbc)
 {
-	struct device_node *np;
-	unsigned int fmt;
-	struct device *dev = pbc->card.dev;
+	int i, j;
+	struct snd_soc_dai_link *link;
 
-	link->name = link->stream_name = "pistachio-i2s-out";
-	np = of_parse_phandle(node, "cpu-dai", 0);
-	if (!np)
-		return -EINVAL;
-	link->cpu_of_node = np;
-	link->platform_of_node = np;
-	fmt = snd_soc_of_parse_daifmt(node, "cpu-", NULL, NULL);
-	pbc->i2s_out_cpu_fmt = fmt;
-	link->codecs = components;
-	np = of_parse_phandle(node, "pcm3060", 0);
-	if (np) {
-		if (pbc->db != PISTACHIO_DAUGHTERBOARD_NONE) {
-			of_node_put(np);
-			dev_err(dev, "pcm3060 is available only when no daughterboard is present");
-			return -EINVAL;
-		}
-		pbc->codecs[PISTACHIO_CODEC_PCM3060_DAC].np = np;
-		link->codecs[link->num_codecs].dai_name = "pcm3060-dac";
-		link->codecs[link->num_codecs++].of_node = np;
-		fmt = snd_soc_of_parse_daifmt(node, "pcm3060-", NULL, NULL);
-		pbc->codecs[PISTACHIO_CODEC_PCM3060_DAC].fmt = fmt;
-	}
-	np = of_parse_phandle(node, "pcm3168a-1", 0);
-	if (np) {
-		if (pbc->db != PISTACHIO_DAUGHTERBOARD_CODEC) {
-			of_node_put(np);
-			dev_err(dev, "pcm3168a-1 is available only when codec daughterboard is present");
-			return -EINVAL;
-		}
-		pbc->codecs[PISTACHIO_CODEC_PCM3168A_1_DAC].np = np;
-		link->codecs[link->num_codecs].dai_name = "pcm3168a-dac";
-		link->codecs[link->num_codecs++].of_node = np;
-		fmt = snd_soc_of_parse_daifmt(node, "pcm3168a-1-", NULL, NULL);
-		pbc->codecs[PISTACHIO_CODEC_PCM3168A_1_DAC].fmt = fmt;
-	}
-	np = of_parse_phandle(node, "pcm3168a-2", 0);
-	if (np) {
-		if (pbc->db != PISTACHIO_DAUGHTERBOARD_CODEC) {
-			of_node_put(np);
-			dev_err(dev, "pcm3168a-2 is available only when codec daughterboard is present");
-			return -EINVAL;
-		}
-		pbc->codecs[PISTACHIO_CODEC_PCM3168A_2_DAC].np = np;
-		link->codecs[link->num_codecs].dai_name = "pcm3168a-dac";
-		link->codecs[link->num_codecs++].of_node = np;
-		fmt = snd_soc_of_parse_daifmt(node, "pcm3168a-2-", NULL, NULL);
-		pbc->codecs[PISTACHIO_CODEC_PCM3168A_2_DAC].fmt = fmt;
-	}
-	if (!link->num_codecs) {
-		link->codec_dai_name = "snd-soc-dummy-dai";
-		link->codec_name = "snd-soc-dummy";
-		link->codecs = NULL;
-	}
-	link->init = pistachio_card_i2s_out_link_init;
-	link->ops = &pistachio_card_i2s_out_ops;
+	if (pbc->event_timer_np)
+		of_node_put(pbc->event_timer_np);
 
-	*i2s_out_master = of_parse_phandle(node, "clock-master", 0);
+	link = pbc->card.dai_link;
+	if (!link)
+		return;
 
-	return link->num_codecs;
+	for (i = 0; i < pbc->card.num_links; i++, link++) {
+		if (link->cpu_of_node)
+			of_node_put(link->cpu_of_node);
+		for (j = 0; j < link->num_codecs; j++)
+			of_node_put(link->codecs[j].of_node);
+	}
 }
 
-#define PISTACHIO_I2S_LOOPBACK_REG		0x88
-#define PISTACHIO_I2S_LOOPBACK_DATA_MASK	0x4
-#define PISTACHIO_I2S_LOOPBACK_CLK_MASK		0x3
-#define PISTACHIO_I2S_LOOPBACK_CLK_SHIFT	0
+static int pistachio_card_init_clk(struct device *dev, char *name,
+					struct clk **pclk)
+{
+	struct clk *clk;
+	int ret;
 
-#define PISTACHIO_I2S_LOOPBACK_CLK_NONE		0
-#define PISTACHIO_I2S_LOOPBACK_CLK_MFIO		1
-#define PISTACHIO_I2S_LOOPBACK_CLK_LOCAL	2
+	clk = devm_clk_get(dev, name);
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
 
-static int pistachio_card_get_i2s_in_master(struct pistachio_card_data *pbc,
-					struct device_node *i2s_in_master)
-{
-	struct pistachio_codec *codec;
-	struct snd_soc_dai_link *link = pbc->dai_links[PISTACHIO_LINK_I2S_IN];
-	bool found = false;
-	u32 loopback_val;
+	ret = clk_prepare_enable(clk);
+	if (ret)
+		return ret;
 
-	if (!link)
-		return 0;
+	*pclk = clk;
 
-	if (IS_ERR(i2s_in_master))
-		return PTR_ERR(i2s_in_master);
+	return 0;
+}
 
-	link = pbc->dai_links[PISTACHIO_LINK_I2S_OUT];
+static int pistachio_card_init_rates(struct pistachio_card *pbc)
+{
+	unsigned int rate;
+	int ret;
 
-	pbc->i2s_in_cpu_fmt &= ~SND_SOC_DAIFMT_MASTER_MASK;
-	pbc->i2s_in_cpu_fmt |= SND_SOC_DAIFMT_CBM_CFM;
-	if (link && i2s_in_master && (i2s_in_master == link->cpu_of_node)) {
-		if (pbc->i2s_out_master != PISTACHIO_CPU_I2S_OUT) {
-			dev_err(pbc->card.dev, "Invalid i2s master config");
-			return -EINVAL;
-		}
-		pbc->i2s_in_master = PISTACHIO_CPU_I2S_OUT;
-		found = true;
-	}
+	rate = PLL_RATE_11025_22050_44100_64000_88200_176400;
+	ret = clk_set_rate(pbc->audio_pll, rate);
+	if (ret)
+		return ret;
+	pbc->audio_pll_rate = rate;
 
-	codec =  &pbc->codecs[PISTACHIO_CODEC_PCM3060_ADC];
-	codec->fmt &= ~SND_SOC_DAIFMT_MASTER_MASK;
-	if (i2s_in_master && (i2s_in_master == codec->np)) {
-		pbc->i2s_in_master = PISTACHIO_CODEC_PCM3060_ADC;
-		codec->fmt |= SND_SOC_DAIFMT_CBM_CFM;
-		found = true;
-	} else {
-		codec->fmt |= SND_SOC_DAIFMT_CBS_CFS;
-	}
+	rate = PISTACHIO_MIN_MCLK_FREQ;
+	ret = clk_set_rate(pbc->i2s_mclk.mclk, rate);
+	if (ret)
+		return ret;
+	pbc->i2s_mclk.cur_rate = rate;
+	ret = clk_set_rate(pbc->dac_mclk.mclk, rate);
+	if (ret)
+		return ret;
+	pbc->dac_mclk.cur_rate = rate;
 
-	codec =  &pbc->codecs[PISTACHIO_CODEC_PCM3168A_1_ADC];
-	codec->fmt &= ~SND_SOC_DAIFMT_MASTER_MASK;
-	if (i2s_in_master && (i2s_in_master == codec->np)) {
-		pbc->i2s_in_master = PISTACHIO_CODEC_PCM3168A_1_ADC;
-		codec->fmt |= SND_SOC_DAIFMT_CBM_CFM;
-		found = true;
-	} else {
-		codec->fmt |= SND_SOC_DAIFMT_CBS_CFS;
-	}
+	return 0;
+}
 
-	codec =  &pbc->codecs[PISTACHIO_CODEC_PCM3168A_2_ADC];
-	codec->fmt &= ~SND_SOC_DAIFMT_MASTER_MASK;
-	if (i2s_in_master && (i2s_in_master == codec->np)) {
-		pbc->i2s_in_master = PISTACHIO_CODEC_PCM3168A_2_ADC;
-		codec->fmt |= SND_SOC_DAIFMT_CBM_CFM;
-		found = true;
-	} else {
-		codec->fmt |= SND_SOC_DAIFMT_CBS_CFS;
-	}
+static int pistachio_card_info_timespec(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = LONG_MAX;
 
-	if (!found)
-		pbc->i2s_in_master = PISTACHIO_FRAME_EXTERNAL;
+	return 0;
+}
 
-	if (pbc->i2s_in_master == PISTACHIO_CPU_I2S_OUT)
-		loopback_val = PISTACHIO_I2S_LOOPBACK_CLK_LOCAL;
-	else
-		loopback_val = PISTACHIO_I2S_LOOPBACK_CLK_NONE;
+static int pistachio_card_get_event_time(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *uc)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
+	struct timespec ts;
 
-	loopback_val <<= PISTACHIO_I2S_LOOPBACK_CLK_SHIFT;
+	pistachio_evt_get_time_ts(pbc->event_timer, &ts);
 
-	regmap_update_bits(pbc->periph_regs, PISTACHIO_I2S_LOOPBACK_REG,
-		PISTACHIO_I2S_LOOPBACK_CLK_MASK, loopback_val);
+	uc->value.integer.value[0] = ts.tv_sec;
+	uc->value.integer.value[1] = ts.tv_nsec;
 
 	return 0;
 }
 
-static int pistachio_card_i2s_in_link_init(struct snd_soc_pcm_runtime *rtd)
+static int pistachio_card_info_source(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
 {
-	struct pistachio_card_data *pbc = snd_soc_card_get_drvdata(rtd->card);
-	struct snd_soc_dai *codec, *cpu = rtd->cpu_dai;
-	int ret, i, j;
-	unsigned int fmt;
-	unsigned long sysclk;
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = PISTACHIO_EVT_NUM_SOURCES - 1;
 
-	fmt = pbc->i2s_in_cpu_fmt;
-
-	if ((fmt & SND_SOC_DAIFMT_MASTER_MASK) == SND_SOC_DAIFMT_CBS_CFS) {
-		fmt = (fmt & ~SND_SOC_DAIFMT_MASTER_MASK) |
-			SND_SOC_DAIFMT_CBM_CFM;
-	}
-	ret = snd_soc_dai_set_fmt(cpu, fmt);
-	if (ret)
-		return ret;
+	return 0;
+}
 
-	for (i = 0; i < rtd->num_codecs; i++) {
-		codec = rtd->codec_dais[i];
-		j = pistachio_card_find_codec_i2s(pbc, codec, false);
-		if (j == -1)
-			continue;
-		pbc->codecs[j].dai = codec;
-		ret = snd_soc_dai_set_fmt(codec, pbc->codecs[j].fmt);
-		if (ret)
-			return ret;
+static int pistachio_card_set_source(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol,
+				  int id)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
 
-		if (pbc->mclk_source == PISTACHIO_MCLK_DAC_CLK)
-			sysclk = pbc->dac_clk_rate;
-		else
-			sysclk = pbc->i2s_mclk_rate;
+	return pistachio_evt_set_source(pbc->event_timer, id,
+		ucontrol->value.integer.value[0]);
+}
 
-		ret = snd_soc_dai_set_sysclk(codec, 0, sysclk, 0);
-		if (ret)
-			return ret;
-	}
+static int pistachio_card_set_source_a(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	return pistachio_card_set_source(kcontrol, ucontrol, 0);
+}
 
-	return 0;
+static int pistachio_card_set_source_b(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	return pistachio_card_set_source(kcontrol, ucontrol, 1);
 }
 
-static int pistachio_card_i2s_in_startup(struct snd_pcm_substream *st)
+static int pistachio_card_get_source(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol,
+				  int id)
 {
-	struct snd_soc_pcm_runtime *rtd = st->private_data;
-	struct pistachio_card_data *pbc = snd_soc_card_get_drvdata(rtd->card);
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
+	enum pistachio_evt_source source;
+	int ret;
 
-	pbc->i2s_in_active_rate = 0;
+	ret = pistachio_evt_get_source(pbc->event_timer, id, &source);
 
-	return 0;
+	if (!ret)
+		ucontrol->value.integer.value[0] = source;
+
+	return ret;
 }
 
-static void pistachio_card_i2s_in_shutdown(struct snd_pcm_substream *st)
+static int pistachio_card_get_source_a(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_pcm_runtime *rtd = st->private_data;
-	struct pistachio_card_data *pbc = snd_soc_card_get_drvdata(rtd->card);
-
-	pbc->i2s_in_active_rate = 0;
+	return pistachio_card_get_source(kcontrol, ucontrol, 0);
 }
 
-static int pistachio_card_i2s_in_hw_params(struct snd_pcm_substream *st,
-				struct snd_pcm_hw_params *params)
+static int pistachio_card_get_source_b(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_pcm_runtime *rtd = st->private_data;
-	struct pistachio_card_data *pbc = snd_soc_card_get_drvdata(rtd->card);
-	unsigned int rate;
+	return pistachio_card_get_source(kcontrol, ucontrol, 1);
+}
 
-	rate = params_rate(params);
-	pbc->i2s_in_active_rate = rate;
+void pistachio_card_sample_rate_notify(int id, void *context)
+{
+	struct pistachio_card *pbc = context;
 
-	return pistachio_card_i2s_hw_params(pbc, rate, false);
+	if (pbc->sample_rate_ids[id])
+		snd_ctl_notify(pbc->card.snd_card, SNDRV_CTL_EVENT_MASK_VALUE,
+				pbc->sample_rate_ids[id]);
 }
 
-static struct snd_soc_ops pistachio_card_i2s_in_ops = {
-	.startup = pistachio_card_i2s_in_startup,
-	.shutdown = pistachio_card_i2s_in_shutdown,
-	.hw_params = pistachio_card_i2s_in_hw_params
-};
-
-static int pistachio_card_parse_of_i2s_in(struct device_node *node,
-		struct pistachio_card_data *pbc, struct snd_soc_dai_link *link,
-		struct snd_soc_dai_link_component *components,
-		struct device_node **i2s_in_master)
+void pistachio_card_sample_rate_notify_a(void *context)
 {
-	struct device_node *np;
-	unsigned int fmt;
-	struct device *dev = pbc->card.dev;
+	pistachio_card_sample_rate_notify(0, context);
+}
 
-	link->name = link->stream_name = "pistachio-i2s-in";
-	np = of_parse_phandle(node, "cpu-dai", 0);
-	if (!np)
-		return -EINVAL;
-	link->cpu_of_node = np;
-	link->platform_of_node = np;
-	fmt = snd_soc_of_parse_daifmt(node, "cpu-", NULL, NULL);
-	pbc->i2s_in_cpu_fmt = fmt;
-	link->codecs = components;
-	np = of_parse_phandle(node, "pcm3060", 0);
-	if (np) {
-		if (pbc->db != PISTACHIO_DAUGHTERBOARD_NONE) {
-			of_node_put(np);
-			dev_err(dev, "pcm3060 is available only when no daughterboard is present");
-			return -EINVAL;
-		}
-		pbc->codecs[PISTACHIO_CODEC_PCM3060_ADC].np = np;
-		link->codecs[link->num_codecs].dai_name = "pcm3060-adc";
-		link->codecs[link->num_codecs++].of_node = np;
-		fmt = snd_soc_of_parse_daifmt(node, "pcm3060-", NULL, NULL);
-		pbc->codecs[PISTACHIO_CODEC_PCM3060_ADC].fmt = fmt;
-	}
-	np = of_parse_phandle(node, "pcm3168a-1", 0);
-	if (np) {
-		if (pbc->db != PISTACHIO_DAUGHTERBOARD_CODEC) {
-			of_node_put(np);
-			dev_err(dev, "pcm3168a-1 is available only when codec daughterboard is present");
-			return -EINVAL;
-		}
-		pbc->codecs[PISTACHIO_CODEC_PCM3168A_1_ADC].np = np;
-		link->codecs[link->num_codecs].dai_name = "pcm3168a-adc";
-		link->codecs[link->num_codecs++].of_node = np;
-		fmt = snd_soc_of_parse_daifmt(node, "pcm3168a-1-", NULL, NULL);
-		pbc->codecs[PISTACHIO_CODEC_PCM3168A_1_ADC].fmt = fmt;
-	}
-	np = of_parse_phandle(node, "pcm3168a-2", 0);
-	if (np) {
-		if (pbc->db != PISTACHIO_DAUGHTERBOARD_CODEC) {
-			of_node_put(np);
-			dev_err(dev, "pcm3168a-2 is available only when codec daughterboard is present");
-			return -EINVAL;
-		}
-		pbc->codecs[PISTACHIO_CODEC_PCM3168A_2_ADC].np = np;
-		link->codecs[link->num_codecs].dai_name = "pcm3168a-adc";
-		link->codecs[link->num_codecs++].of_node = np;
-		fmt = snd_soc_of_parse_daifmt(node, "pcm3168a-2-", NULL, NULL);
-		pbc->codecs[PISTACHIO_CODEC_PCM3168A_2_ADC].fmt = fmt;
-	}
-	if (!link->num_codecs) {
-		link->codec_dai_name = "snd-soc-dummy-dai";
-		link->codec_name = "snd-soc-dummy";
-		link->codecs = NULL;
-	}
-	link->init = pistachio_card_i2s_in_link_init;
-	link->ops = &pistachio_card_i2s_in_ops;
+void pistachio_card_sample_rate_notify_b(void *context)
+{
+	pistachio_card_sample_rate_notify(1, context);
+}
 
-	*i2s_in_master = of_parse_phandle(node, "clock-master", 0);
+void pistachio_card_phase_difference_notify(void *context)
+{
+	struct pistachio_card *pbc = context;
 
-	return link->num_codecs;
+	if (pbc->phase_difference_id)
+		snd_ctl_notify(pbc->card.snd_card, SNDRV_CTL_EVENT_MASK_VALUE,
+				pbc->phase_difference_id);
 }
 
-static int pistachio_card_parse_of(struct device_node *node,
-	struct pistachio_card_data *pbc, struct device_node **i2s_out_master,
-	struct device_node **i2s_in_master)
+static int pistachio_card_get_sample_period(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol,
+				  int id)
 {
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
 	int ret;
-	struct device_node *np;
-	struct snd_soc_dai_link *dai_link = pbc->dai_links_st;
-	struct snd_soc_dai_link_component *component = pbc->codec_st;
+	u32 val, freq, nsec;
+	u64 temp;
 
-	if (!node)
-		return -EINVAL;
+	pbc->sample_rate_ids[id] = &kcontrol->id;
 
-	pbc->card.name = "pistachio-card";
+	ret = pistachio_evt_get_sample_rate(pbc->event_timer, id, &val, &freq,
+				pistachio_card_sample_rate_notify_a, pbc);
 
-	/* The off-codec widgets */
-	if (of_property_read_bool(node, "widgets")) {
-		ret = snd_soc_of_parse_audio_simple_widgets(&pbc->card,
-					"widgets");
-		if (ret)
-			return ret;
+	if (!ret) {
+		temp = ((u64)val * NSEC_PER_SEC) + (freq / 2);
+		do_div(temp, freq);
+		nsec = do_div(temp, NSEC_PER_SEC);
+		ucontrol->value.integer.value[0] = temp;
+		ucontrol->value.integer.value[1] = nsec;
 	}
 
-	/* DAPM routes */
-	if (of_property_read_bool(node, "routing")) {
-		ret = snd_soc_of_parse_audio_routing(&pbc->card,
-					"routing");
-		if (ret)
-			return ret;
-	}
+	return ret;
+}
 
-	np = of_get_child_by_name(node, "spdif-out");
-	if (np) {
-		ret = pistachio_card_parse_of_spdif_out(np, pbc, dai_link);
-		if (ret)
-			return ret;
-		pbc->dai_links[PISTACHIO_LINK_SPDIF_OUT] = dai_link++;
-	}
+static int pistachio_card_get_sample_period_a(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	return pistachio_card_get_sample_period(kcontrol, ucontrol, 0);
+}
 
-	np = of_get_child_by_name(node, "spdif-in");
-	if (np) {
-		ret = pistachio_card_parse_of_spdif_in(np, pbc, dai_link);
-		if (ret)
-			return ret;
-		pbc->dai_links[PISTACHIO_LINK_SPDIF_IN] = dai_link++;
-	}
+static int pistachio_card_get_sample_period_b(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	return pistachio_card_get_sample_period(kcontrol, ucontrol, 1);
+}
 
-	np = of_get_child_by_name(node, "parallel-out");
-	if (np) {
-		ret = pistachio_card_parse_of_parallel_out(np, pbc,
-				dai_link, component);
-		if (ret < 0)
-			return ret;
-		pbc->dai_links[PISTACHIO_LINK_PRL_OUT] = dai_link++;
-		component += ret;
-	}
+static int pistachio_card_info_sample_rate(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = LONG_MAX;
 
-	np = of_get_child_by_name(node, "i2s-out");
-	if (np) {
-		ret = pistachio_card_parse_of_i2s_out(np, pbc,
-				dai_link, component, i2s_out_master);
-		if (ret < 0)
-			return ret;
-		pbc->dai_links[PISTACHIO_LINK_I2S_OUT] = dai_link++;
-		component += ret;
-	}
+	return 0;
+}
 
-	np = of_get_child_by_name(node, "i2s-in");
-	if (np) {
-		ret = pistachio_card_parse_of_i2s_in(np, pbc,
-				dai_link, component, i2s_in_master);
-		if (ret < 0)
-			return ret;
-		pbc->dai_links[PISTACHIO_LINK_I2S_IN] = dai_link++;
+static int pistachio_card_get_sample_rate(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol,
+				  int id)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
+	int ret;
+	u32 val, freq, rate;
+
+	pbc->sample_rate_ids[id] = &kcontrol->id;
+
+	ret = pistachio_evt_get_sample_rate(pbc->event_timer, id, &val, &freq,
+				pistachio_card_sample_rate_notify_b, pbc);
+
+	if (!ret) {
+		if (!val)
+			return -EINVAL;
+		rate = DIV_ROUND_CLOSEST(freq, val);
+		ucontrol->value.integer.value[0] = rate;
 	}
 
-	pbc->hp_jack_gpio.gpio = of_get_named_gpio(node,
-				"img,hp-det-gpio", 0);
-	if (pbc->hp_jack_gpio.gpio == -EPROBE_DEFER)
-		return -EPROBE_DEFER;
+	return ret;
+}
 
-	return dai_link - pbc->dai_links_st;
+static int pistachio_card_get_sample_rate_a(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	return pistachio_card_get_sample_rate(kcontrol, ucontrol, 0);
 }
 
-/* Decrease the reference count of the device nodes */
-static void pistachio_card_unref(struct platform_device *pdev,
-	struct device_node *i2s_out_master, struct device_node *i2s_in_master)
+static int pistachio_card_get_sample_rate_b(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_card *card = platform_get_drvdata(pdev);
-	struct snd_soc_dai_link *dai_link;
-	struct device_node *np;
-	const struct device_node *npc;
-	int i, j;
+	return pistachio_card_get_sample_rate(kcontrol, ucontrol, 1);
+}
 
-	dai_link = card->dai_link;
+static int pistachio_card_get_phase_difference(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
+	int ret;
+	u32 val, freq, nsec;
+	u64 temp;
 
-	for (i = 0; i < card->num_links; i++, dai_link++) {
+	pbc->phase_difference_id = &kcontrol->id;
 
-		np = (struct device_node *) dai_link->cpu_of_node;
-		if (np)
-			of_node_put(np);
+	ret = pistachio_evt_get_phase_difference(pbc->event_timer, &val,
+			&freq, pistachio_card_phase_difference_notify, pbc);
 
-		if (dai_link->codecs) {
-			for (j = 0; j < dai_link->num_codecs; j++) {
-				npc = dai_link->codecs[j].of_node;
-				np = (struct device_node *)npc;
-				if (np)
-					of_node_put(np);
-			}
-		}
+	if (!ret) {
+		temp = ((u64)val * NSEC_PER_SEC) + (freq / 2);
+		do_div(temp, freq);
+		nsec = do_div(temp, NSEC_PER_SEC);
+		ucontrol->value.integer.value[0] = temp;
+		ucontrol->value.integer.value[1] = nsec;
 	}
+
+	return ret;
 }
 
-static int pistachio_card_init_clk(struct device *dev, char *name,
-		struct clk **pclk, unsigned long *rate)
+static int pistachio_card_get_mute(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
 {
-	struct clk *clk;
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
 	int ret;
 
-	clk = devm_clk_get(dev, name);
-	if (IS_ERR(clk)) {
-		ret = PTR_ERR(clk);
+	ret = gpio_get_value_cansleep(pbc->mute_gpio);
+	if (ret < 0)
 		return ret;
-	}
+	else if (pbc->mute_gpio_inverted)
+		ucontrol->value.integer.value[0] = !ret;
+	else
+		ucontrol->value.integer.value[0] = !!ret;
 
-	ret = clk_prepare_enable(clk);
-	if (ret)
-		return ret;
+	return 0;
+}
 
-	*rate = clk_get_rate(clk);
+static int pistachio_card_set_mute(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
+	int val;
 
-	*pclk = clk;
+	if (pbc->mute_gpio_inverted)
+		val = !ucontrol->value.integer.value[0];
+	else
+		val = ucontrol->value.integer.value[0];
+
+	gpio_set_value_cansleep(pbc->mute_gpio, val);
 
 	return 0;
 }
 
-static int pistachio_card_info_event_time(struct snd_kcontrol *kcontrol,
+static int pistachio_card_info_sample_rates(struct snd_kcontrol *kcontrol,
 		struct snd_ctl_elem_info *uinfo)
 {
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER64;
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 2;
-	uinfo->value.integer64.min = 0;
-	uinfo->value.integer64.max = LLONG_MAX;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 192000;
 
 	return 0;
 }
 
-static int pistachio_card_get_event_time(struct snd_kcontrol *kcontrol,
-				  struct snd_ctl_elem_value *uc)
+static int pistachio_card_set_sample_rates_mclk(struct pistachio_card *pbc,
+		struct pistachio_mclk *mclk, unsigned int i2s_out_rate,
+		unsigned int i2s_in_rate)
+{
+	struct pistachio_i2s_mclk *mclk_a, *mclk_b;
+	unsigned int rate_a, rate_b;
+	int ret = 0;
+
+	mclk_a = NULL;
+	mclk_b = NULL;
+	rate_a = i2s_out_rate;
+	rate_b = i2s_in_rate;
+
+	if (i2s_out_rate) {
+		if (pbc->i2s_out->i2s.mclk_a.mclk == mclk)
+			mclk_a = &pbc->i2s_out->i2s.mclk_a;
+		else if (pbc->i2s_out->i2s.mclk_b.mclk == mclk)
+			mclk_a = &pbc->i2s_out->i2s.mclk_b;
+	}
+	if (i2s_in_rate) {
+		if (pbc->i2s_in->i2s.mclk_a.mclk == mclk)
+			mclk_b = &pbc->i2s_in->i2s.mclk_a;
+		else if (pbc->i2s_in->i2s.mclk_b.mclk == mclk)
+			mclk_b = &pbc->i2s_in->i2s.mclk_b;
+	}
+	if (!mclk_a) {
+		mclk_a = mclk_b;
+		rate_a = rate_b;
+		mclk_b = NULL;
+	}
+
+	if (mclk_a) {
+		ret = pistachio_card_update_mclk(pbc, mclk_a, mclk_b, rate_a,
+						rate_b);
+	}
+
+	return ret;
+}
+
+static int pistachio_card_set_sample_rates(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
-	struct pistachio_card_data *pbc = snd_soc_card_get_drvdata(card);
-	struct timespec ts;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
+	int ret;
+	unsigned int pll_rate, i2s_out_rate = 0, i2s_in_rate = 0;
 
-	pistachio_evt_read(pbc->event_timer, &ts);
+	if (pbc->i2s_out)
+		i2s_out_rate = ucontrol->value.integer.value[0];
+	if (pbc->i2s_in && pbc->i2s_in->i2s.mclk_a.mclk)
+		i2s_in_rate = ucontrol->value.integer.value[1];
 
-	uc->value.integer64.value[0] = ts.tv_sec;
-	uc->value.integer64.value[1] = ts.tv_nsec;
+	if (!i2s_out_rate && !i2s_in_rate)
+		return 0;
 
-	return 0;
+	pll_rate = 0;
+
+	if (i2s_out_rate) {
+		ret = pistachio_card_get_pll_rate(i2s_out_rate);
+		if (ret < 0)
+			return ret;
+		pll_rate = ret;
+	}
+
+	if (i2s_in_rate) {
+		ret = pistachio_card_get_pll_rate(i2s_in_rate);
+		if (ret < 0)
+			return ret;
+		if (pll_rate && (ret != pll_rate))
+			return -EINVAL;
+		pll_rate = ret;
+	}
+
+	mutex_lock(&pbc->rate_mutex);
+
+	if (pbc->audio_pll_rate != pll_rate) {
+		ret = pistachio_card_set_pll_rate(pbc, pll_rate);
+		if (ret) {
+			mutex_unlock(&pbc->rate_mutex);
+			return ret;
+		}
+	}
+
+	ret = pistachio_card_set_sample_rates_mclk(pbc, &pbc->i2s_mclk,
+						i2s_out_rate, i2s_in_rate);
+	if (ret) {
+		mutex_unlock(&pbc->rate_mutex);
+		return ret;
+	}
+
+	ret = pistachio_card_set_sample_rates_mclk(pbc, &pbc->dac_mclk,
+						i2s_out_rate, i2s_in_rate);
+
+	mutex_unlock(&pbc->rate_mutex);
+
+	return ret;
 }
 
-static struct snd_kcontrol_new pistachio_bub_controls[] = {
+static struct snd_kcontrol_new pistachio_controls[] = {
 	{
 		.access = SNDRV_CTL_ELEM_ACCESS_READ |
 			SNDRV_CTL_ELEM_ACCESS_VOLATILE,
 		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
 		.name = "Event Time",
-		.info = pistachio_card_info_event_time,
+		.info = pistachio_card_info_timespec,
 		.get = pistachio_card_get_event_time
 	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "Measurement Source A",
+		.info = pistachio_card_info_source,
+		.get = pistachio_card_get_source_a,
+		.put = pistachio_card_set_source_a
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "Measurement Source B",
+		.info = pistachio_card_info_source,
+		.get = pistachio_card_get_source_b,
+		.put = pistachio_card_set_source_b
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "Sample Rate A",
+		.info = pistachio_card_info_sample_rate,
+		.get = pistachio_card_get_sample_rate_a,
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "Sample Rate B",
+		.info = pistachio_card_info_sample_rate,
+		.get = pistachio_card_get_sample_rate_b,
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "Sample Period A",
+		.info = pistachio_card_info_timespec,
+		.get = pistachio_card_get_sample_period_a,
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "Sample Period B",
+		.info = pistachio_card_info_timespec,
+		.get = pistachio_card_get_sample_period_b,
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "Phase Difference",
+		.info = pistachio_card_info_timespec,
+		.get = pistachio_card_get_phase_difference,
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_WRITE,
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "I2S Rates",
+		.info = pistachio_card_info_sample_rates,
+		.put = pistachio_card_set_sample_rates
+	},
 };
 
-static int pistachio_card_probe(struct platform_device *pdev)
-{
-	struct pistachio_card_data *pbc;
-	struct device_node *np_event, *np = pdev->dev.of_node;
-	struct device *dev = &pdev->dev;
-	int ret;
-	struct device_node *i2s_out_master, *i2s_in_master, *codec_np;
-	struct snd_soc_codec_conf *codec_conf;
+#ifdef DEBUG
 
-	pbc = devm_kzalloc(dev, sizeof(*pbc), GFP_KERNEL);
-	if (!pbc)
-		return -ENOMEM;
+static void pistachio_card_info_mclk(struct pistachio_card *pbc,
+					struct pistachio_i2s_mclk *mclk)
+{
+	struct device *dev = pbc->card.dev;
+	int i;
 
-	pbc->card.owner = THIS_MODULE;
-	pbc->card.dev = dev;
+	dev_dbg(dev, "        Min Freq: %u\n", mclk->mclk->min_rate);
+	dev_dbg(dev, "        Max Freq: %u\n", mclk->mclk->max_rate);
+	dev_dbg(dev, "        FS Rates:\n");
 
-	spin_lock_init(&pbc->parallel_out_lock);
-	spin_lock_init(&pbc->spdif_out_lock);
-	spin_lock_init(&pbc->i2s_out_lock);
+	for (i = 0; i < mclk->num_fs_rates; i++)
+		dev_dbg(dev, "            %u\n", mclk->fs_rates[i]);
+}
 
-	pbc->hp_jack_gpio.gpio = -ENOENT;
+static void pistachio_card_info_mclks(struct pistachio_card *pbc,
+					struct pistachio_i2s *i2s)
+{
+	struct pistachio_i2s_mclk *i2s_mclk;
+	struct pistachio_i2s_mclk *dac_mclk;
+	struct device *dev = pbc->card.dev;
 
-	if (!np || !of_device_is_available(np))
-		return -EINVAL;
+	if (i2s->mclk_a.mclk == &pbc->i2s_mclk)
+		i2s_mclk = &i2s->mclk_a;
+	else if (pbc->i2s_in->i2s.mclk_b.mclk == &pbc->i2s_mclk)
+		i2s_mclk = &i2s->mclk_b;
+	else
+		i2s_mclk = NULL;
 
-	i2s_out_master = NULL;
-	i2s_in_master = NULL;
+	if (i2s_mclk) {
+		dev_dbg(dev, "    I2S MCLK\n");
+		pistachio_card_info_mclk(pbc, i2s_mclk);
+	} else {
+		dev_dbg(dev, "    I2S MCLK NOT USED\n");
+	}
 
-	ret = of_property_read_u32(np, "img,daughterboard", &pbc->db);
-	if (ret)
-		return ret;
-	if (pbc->db > PISTACHIO_DAUGHTERBOARD_MAX)
-		return -EINVAL;
+	dev_dbg(dev, "\n");
 
-	ret = of_property_read_u32(np, "img,mclk", &pbc->mclk_source);
-	if (ret)
-		return ret;
-	if (pbc->mclk_source > PISTACHIO_MCLK_MAX)
-		return -EINVAL;
+	if (i2s->mclk_a.mclk == &pbc->dac_mclk)
+		dac_mclk = &i2s->mclk_a;
+	else if (i2s->mclk_b.mclk == &pbc->dac_mclk)
+		dac_mclk = &i2s->mclk_b;
+	else
+		dac_mclk = NULL;
 
-	ret = of_property_read_u32(np, "img,mclk-max", &pbc->mclk_max);
-	if (ret) {
-		switch (pbc->db) {
-		case PISTACHIO_DAUGHTERBOARD_NONE:
-		case PISTACHIO_DAUGHTERBOARD_CODEC:
-			pbc->mclk_max = PCM1368A_PCM3060_MAX_MCLK;
-			break;
-		case PISTACHIO_DAUGHTERBOARD_BREAKOUT:
-			pbc->mclk_max = ULONG_MAX;
-			break;
-		default:
-			return -EINVAL;
-		};
+	if (dac_mclk) {
+		dev_dbg(dev, "    DAC MCLK\n");
+		pistachio_card_info_mclk(pbc, dac_mclk);
+	} else {
+		dev_dbg(dev, "    DAC MCLK NOT USED\n");
 	}
+}
 
-	pbc->periph_regs = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,
-							    "img,cr-periph");
-	if (IS_ERR(pbc->periph_regs))
-		return PTR_ERR(pbc->periph_regs);
+static void pistachio_card_info_i2s_out(struct pistachio_card *pbc,
+					struct snd_soc_dai_link *link)
+{
+	int i, j;
+	struct snd_soc_dai_link_component *components;
+	struct snd_soc_codec_conf *confs;
+	struct device *dev = pbc->card.dev;
+	char *text;
 
-	pbc->top_regs = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,
-							    "img,cr-top");
-	if (IS_ERR(pbc->top_regs))
-		return PTR_ERR(pbc->top_regs);
+	components = pbc->i2s_out->i2s.components;
+	confs = pbc->card.codec_conf;
 
-	np_event = of_parse_phandle(np, "img,event-timer", 0);
-	if (!np_event)
-		return -EINVAL;
-	pbc->event_timer = of_find_device_by_node(np_event);
-	if (!pbc->event_timer)
-		return -EPROBE_DEFER;
-
-	ret = pistachio_card_parse_of(np, pbc,
-			&i2s_out_master, &i2s_in_master);
-	if (ret < 0) {
-		if (ret != -EPROBE_DEFER)
-			dev_err(dev, "parse error %d\n", ret);
-		goto err;
-	}
+	dev_dbg(dev, "I2S OUT\n");
+	dev_dbg(dev, "\n");
+	if (pbc->i2s_in && (pbc->i2s_in->frame_master ==
+			PISTACHIO_CLOCK_MASTER_LOOPBACK))
+		text = "(Dual Frame + Bit Clock Master)";
+	else
+		text = "(Frame + Bit Clock Master)";
+	dev_dbg(dev, "    CPU DAI\n");
+	dev_dbg(dev, "        i2s-out (%s) %s\n",
+		link->cpu_of_node->name, text);
+	dev_dbg(dev, "\n");
+	dev_dbg(dev, "    CODECS\n");
+
+	for (i = 0; i < pbc->i2s_out->i2s.num_codecs; i++) {
+		for (j = 0; j < pbc->card.num_configs; j++)
+			if (confs[j].of_node == components[i].of_node)
+				break;
 
-	if (ret > 0) {
-		pbc->card.dai_link = pbc->dai_links_st;
-		pbc->card.num_links = ret;
+		dev_dbg(dev, "        %s (%s) (%s)\n", confs[j].name_prefix,
+			confs[j].of_node->name,
+			components[i].dai_name);
 	}
+	dev_dbg(dev, "\n");
 
-	ret = pistachio_card_get_i2s_out_master(pbc, i2s_out_master);
-	if (!ret)
-		ret = pistachio_card_get_i2s_in_master(pbc, i2s_in_master);
+	pistachio_card_info_mclks(pbc, &pbc->i2s_out->i2s);
 
-	if (!IS_ERR_OR_NULL(i2s_out_master))
-		of_node_put(i2s_out_master);
+	dev_dbg(dev, "\n");
 
-	if (!IS_ERR_OR_NULL(i2s_in_master))
-		of_node_put(i2s_in_master);
+	if ((link->dai_fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_I2S)
+		text = "I2S";
+	else
+		text = "Left Justified";
+	dev_dbg(dev, "    Format: %s\n", text);
 
-	if (ret)
-		goto err;
+	if ((link->dai_fmt & SND_SOC_DAIFMT_CLOCK_MASK) == SND_SOC_DAIFMT_CONT)
+		text = "Yes";
+	else
+		text = "No";
+	dev_dbg(dev, "    Continuous Clock: %s\n", text);
 
-	codec_conf = pbc->codec_conf;
+	dev_dbg(dev, "\n");
+}
 
-	codec_np = pbc->codecs[PISTACHIO_CODEC_TPA6130A2].np;
-	if (codec_np) {
-		codec_conf->of_node = codec_np;
-		codec_conf->name_prefix = "TPA";
-		codec_conf++;
-	}
+static void pistachio_card_info_i2s_in(struct pistachio_card *pbc,
+					struct snd_soc_dai_link *link)
+{
+	int i, j;
+	struct snd_soc_dai_link_component *components;
+	struct snd_soc_codec_conf *confs;
+	char *text;
+	struct device *dev = pbc->card.dev;
 
-	codec_np = pbc->codecs[PISTACHIO_CODEC_PCM3060_DAC].np;
-	if (!codec_np)
-		codec_np = pbc->codecs[PISTACHIO_CODEC_PCM3060_ADC].np;
-	if (codec_np) {
-		codec_conf->of_node = codec_np;
-		codec_conf->name_prefix = "PCM3060";
-		codec_conf++;
-	}
+	components = pbc->i2s_in->i2s.components;
+	confs = pbc->card.codec_conf;
+
+	dev_dbg(dev, "I2S IN\n");
+	dev_dbg(dev, "\n");
+	dev_dbg(dev, "    CPU DAI\n");
+	dev_dbg(dev, "        i2s-in (%s)\n",
+		link->cpu_of_node->name);
+	dev_dbg(dev, "\n");
+	dev_dbg(dev, "    CODECS\n");
+
+	for (i = 0; i < pbc->i2s_out->i2s.num_codecs; i++) {
+		for (j = 0; j < pbc->card.num_configs; j++)
+			if (confs[j].of_node == components[i].of_node)
+				break;
+
+		if (i == pbc->i2s_in->frame_master)
+			if (i == pbc->i2s_in->bitclock_master)
+				text = "(Frame + Bit Clock Master)";
+			else
+				text = "(Frame Master)";
+		else
+			if (i == pbc->i2s_in->bitclock_master)
+				text = "(Bitclock Master)";
+			else
+				text = "";
 
-	codec_np = pbc->codecs[PISTACHIO_CODEC_PCM3168A_1_DAC].np;
-	if (!codec_np)
-		codec_np = pbc->codecs[PISTACHIO_CODEC_PCM3168A_1_ADC].np;
-	if (codec_np) {
-		codec_conf->of_node = codec_np;
-		codec_conf->name_prefix = "PCM3168A 1";
-		codec_conf++;
+		dev_dbg(dev, "        %s (%s) (%s) %s\n", confs[j].name_prefix,
+			confs[j].of_node->name,
+			components[i].dai_name, text);
 	}
+	dev_dbg(dev, "\n");
+
+	pistachio_card_info_mclks(pbc, &pbc->i2s_in->i2s);
+
+	dev_dbg(dev, "\n");
+
+	if ((pbc->i2s_in->fmt & SND_SOC_DAIFMT_FORMAT_MASK) ==
+			SND_SOC_DAIFMT_I2S)
+		text = "I2S";
+	else
+		text = "Left Justified";
+	dev_dbg(dev, "    Format: %s\n", text);
+
+	if ((pbc->i2s_in->fmt & SND_SOC_DAIFMT_CLOCK_MASK) ==
+			SND_SOC_DAIFMT_CONT)
+		text = "Yes";
+	else
+		text = "No";
+	dev_dbg(dev, "    Continuous Clock: %s\n", text);
+
+	dev_dbg(dev, "\n");
+}
 
-	codec_np = pbc->codecs[PISTACHIO_CODEC_PCM3168A_2_DAC].np;
-	if (!codec_np)
-		codec_np = pbc->codecs[PISTACHIO_CODEC_PCM3168A_2_ADC].np;
-	if (codec_np) {
-		codec_conf->of_node = codec_np;
-		codec_conf->name_prefix = "PCM3168A 2";
-		codec_conf++;
+static void pistachio_card_info(struct pistachio_card *pbc)
+{
+	struct device *dev = pbc->card.dev;
+	struct snd_soc_codec_conf *conf;
+	struct snd_soc_dai_link *link;
+	char *text;
+
+	link = pbc->card.dai_link;
+
+	dev_dbg(dev, "\n");
+	dev_dbg(dev, "####################################################\n");
+	dev_dbg(dev, "\n");
+	dev_dbg(dev, "Pistachio Audio Card\n");
+	dev_dbg(dev, "\n");
+
+	if (pbc->spdif_out) {
+		dev_dbg(dev, "SPDIF OUT\n");
+		dev_dbg(dev, "\n");
+		dev_dbg(dev, "    CPU DAI\n");
+		dev_dbg(dev, "        spdif-out (%s)\n",
+			link->cpu_of_node->name);
+		dev_dbg(dev, "\n");
+		link++;
+	}
+	if (pbc->spdif_in) {
+		dev_dbg(dev, "SPDIF IN\n");
+		dev_dbg(dev, "\n");
+		dev_dbg(dev, "    CPU DAI\n");
+		dev_dbg(dev, "        spdif-in (%s)\n",
+			link->cpu_of_node->name);
+		dev_dbg(dev, "\n");
+		link++;
+	}
+	if (pbc->parallel_out) {
+		dev_dbg(dev, "PARALLEL OUT\n");
+		dev_dbg(dev, "\n");
+		dev_dbg(dev, "    CPU DAI\n");
+		dev_dbg(dev, "        parallel-out (%s)\n",
+			link->cpu_of_node->name);
+		dev_dbg(dev, "\n");
+		dev_dbg(dev, "    CODECS\n");
+		conf = &pbc->card.codec_conf[pbc->card.num_configs - 1];
+		dev_dbg(dev, "        %s (%s) (%s)\n", conf->name_prefix,
+			conf->of_node->name,
+			pbc->parallel_out->internal_dac.dai_name);
+		dev_dbg(dev, "\n");
+		link++;
+	}
+	if (pbc->i2s_out) {
+		pistachio_card_info_i2s_out(pbc, link);
+		link++;
+	}
+
+	if (pbc->i2s_in)
+		pistachio_card_info_i2s_in(pbc, link);
+
+	if (gpio_is_valid(pbc->mute_gpio)) {
+		if (pbc->mute_gpio_inverted)
+			text = "(Active Low)";
+		else
+			text = "(Active High)";
+		dev_dbg(dev, "Mute: GPIO %u %s\n", pbc->mute_gpio, text);
 	}
+	if (gpio_is_valid(pbc->hp_jack_gpio.gpio)) {
+		if (pbc->hp_jack_gpio.invert)
+			text = "(Active Low)";
+		else
+			text = "(Active High)";
+		dev_dbg(dev, "Headphone-Detect: GPIO %u %s\n",
+				pbc->hp_jack_gpio.gpio, text);
+	}
+	dev_dbg(dev, "\n");
+	dev_dbg(dev, "####################################################\n");
+	dev_dbg(dev, "\n");
+}
+
+#endif
+
+static int pistachio_card_probe(struct platform_device *pdev)
+{
+	struct pistachio_card *pbc;
+	struct device_node *np = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	int ret;
+	unsigned long gpio_flags;
+	struct snd_kcontrol_new *control;
+
+	if (!np || !of_device_is_available(np))
+		return -EINVAL;
 
-	pbc->card.codec_conf = pbc->codec_conf;
-	pbc->card.num_configs = (codec_conf - pbc->codec_conf);
+	pbc = devm_kzalloc(dev, sizeof(*pbc), GFP_KERNEL);
+	if (!pbc)
+		return -ENOMEM;
 
-	ret = pistachio_card_init_clk(dev, "audio_pll", &pbc->audio_pll,
-			&pbc->audio_pll_rate);
+	pbc->card.owner = THIS_MODULE;
+	pbc->card.dev = dev;
+	pbc->card.name = "pistachio-card";
+
+	snd_soc_card_set_drvdata(&pbc->card, pbc);
+
+	mutex_init(&pbc->rate_mutex);
+
+	pbc->hp_jack_gpio.gpio = -ENOENT;
+	pbc->mute_gpio = -ENOENT;
+
+	ret = pistachio_card_parse_of(np, pbc);
 	if (ret)
 		goto err;
 
-	ret = pistachio_card_init_clk(dev, "i2s_mclk", &pbc->i2s_mclk,
-			&pbc->i2s_mclk_rate);
+	ret = pistachio_card_init_clk(dev, "audio_pll", &pbc->audio_pll);
 	if (ret)
-		goto err_clk_audio_pll;
+		goto err;
 
-	pbc->i2s_clk_notifier.notifier_call =
-			pistachio_card_i2s_clk_notifier_cb;
-	ret = clk_notifier_register(pbc->i2s_mclk,
-			&pbc->i2s_clk_notifier);
+	ret = pistachio_card_init_clk(dev, "i2s_mclk", &pbc->i2s_mclk.mclk);
 	if (ret)
-		goto err_clk_mclk;
+		goto err_clk_audio_pll;
 
-	if (pbc->mclk_source == PISTACHIO_MCLK_DAC_CLK) {
-		ret = pistachio_card_init_clk(dev, "dac_clk", &pbc->dac_clk,
-				&pbc->dac_clk_rate);
-		if (ret)
-			goto err_clk_mclk;
-	}
+	ret = pistachio_card_init_clk(dev, "dac_clk", &pbc->dac_mclk.mclk);
+	if (ret)
+		goto err_clk_i2s;
 
-	ret = pistachio_card_init_clk(dev, "evt_clk", &pbc->evt_clk,
-				&pbc->evt_clk_rate);
+	ret = pistachio_card_init_rates(pbc);
 	if (ret)
 		goto err_clk_dac;
 
-	snd_soc_card_set_drvdata(&pbc->card, pbc);
+	pbc->i2s_clk_notifier.notifier_call = pistachio_card_i2s_clk_cb;
+	ret = clk_notifier_register(pbc->i2s_mclk.mclk,
+					&pbc->i2s_clk_notifier);
+	if (ret)
+		goto err_clk_dac;
 
 	ret = devm_snd_soc_register_card(dev, &pbc->card);
-	if (ret < 0)
-		goto err_clk_evt;
+	if (ret)
+		goto err_notifier;
 
-	ret = snd_soc_add_card_controls(&pbc->card, pistachio_bub_controls,
-			ARRAY_SIZE(pistachio_bub_controls));
-	if(ret < 0)
-		goto err_clk_evt;
+	ret = snd_soc_add_card_controls(&pbc->card, pistachio_controls,
+					ARRAY_SIZE(pistachio_controls));
+	if (ret)
+		goto err_notifier;
 
 	if (gpio_is_valid(pbc->hp_jack_gpio.gpio)) {
 		pbc->hp_jack_pin.pin = "Headphones";
@@ -1718,89 +2294,63 @@ static int pistachio_card_probe(struct platform_device *pdev)
 		pbc->hp_jack_gpio.name = "Headphone detection";
 		pbc->hp_jack_gpio.report = SND_JACK_HEADPHONE;
 		pbc->hp_jack_gpio.debounce_time = 150;
-		snd_soc_card_jack_new(&pbc->card, "Headphones",
-				SND_JACK_HEADPHONE, &pbc->hp_jack, &pbc->hp_jack_pin, 1);
-		snd_soc_jack_add_gpios(&pbc->hp_jack, 1, &pbc->hp_jack_gpio);
+		ret = snd_soc_card_jack_new(&pbc->card, "Headphones",
+			SND_JACK_HEADPHONE, &pbc->hp_jack, &pbc->hp_jack_pin,
+			1);
+		if (ret)
+			goto err_notifier;
+		ret = snd_soc_jack_add_gpios(&pbc->hp_jack, 1,
+				&pbc->hp_jack_gpio);
+		if (ret)
+			goto err_notifier;
 	}
 
-	dev_info(dev, "\n");
-	dev_info(dev, "#####################################\n");
-	dev_info(dev, "\n");
-	dev_info(dev, "Pistachio BuB Audio Card\n");
-	dev_info(dev, "\n");
-
-	if (!pbc->card.num_links) {
-		dev_info(dev, "No dai links present\n");
-	} else {
-		if (pbc->dai_links[PISTACHIO_LINK_SPDIF_OUT]) {
-			dev_info(dev, "SPDIF OUT\n");
-			dev_info(dev, "\n");
-		}
-		if (pbc->dai_links[PISTACHIO_LINK_SPDIF_IN]) {
-			dev_info(dev, "SPDIF IN\n");
-			dev_info(dev, "\n");
-		}
-		if (pbc->dai_links[PISTACHIO_LINK_PRL_OUT]) {
-			dev_info(dev, "PARALLEL OUT\n");
-			if (pbc->codecs[PISTACHIO_CODEC_TPA6130A2].np)
-				dev_info(dev, "    TPA6130A2\n");
-			dev_info(dev, "\n");
-		}
-		if (pbc->dai_links[PISTACHIO_LINK_I2S_OUT]) {
-			dev_info(dev, "I2S OUT%s\n",
-				((pbc->i2s_out_master == PISTACHIO_CPU_I2S_OUT) ?
-				((pbc->i2s_in_master == PISTACHIO_CPU_I2S_OUT) ?
-				(" (Dual Frame + Bit Clock Master)") : (" (Frame + Bit Clock Master)")) :
-				("")));
-			if (pbc->codecs[PISTACHIO_CODEC_PCM3060_DAC].np)
-				dev_info(dev, "    PCM3060%s\n",
-					(pbc->i2s_out_master == PISTACHIO_CODEC_PCM3060_DAC) ?
-					(" (Frame + Bit Clock Master)") : (""));
-			if (pbc->codecs[PISTACHIO_CODEC_PCM3168A_1_DAC].np)
-				dev_info(dev, "    PCM3168A 1%s\n",
-					(pbc->i2s_out_master == PISTACHIO_CODEC_PCM3168A_1_DAC) ?
-					(" (Frame + Bit Clock Master)") : (""));
-			if (pbc->codecs[PISTACHIO_CODEC_PCM3168A_2_DAC].np)
-				dev_info(dev, "    PCM3168A 2%s\n",
-					(pbc->i2s_out_master == PISTACHIO_CODEC_PCM3168A_2_DAC) ?
-					(" (Frame + Bit Clock Master)") : (""));
-			dev_info(dev, "\n");
-		}
-		if (pbc->dai_links[PISTACHIO_LINK_I2S_IN]) {
-			dev_info(dev, "I2S IN\n");
-			if (pbc->codecs[PISTACHIO_CODEC_PCM3060_ADC].np)
-				dev_info(dev, "    PCM3060%s\n",
-					(pbc->i2s_in_master == PISTACHIO_CODEC_PCM3060_ADC) ?
-					(" (Frame + Bit Clock Master)") : (""));
-			if (pbc->codecs[PISTACHIO_CODEC_PCM3168A_1_ADC].np)
-				dev_info(dev, "    PCM3168A 1%s\n",
-					(pbc->i2s_in_master == PISTACHIO_CODEC_PCM3168A_1_ADC) ?
-					(" (Frame + Bit Clock Master)") : (""));
-			if (pbc->codecs[PISTACHIO_CODEC_PCM3168A_2_ADC].np)
-				dev_info(dev, "    PCM3168A 2%s\n",
-					(pbc->i2s_in_master == PISTACHIO_CODEC_PCM3168A_2_ADC) ?
-					(" (Frame + Bit Clock Master)") : (""));
-			if (pbc->i2s_in_master == PISTACHIO_FRAME_EXTERNAL)
-				dev_info(dev, "    EXTERNAL (Frame + Bit Clock Master)\n");
-			dev_info(dev, "\n");
+	if (gpio_is_valid(pbc->mute_gpio)) {
+		if (pbc->mute_gpio_inverted)
+			gpio_flags = GPIOF_OUT_INIT_HIGH;
+		else
+			gpio_flags = GPIOF_OUT_INIT_LOW;
+		ret = gpio_request_one(pbc->mute_gpio, gpio_flags, "Mute");
+		if (ret)
+			goto err_jack;
+		control = devm_kzalloc(dev, sizeof(*control), GFP_KERNEL);
+		if (!control) {
+			ret = -ENOMEM;
+			goto err_mute;
 		}
+		control->access = SNDRV_CTL_ELEM_ACCESS_READWRITE;
+		control->iface = SNDRV_CTL_ELEM_IFACE_CARD;
+		control->name = "Mute Switch";
+		control->info = snd_ctl_boolean_mono_info;
+		control->get = pistachio_card_get_mute;
+		control->put = pistachio_card_set_mute;
+		ret = snd_soc_add_card_controls(&pbc->card, control, 1);
+		if (ret)
+			goto err_mute;
 	}
-	dev_info(dev, "#####################################\n");
-	dev_info(dev, "\n");
+
+#ifdef	DEBUG
+	pistachio_card_info(pbc);
+#endif
 
 	return 0;
 
-err_clk_evt:
-	clk_disable_unprepare(pbc->evt_clk);
+err_mute:
+	if (gpio_is_valid(pbc->mute_gpio))
+		gpio_free(pbc->mute_gpio);
+err_jack:
+	if (gpio_is_valid(pbc->hp_jack_gpio.gpio))
+		snd_soc_jack_free_gpios(&pbc->hp_jack, 1, &pbc->hp_jack_gpio);
+err_notifier:
+	clk_notifier_unregister(pbc->i2s_mclk.mclk, &pbc->i2s_clk_notifier);
 err_clk_dac:
-	if (pbc->mclk_source == PISTACHIO_MCLK_DAC_CLK)
-		clk_disable_unprepare(pbc->dac_clk);
-err_clk_mclk:
-	clk_disable_unprepare(pbc->i2s_mclk);
+	clk_disable_unprepare(pbc->dac_mclk.mclk);
+err_clk_i2s:
+	clk_disable_unprepare(pbc->i2s_mclk.mclk);
 err_clk_audio_pll:
 	clk_disable_unprepare(pbc->audio_pll);
 err:
-	pistachio_card_unref(pdev, i2s_out_master, i2s_in_master);
+	pistachio_card_unref(pbc);
 
 	return ret;
 }
@@ -1808,26 +2358,31 @@ err:
 static int pistachio_card_remove(struct platform_device *pdev)
 {
 	struct snd_soc_card *card = platform_get_drvdata(pdev);
-	struct pistachio_card_data *pbc = snd_soc_card_get_drvdata(card);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
 
+	pistachio_evt_abort_measurements(pbc->event_timer);
+	if (gpio_is_valid(pbc->mute_gpio))
+		gpio_free(pbc->mute_gpio);
 	if (gpio_is_valid(pbc->hp_jack_gpio.gpio))
-		snd_soc_jack_free_gpios(&pbc->hp_jack, 1,
-					&pbc->hp_jack_gpio);
-
-	pistachio_card_unref(pdev, NULL, NULL);
+		snd_soc_jack_free_gpios(&pbc->hp_jack, 1, &pbc->hp_jack_gpio);
+	clk_notifier_unregister(pbc->i2s_mclk.mclk, &pbc->i2s_clk_notifier);
+	clk_disable_unprepare(pbc->dac_mclk.mclk);
+	clk_disable_unprepare(pbc->i2s_mclk.mclk);
+	clk_disable_unprepare(pbc->audio_pll);
+	pistachio_card_unref(pbc);
 
 	return 0;
 }
 
 static const struct of_device_id pistachio_card_of_match[] = {
-	{ .compatible = "img,pistachio-bub-audio" },
+	{ .compatible = "img,pistachio-audio" },
 	{},
 };
 MODULE_DEVICE_TABLE(of, pistachio_card_of_match);
 
 static struct platform_driver pistachio_card = {
 	.driver = {
-		.name = "pistachio-bub-card",
+		.name = "pistachio-card",
 		.of_match_table = pistachio_card_of_match,
 	},
 	.probe = pistachio_card_probe,
@@ -1835,6 +2390,6 @@ static struct platform_driver pistachio_card = {
 };
 module_platform_driver(pistachio_card);
 
-MODULE_DESCRIPTION("Pistachio BuB audio card driver");
+MODULE_DESCRIPTION("Pistachio audio card driver");
 MODULE_AUTHOR("Damien Horsley <Damien.Horsley@imgtec.com>");
 MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/img/pistachio-event-timer-atu.c b/sound/soc/img/pistachio-event-timer-atu.c
new file mode 100644
index 0000000..698b6ec9
--- /dev/null
+++ b/sound/soc/img/pistachio-event-timer-atu.c
@@ -0,0 +1,68 @@
+/*
+ * Pistachio event timer ATU time units
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clocksource.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/hrtimer.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/timecounter.h>
+
+#include <linux/atu_clk.h>
+
+#include "pistachio-event-timer.h"
+#include "pistachio-event-timer-internal.h"
+
+
+u64 _pistachio_evt_get_time(struct pistachio_evt *evt)
+{
+	return atu_get_current_time();
+}
+EXPORT_SYMBOL_GPL(_pistachio_evt_get_time);
+
+u64 pistachio_evt_get_time(struct pistachio_evt *evt)
+{
+	return atu_get_current_time();
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_get_time);
+
+int pistachio_evt_time_to_reg(struct pistachio_evt *evt, u64 time, u32 *reg,
+				u64 min_time_delta)
+{
+	return atu_to_frc(time, reg, min_time_delta);
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_time_to_reg);
+
+int pistachio_evt_init(struct pistachio_evt *evt)
+{
+	return atu_cyclecounter_register(&evt->cc, evt->audio_pll);
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_init);
+
+void pistachio_evt_deinit(struct pistachio_evt *evt)
+{
+	atu_cyclecounter_unregister(&evt->cc);
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_deinit);
diff --git a/sound/soc/img/pistachio-event-timer-internal.h b/sound/soc/img/pistachio-event-timer-internal.h
new file mode 100644
index 0000000..562d14b
--- /dev/null
+++ b/sound/soc/img/pistachio-event-timer-internal.h
@@ -0,0 +1,69 @@
+/*
+ * Imagination Technologies Pistachio Event Timer Internal Header
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#ifndef __IMG_PISTACHIO_EVT_INTERNAL_H__
+#define __IMG_PISTACHIO_EVT_INTERNAL_H__
+
+enum pistachio_evt_state {
+	PISTACHIO_EVT_STATE_IDLE = 0,
+	PISTACHIO_EVT_STATE_ACTIVE_FIRST,
+	PISTACHIO_EVT_STATE_ACTIVE_SECOND,
+	PISTACHIO_EVT_STATE_ACTIVE_THIRD,
+	PISTACHIO_EVT_STATE_COMPLETE
+};
+
+struct pistachio_evt_callback {
+	u64 trigger_time;
+	u32 cyc;
+	void (*callback)(struct pistachio_evt *, void *);
+	void *context;
+};
+
+struct pistachio_evt_measurement {
+	enum pistachio_evt_state state;
+	void (*callback)(void *);
+	void *context;
+};
+
+struct pistachio_evt {
+	struct list_head list;
+	spinlock_t lock;
+	struct device *dev;
+	struct device_node *np;
+	void __iomem *base;
+	struct clk *audio_pll;
+	struct clk *clk_sys;
+	struct clk *clk_ref_a;
+	struct clk *clk_ref_b;
+	const char *ref_names[2];
+	struct clk *clk_ref_internal;
+	struct cyclecounter cc;
+	struct timecounter tc;
+	struct notifier_block evt_clk_notifier;
+	struct hrtimer poll_timer;
+	ktime_t quarter_rollover;
+	unsigned long sys_rate;
+	struct pistachio_evt_callback trigger_cbs[PISTACHIO_EVT_NUM_ENABLES];
+	struct pistachio_evt_measurement sample_rates[PISTACHIO_EVT_MAX_SOURCES];
+	struct pistachio_evt_measurement phase_difference;
+};
+
+/* Call with lock held */
+u64 _pistachio_evt_get_time(struct pistachio_evt *evt);
+/* Call without lock held */
+u64 pistachio_evt_get_time(struct pistachio_evt *evt);
+int pistachio_evt_time_to_reg(struct pistachio_evt *evt, u64 time,
+				u32 *reg, u64 min_time_delta);
+int pistachio_evt_init(struct pistachio_evt *evt);
+void pistachio_evt_deinit(struct pistachio_evt *evt);
+
+#endif
diff --git a/sound/soc/img/pistachio-event-timer-local.c b/sound/soc/img/pistachio-event-timer-local.c
new file mode 100644
index 0000000..33ad48d
--- /dev/null
+++ b/sound/soc/img/pistachio-event-timer-local.c
@@ -0,0 +1,186 @@
+/*
+ * Pistachio event timer local time units
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clocksource.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/hrtimer.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/timecounter.h>
+
+#include <linux/atu_clk.h>
+
+#include "pistachio-event-timer.h"
+#include "pistachio-event-timer-internal.h"
+
+static u64 _pistachio_evt_get_time_cyc(struct pistachio_evt *evt, u32 *cyc)
+{
+	u64 ret;
+
+	ret = timecounter_read(&evt->tc);
+	if (cyc)
+		*cyc = evt->tc.cycle_last;
+
+	return ret;
+}
+
+static u64 pistachio_evt_get_time_cyc(struct pistachio_evt *evt, u32 *cyc)
+{
+	unsigned long flags;
+	u64 ret;
+
+	spin_lock_irqsave(&evt->lock, flags);
+	ret = _pistachio_evt_read_ns(evt, cyc);
+	spin_unlock_irqrestore(&evt->lock, flags);
+
+	return ret;
+}
+
+u64 _pistachio_evt_get_time(struct pistachio_evt *evt)
+{
+	return _pistachio_evt_get_time_cyc(evt, NULL);
+}
+EXPORT_SYMBOL_GPL(_pistachio_evt_get_time);
+
+u64 pistachio_evt_get_time(struct pistachio_evt *evt)
+{
+	return pistachio_evt_get_time_cyc(evt, NULL);
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_get_time);
+
+int pistachio_evt_time_to_reg(struct pistachio_evt *evt, u64 time, u32 *reg,
+				u64 min_time_delta)
+{
+	u64 tmp;
+	u32 cyc;
+
+	tmp = _pistachio_evt_get_time_cyc(evt, &cyc);
+
+	/* Trigger in the past or too close to current time? */
+	if (time < (tmp + min_time_delta))
+		return -ETIME;
+
+	/*
+	 * Convert ns difference between current time and trigger time
+	 * to event timer cycles
+	 */
+	tmp = (time - tmp) << evt->cc.shift;
+	do_div(tmp, evt->cc.mult);
+
+	/* Trigger too far into the future (cyc value would be ambiguous)? */
+	if (tmp > evt->cc.mask)
+		return -ETIME;
+
+	/* Calculate cycle value for trigger */
+	cyc = (cyc + tmp) & evt->cc.mask;
+
+	/* Final time check before fast write operations */
+	tmp = _pistachio_evt_get_time_cyc(evt, &cyc);
+	if (time < (tmp + min_time_delta))
+		return -ETIME;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_time_to_reg);
+
+static enum hrtimer_restart pistachio_evt_poll(struct hrtimer *tmr)
+{
+	struct pistachio_evt *evt;
+	u64 tmp;
+
+	evt = container_of(tmr, struct pistachio_evt, poll_timer);
+
+	tmp = pistachio_evt_get_time(evt);
+
+	hrtimer_forward(&evt->poll_timer,
+			hrtimer_get_expires(&evt->poll_timer),
+			evt->quarter_rollover);
+
+	return HRTIMER_RESTART;
+}
+
+static void pistachio_evt_start_poll_timer(struct pistachio_evt *evt)
+{
+	ktime_t ks;
+
+	ks = ktime_get();
+	ks = ktime_add(ks, evt->quarter_rollover);
+
+	hrtimer_start(&evt->poll_timer, ks, HRTIMER_MODE_ABS);
+}
+
+static int pistachio_evt_clk_notifier_cb(struct notifier_block *nb,
+		unsigned long event, void *data)
+{
+	struct pistachio_evt *evt;
+
+	evt = container_of(nb, struct pistachio_evt, evt_clk_notifier);
+
+	switch (event) {
+	case PRE_RATE_CHANGE:
+		pistachio_evt_read_ns(evt, NULL);
+		return NOTIFY_OK;
+	case POST_RATE_CHANGE:
+		hrtimer_cancel(&evt->poll_timer);
+		pistachio_evt_clk_rate_change(evt);
+		pistachio_evt_read_ns(evt, NULL);
+		pistachio_evt_start_poll_timer(evt);
+		return NOTIFY_OK;
+	case ABORT_RATE_CHANGE:
+		return NOTIFY_OK;
+	default:
+		return NOTIFY_DONE;
+	}
+}
+
+int pistachio_evt_init(struct pistachio_evt *evt)
+{
+	int ret;
+
+	timecounter_init(&evt->tc, (const struct cyclecounter *)&evt->cc, 0);
+
+	hrtimer_init(&evt->poll_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
+	evt->poll_timer.function = pistachio_evt_poll;
+
+	pistachio_evt_start_poll_timer(evt);
+
+	evt->evt_clk_notifier.notifier_call = pistachio_evt_clk_notifier_cb;
+
+	ret = clk_notifier_register(evt->clk_ref_internal,
+					&evt->evt_clk_notifier);
+
+	if (ret)
+		hrtimer_cancel(&evt->poll_timer);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_init);
+
+void pistachio_evt_deinit(struct pistachio_evt *evt)
+{
+	clk_notifier_unregister(evt->clk_ref_internal, &evt->evt_clk_notifier);
+	hrtimer_cancel(&evt->poll_timer);
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_deinit);
diff --git a/sound/soc/img/pistachio-event-timer.c b/sound/soc/img/pistachio-event-timer.c
index c0f5d29..29f81ce 100644
--- a/sound/soc/img/pistachio-event-timer.c
+++ b/sound/soc/img/pistachio-event-timer.c
@@ -1,7 +1,7 @@
 /*
  * Pistachio event timer driver
  *
- * Copyright (C) 2014 Imagination Technologies Ltd.
+ * Copyright (C) 2015 Imagination Technologies Ltd.
  *
  * Author: Damien Horsley <Damien.Horsley@imgtec.com>
  *
@@ -11,30 +11,32 @@
  */
 
 #include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clocksource.h>
+#include <linux/delay.h>
+#include <linux/hrtimer.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
 #include <linux/irq.h>
-#include <linux/hrtimer.h>
 #include <linux/kernel.h>
 #include <linux/list.h>
 #include <linux/module.h>
 #include <linux/of.h>
+#include <linux/of_address.h>
 #include <linux/of_device.h>
+#include <linux/of_irq.h>
 #include <linux/platform_device.h>
+#include <linux/regmap.h>
 #include <linux/slab.h>
 #include <linux/spinlock.h>
-#include <linux/of_irq.h>
-#include <linux/clk-provider.h>
-#include <linux/of_address.h>
-#include <linux/delay.h>
-#include <linux/clocksource.h>
 #include <linux/timecounter.h>
 
-#ifdef CONFIG_ATU
-#include <linux/atu_clk.h>
-#endif /* CONFIG_ATU */
+#include <linux/mfd/syscon.h>
 
 #include "pistachio-event-timer.h"
+#include "pistachio-event-timer-internal.h"
+
+#define	PISTACHIO_EVT_FIFO_DEPTH		16
 
 #define PISTACHIO_EVT_COUNTER			0x0
 #define PISTACHIO_EVT_COUNTER_MASK		0x3fffffff
@@ -57,135 +59,92 @@
 #define PISTACHIO_EVT_TIMER_ENABLE		0x100
 #define PISTACHIO_EVT_TIMER_ENABLE_MASK		0x1
 
+#define PISTACHIO_EVT_SOURCES			0x108
+#define PISTACHIO_EVT_SOURCES_SHIFT		16
+#define	PISTACHIO_EVT_SOURCES_MASK_LSB		0xffffUL
+
+#define PISTACHIO_EVT_PHASE_FIFO		0x110
+
+#define	PISTACHIO_EVT_SAMPLE_FIFO(id)		(0x114 + ((id) * 0x4))
+
 #define PISTACHIO_EVT_EVENT_CTL			0x120
 #define PISTACHIO_EVT_EVENT_CTL_MASK		0x3
 #define PISTACHIO_EVT_EVENT_CTL_WIDTH		2
 
-#define PISTACHIO_EVT_TB			0x130
-#define PISTACHIO_EVT_TIME_REG(en)		(PISTACHIO_EVT_TB + (0x4 * en))
+#define PISTACHIO_EVT_TIME_REG(en)		(0x130 + ((en) * 0x4))
 
-#define PISTACHIO_EVT_TIMESTAMP_SRC_START	0x190
-#define PISTACHIO_EVT_TIMESTAMP_SRC_MASK	0xff
-#define PISTACHIO_EVT_TIMESTAMP_SRC_WIDTH	8
+#define PISTACHIO_EVT_INT_STATUS		0x170
 
-#define	PISTACHIO_EVT_MIN_EVENT_DELTA_NS	100000
+#define PISTACHIO_EVT_INT_ENABLE		0x174
 
-struct pistachio_evt_callback {
-	u64 trigger_time;
-	u32 cyc;
-	void (*callback)(void *context);
-	void *context;
-};
+#define PISTACHIO_EVT_INT_CLEAR			0x178
 
-struct pistachio_evt_data {
-	spinlock_t lock;
-	struct device *dev;
-	void __iomem *base;
-	struct clk *clk_sys;
-	struct clk *clk_ref_internal;
-	struct clk *clk_ref_a;
-	struct clk *clk_ref_b;
-	const char *ref_names[2];
-	struct cyclecounter cc;
-	struct timecounter tc;
-	struct notifier_block evt_clk_notifier;
-	struct hrtimer poll_timer;
-	ktime_t quarter_rollover;
-	unsigned long rate;
-	struct pistachio_evt_callback trigger_cbs[PISTACHIO_EVT_NUM_ENABLES];
-};
-unsigned long evt_timer_rate;
+#define	PISTACHIO_EVT_INT_SAMPLE_0_FNE_MASK	BIT(5)
+#define	PISTACHIO_EVT_INT_SAMPLE_1_FNE_MASK	BIT(9)
+#define	PISTACHIO_EVT_INT_PHASE_FNE_MASK	BIT(1)
+
+#define	PISTACHIO_EVT_EXT_SRC_REG		0x158
+#define	PISTACHIO_EVT_EXT_SRC_MASK		0xf
+#define	PISTACHIO_EVT_EXT_SRC_NUM_BANKS		7
+
+#define	PISTACHIO_EVT_MIN_EVENT_DELTA_NS	10000
+
+static LIST_HEAD(pistachio_evt_list);
+static DEFINE_SPINLOCK(pistachio_evt_list_spinlock);
 
-static inline u32 pistachio_evt_readl(struct pistachio_evt_data *evt, u32 reg)
+static inline u32 pistachio_evt_readl(struct pistachio_evt *evt, u32 reg)
 {
 	return readl(evt->base + reg);
 }
 
-static inline void pistachio_evt_writel(struct pistachio_evt_data *evt,
+static inline void pistachio_evt_writel(struct pistachio_evt *evt,
 					u32 val, u32 reg)
 {
 	writel(val, evt->base + reg);
 }
 
-static inline void pistachio_evt_stop_count(struct pistachio_evt_data *evt)
+static inline void pistachio_evt_stop_count(struct pistachio_evt *evt)
 {
 	u32 reg = pistachio_evt_readl(evt, PISTACHIO_EVT_COUNTER);
+
 	reg &= ~PISTACHIO_EVT_COUNTER_ENABLE_MASK;
 	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_COUNTER);
 }
 
-static inline void pistachio_evt_start_count(struct pistachio_evt_data *evt)
+static inline void pistachio_evt_start_count(struct pistachio_evt *evt)
 {
 	u32 reg = pistachio_evt_readl(evt, PISTACHIO_EVT_COUNTER);
+
 	reg |= PISTACHIO_EVT_COUNTER_ENABLE_MASK;
 	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_COUNTER);
 }
 
-static inline int pistachio_evt_get_count(struct pistachio_evt_data *evt)
+static inline u32 pistachio_evt_get_count(struct pistachio_evt *evt)
 {
 	u32 reg = pistachio_evt_readl(evt, PISTACHIO_EVT_COUNTER);
-	return reg & PISTACHIO_EVT_COUNTER_MASK;
-}
 
-static inline void pistachio_evt_set_count(struct pistachio_evt_data *evt,
-					int count)
-{
-	u32 reg = pistachio_evt_readl(evt, PISTACHIO_EVT_COUNTER);
-	reg = (reg & ~PISTACHIO_EVT_COUNTER_MASK) |
-		(count & PISTACHIO_EVT_COUNTER_MASK);
-	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_COUNTER);
+	return reg & PISTACHIO_EVT_COUNTER_MASK;
 }
 
 static cycle_t pistachio_evt_cc_read(const struct cyclecounter *cc)
 {
-	struct pistachio_evt_data *evt;
+	struct pistachio_evt *evt;
 
-	evt = container_of(cc, struct pistachio_evt_data, cc);
+	evt = container_of(cc, struct pistachio_evt, cc);
 
 	return (cycle_t)pistachio_evt_get_count(evt);
 }
 
-static u64 _pistachio_evt_read_ns(struct pistachio_evt_data *evt, u32 *cyc)
-{
-	u64 ret;
-
-	ret = timecounter_read(&evt->tc);
-	if (cyc)
-		*cyc = evt->tc.cycle_last;
-
-	return ret;
-}
-
-static u64 pistachio_evt_read_ns(struct pistachio_evt_data *evt, u32 *cyc)
-{
-	unsigned long flags;
-	u64 ret;
-
-	spin_lock_irqsave(&evt->lock, flags);
-	ret = _pistachio_evt_read_ns(evt, cyc);
-	spin_unlock_irqrestore(&evt->lock, flags);
-
-	return ret;
-}
-
-void pistachio_evt_read(struct platform_device *pdev,
+void pistachio_evt_get_time_ts(struct pistachio_evt *evt,
 				struct timespec *ts)
 {
 	u64 tmp;
-#ifndef	CONFIG_ATU
-	struct pistachio_evt_data *evt = platform_get_drvdata(pdev);
-#endif
-
-#ifdef	CONFIG_ATU
-	tmp = atu_get_current_time();
-#else
-	tmp = pistachio_evt_read_ns(evt, NULL);
-#endif
 
+	tmp = pistachio_evt_get_time(evt);
 	ts->tv_nsec = do_div(tmp, NSEC_PER_SEC);
 	ts->tv_sec = tmp;
 }
-EXPORT_SYMBOL_GPL(pistachio_evt_read);
+EXPORT_SYMBOL_GPL(pistachio_evt_get_time_ts);
 
 static inline bool pistachio_evt_bad_event(enum pistachio_evt_enable event)
 {
@@ -201,7 +160,7 @@ static inline bool pistachio_evt_bad_event(enum pistachio_evt_enable event)
 }
 
 static struct pistachio_evt_callback *pistachio_evt_get_next_trigger(
-		struct pistachio_evt_data *evt, u64 *p_next_trigger)
+		struct pistachio_evt *evt, u64 *p_next_trigger)
 {
 	u64 next_trigger, tmp;
 	int i;
@@ -210,7 +169,7 @@ static struct pistachio_evt_callback *pistachio_evt_get_next_trigger(
 	cb = &evt->trigger_cbs[0];
 	next_trigger = ULLONG_MAX;
 
-	for (i = 0; i < PISTACHIO_EVT_NUM_ENABLES; i++) {
+	for (i = 0; i < PISTACHIO_EVT_NUM_ENABLES; i++, cb++) {
 		if (!pistachio_evt_bad_event(i)) {
 			tmp = cb->trigger_time;
 			if (tmp && (tmp < next_trigger)) {
@@ -218,7 +177,6 @@ static struct pistachio_evt_callback *pistachio_evt_get_next_trigger(
 				cbr = cb;
 			}
 		}
-		cb++;
 	}
 
 	*p_next_trigger = next_trigger;
@@ -226,16 +184,33 @@ static struct pistachio_evt_callback *pistachio_evt_get_next_trigger(
 	return cbr;
 }
 
-void _pistachio_evt_disable_event(struct platform_device *pdev,
+struct pistachio_evt *pistachio_evt_get(struct device_node *np)
+{
+	struct pistachio_evt *evt, *ret = ERR_PTR(-EPROBE_DEFER);
+
+	spin_lock(&pistachio_evt_list_spinlock);
+	list_for_each_entry(evt, &pistachio_evt_list, list) {
+		if (evt->np == np) {
+			ret = evt;
+			break;
+		}
+	}
+	spin_unlock(&pistachio_evt_list_spinlock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_get);
+
+void _pistachio_evt_disable_event(struct pistachio_evt *evt,
 		enum pistachio_evt_enable event)
 {
 	u32 reg;
-	struct pistachio_evt_data *evt = platform_get_drvdata(pdev);
 
 	dev_dbg(evt->dev, "Disable event %u\n", (unsigned int)event);
 
 	if (pistachio_evt_bad_event(event)) {
-		dev_err(evt->dev, "Disable event %u failed (bad event %u)\n", (unsigned int)event, (unsigned int)event);
+		dev_err(evt->dev, "Disable event %u failed (bad event %u)\n",
+			(unsigned int)event, (unsigned int)event);
 		return;
 	}
 
@@ -250,52 +225,52 @@ void _pistachio_evt_disable_event(struct platform_device *pdev,
 }
 EXPORT_SYMBOL_GPL(_pistachio_evt_disable_event);
 
-void pistachio_evt_disable_event(struct platform_device *pdev,
+void pistachio_evt_disable_event(struct pistachio_evt *evt,
 		enum pistachio_evt_enable event)
 {
 	unsigned long flags;
-	struct pistachio_evt_data *evt = platform_get_drvdata(pdev);
 
 	spin_lock_irqsave(&evt->lock, flags);
-	_pistachio_evt_disable_event(pdev, event);
+	_pistachio_evt_disable_event(evt, event);
 	spin_unlock_irqrestore(&evt->lock, flags);
 }
 EXPORT_SYMBOL_GPL(pistachio_evt_disable_event);
 
-int pistachio_evt_set_event(struct platform_device *pdev,
+int pistachio_evt_set_event(struct pistachio_evt *evt,
 		enum pistachio_evt_enable event, enum pistachio_evt_type type,
 		struct timespec *ts,
-		void (*event_trigger_callback)(void *context), void *context)
+		void (*event_trigger_callback)(struct pistachio_evt *, void *),
+		void *context)
 {
 	u32 reg, cyc, event_reg_addr, irq_reg_addr;
 	u64 trigger_time, next_trigger;
 	unsigned long flags;
-	struct pistachio_evt_data *evt = platform_get_drvdata(pdev);
 	struct pistachio_evt_callback *cb;
-#ifdef	CONFIG_ATU
 	int ret;
-#else
-	u64 tmp;
-#endif
 
-	dev_dbg(evt->dev, "Set event %u type %u time %u,%u\n", (unsigned int)event, (unsigned int)type, (unsigned int)ts->tv_sec, (unsigned int)ts->tv_nsec);
+	dev_dbg(evt->dev, "Set event %u type %u time %u,%ld\n",
+		(unsigned int)event, (unsigned int)type,
+		(unsigned int)ts->tv_sec, ts->tv_nsec);
 
 	if (pistachio_evt_bad_event(event)) {
-		dev_err(evt->dev, "Set event %u failed (bad event %u)\n", (unsigned int)event, (unsigned int)event);
+		dev_err(evt->dev, "Set event %u failed (bad event %u)\n",
+			(unsigned int)event, (unsigned int)event);
 		return -EINVAL;
 	}
 
-	switch(type) {
+	switch (type) {
 	case PISTACHIO_EVT_TYPE_LEVEL:
 	case PISTACHIO_EVT_TYPE_PULSE:
 		break;
 	default:
-		dev_err(evt->dev, "Set event %u failed (bad event type %u)\n", (unsigned int)event, (unsigned int)type);
+		dev_err(evt->dev, "Set event %u failed (bad event type %u)\n",
+			(unsigned int)event, (unsigned int)type);
 		return -EINVAL;
 	}
 
 	if (!ts) {
-		dev_err(evt->dev, "Set event %u failed (ts == NULL)\n", (unsigned int)event);
+		dev_err(evt->dev, "Set event %u failed (ts == NULL)\n",
+			(unsigned int)event);
 		return -EINVAL;
 	}
 
@@ -308,14 +283,19 @@ int pistachio_evt_set_event(struct platform_device *pdev,
 
 	/* Trigger already pending for this event? */
 	if (evt->trigger_cbs[event].trigger_time) {
-		dev_err(evt->dev, "Set event %u failed (trigger already pending at %lldns)\n", (unsigned int)event, evt->trigger_cbs[event].trigger_time);
 		spin_unlock_irqrestore(&evt->lock, flags);
+		dev_err(evt->dev, "Set event %u failed (trigger already pending at %lluns)\n",
+			(unsigned int)event,
+			evt->trigger_cbs[event].trigger_time);
 		return -EINVAL;
 	}
 
 	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_EVENT_CTL);
 
-	/* Disable event first */
+	/*
+	 * This event may have triggered previously. The control bits need to
+	 * be cleared before programming a new trigger
+	 */
 	reg &= ~(PISTACHIO_EVT_EVENT_CTL_MASK <<
 		(PISTACHIO_EVT_EVENT_CTL_WIDTH * event));
 
@@ -323,62 +303,22 @@ int pistachio_evt_set_event(struct platform_device *pdev,
 
 	reg |= (type << (PISTACHIO_EVT_EVENT_CTL_WIDTH * event));
 
-#ifdef	CONFIG_ATU
-	ret = atu_to_frc(trigger_time, &cyc, PISTACHIO_EVT_MIN_EVENT_DELTA_NS);
-	if(ret) {
+	ret = pistachio_evt_time_to_reg(evt, trigger_time, &cyc,
+					PISTACHIO_EVT_MIN_EVENT_DELTA_NS);
+	if (ret) {
 		spin_unlock_irqrestore(&evt->lock, flags);
+		dev_err(evt->dev, "Set event %u failed (%d)\n",
+			(unsigned int)event, ret);
 		return ret;
 	}
-#else
-	tmp = _pistachio_evt_read_ns(evt, &cyc);
-
-	/* Trigger in the past or too close to current time? */
-	if (trigger_time < (tmp + PISTACHIO_EVT_MIN_EVENT_DELTA_NS)) {
-		if (trigger_time < tmp)
-			dev_dbg(evt->dev, "Set event %u failed (1) (trigger in the past: -%lluns)\n", (unsigned int)event, (tmp - trigger_time));
-		else
-			dev_dbg(evt->dev, "Set event %u failed (1) (trigger too close to expiry: +%lluns)\n", (unsigned int)event, (trigger_time - tmp));
-		spin_unlock_irqrestore(&evt->lock, flags);
-		return -ETIME;
-	}
-
-	/*
-	 * Convert ns difference between current time and trigger time
-	 * to event timer cycles
-	 */
-	tmp = (trigger_time - tmp) << evt->cc.shift;
-	do_div(tmp, evt->cc.mult);
 
-	/* Trigger too far into the future (cyc value would be ambiguous)? */
-	if (tmp > PISTACHIO_EVT_COUNTER_MASK) {
-		dev_dbg(evt->dev, "Set event %u failed (trigger too far into the future: %lluns)\n", (unsigned int)event, trigger_time);
-		spin_unlock_irqrestore(&evt->lock, flags);
-		return -ETIME;
-	}
-
-	/* Calculate cycle value for trigger */
-	cyc = (cyc + tmp) & PISTACHIO_EVT_COUNTER_MASK;
+	pistachio_evt_writel(evt, cyc, event_reg_addr);
 
 	cb = pistachio_evt_get_next_trigger(evt, &next_trigger);
 
-	/* Final time check before fast write operations */
-	tmp = _pistachio_evt_read_ns(evt, NULL);
-
-	if (trigger_time < (tmp + PISTACHIO_EVT_MIN_EVENT_DELTA_NS)) {
-		if (trigger_time < tmp)
-			dev_dbg(evt->dev, "Set event %u failed (2) (trigger in the past: -%lluns)\n", (unsigned int)event, (tmp - trigger_time));
-		else
-			dev_dbg(evt->dev, "Set event %u failed (2) (trigger too close to expiry: +%lluns)\n", (unsigned int)event, (trigger_time - tmp));
-		spin_unlock_irqrestore(&evt->lock, flags);
-		return -ETIME;
-	}
-#endif
-
-	pistachio_evt_writel(evt, cyc, event_reg_addr);
-
 	/*
 	 * No irq trigger currently set or the new trigger time is
-	 * earlier than the current trigger time?
+	 * earlier than the next trigger time?
 	 */
 	if (!cb || (next_trigger > trigger_time)) {
 		pistachio_evt_writel(evt, cyc, irq_reg_addr);
@@ -400,8 +340,8 @@ int pistachio_evt_set_event(struct platform_device *pdev,
 }
 EXPORT_SYMBOL_GPL(pistachio_evt_set_event);
 
-static bool pistachio_evt_retrigger(struct pistachio_evt_data *evt,
-				struct pistachio_evt_callback * cb)
+static bool pistachio_evt_retrigger(struct pistachio_evt *evt,
+				struct pistachio_evt_callback *cb)
 {
 	u32 reg, trig_reg_addr;
 	u64 cur_time;
@@ -416,11 +356,7 @@ static bool pistachio_evt_retrigger(struct pistachio_evt_data *evt,
 	pistachio_evt_writel(evt, cb->cyc, trig_reg_addr);
 	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_EVENT_CTL);
 
-#ifdef	CONFIG_ATU
-	cur_time = atu_get_current_time();
-#else
-	cur_time = _pistachio_evt_read_ns(evt, NULL);
-#endif
+	cur_time = _pistachio_evt_get_time(evt);
 
 	/* Trigger passed while writing? */
 	if (cb->trigger_time < cur_time)
@@ -431,7 +367,7 @@ static bool pistachio_evt_retrigger(struct pistachio_evt_data *evt,
 
 static irqreturn_t pistachio_evt_trigger_0_irq(int irq, void *dev_id)
 {
-	struct pistachio_evt_data *evt = (struct pistachio_evt_data *)dev_id;
+	struct pistachio_evt *evt = (struct pistachio_evt *)dev_id;
 	u64 next_trigger, cur_time;
 	struct pistachio_evt_callback *cb;
 	unsigned long flags;
@@ -454,21 +390,17 @@ static irqreturn_t pistachio_evt_trigger_0_irq(int irq, void *dev_id)
 		if (!cb)
 			break;
 
-#ifdef	CONFIG_ATU
-		cur_time = atu_get_current_time();
-#else
-		cur_time = _pistachio_evt_read_ns(evt, NULL);
-#endif
+		cur_time = _pistachio_evt_get_time(evt);
 
 		if (cur_time >= next_trigger) {
 			if (cb->callback)
-				cb->callback(cb->context);
+				cb->callback(evt, cb->context);
 			cb->trigger_time = 0;
 		} else if (pistachio_evt_retrigger(evt, cb)) {
 			break;
 		} else {
 			if (cb->callback)
-				cb->callback(cb->context);
+				cb->callback(evt, cb->context);
 			cb->trigger_time = 0;
 		}
 	}
@@ -478,124 +410,323 @@ static irqreturn_t pistachio_evt_trigger_0_irq(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-int pistachio_evt_set_timestamp_source(struct platform_device *pdev,
-		unsigned int ts_module_index, unsigned int interrupt_source)
+int pistachio_evt_set_source(struct pistachio_evt *evt,
+			int id, enum pistachio_evt_source source)
 {
-	u32 timestamps_per_reg, reg_addr, reg, shift;
-	struct pistachio_evt_data *evt = platform_get_drvdata(pdev);
 	unsigned long flags;
+	u32 reg;
 
-	dev_dbg(evt->dev, "Set timestamp source module index %u source %u\n", (unsigned int)ts_module_index, (unsigned int)interrupt_source);
-
-	if (ts_module_index >= PISTACHIO_EVT_NUM_TIMESTAMP_MODULES) {
-		dev_err(evt->dev, "Set timestamp source module index %u failed (bad timestamp module index %u)\n", (unsigned int)ts_module_index, ts_module_index);
+	if ((id >= PISTACHIO_EVT_MAX_SOURCES) ||
+			(source >= PISTACHIO_EVT_NUM_SOURCES))
 		return -EINVAL;
-	}
 
-	timestamps_per_reg = (32 / PISTACHIO_EVT_TIMESTAMP_SRC_WIDTH);
-	reg_addr = PISTACHIO_EVT_TIMESTAMP_SRC_START +
-		((ts_module_index / timestamps_per_reg) * 4);
+	spin_lock_irqsave(&evt->lock, flags);
 
-	shift = ts_module_index % timestamps_per_reg;
-	shift *= PISTACHIO_EVT_TIMESTAMP_SRC_WIDTH;
+	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_SOURCES);
+	reg &= ~(PISTACHIO_EVT_SOURCES_MASK_LSB <<
+		(id * PISTACHIO_EVT_SOURCES_SHIFT));
+	reg |= source << (id * PISTACHIO_EVT_SOURCES_SHIFT);
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_SOURCES);
 
-	spin_lock_irqsave(&evt->lock, flags);
+	/*
+	 * Changing one of the sources invalidates the active sample rate
+	 * measurement for the source in question, and the active phase
+	 * difference measurement, so reset these states and mask the
+	 * interrupts
+	 */
+	evt->sample_rates[id].state = PISTACHIO_EVT_STATE_IDLE;
+	evt->phase_difference.state = PISTACHIO_EVT_STATE_IDLE;
 
-	reg = pistachio_evt_readl(evt, reg_addr);
+	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_ENABLE);
+	if (id == 0)
+		reg &= ~PISTACHIO_EVT_INT_SAMPLE_0_FNE_MASK;
+	else
+		reg &= ~PISTACHIO_EVT_INT_SAMPLE_1_FNE_MASK;
+	reg &= ~PISTACHIO_EVT_INT_PHASE_FNE_MASK;
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_INT_ENABLE);
 
-	reg &= ~(PISTACHIO_EVT_TIMESTAMP_SRC_MASK << shift);
+	spin_unlock_irqrestore(&evt->lock, flags);
 
-	reg |= (interrupt_source & PISTACHIO_EVT_TIMESTAMP_SRC_MASK) << shift;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_set_source);
 
-	pistachio_evt_writel(evt, reg, reg_addr);
+int pistachio_evt_get_source(struct pistachio_evt *evt,
+		int id, enum pistachio_evt_source *source)
+{
+	u32 reg;
 
-	pistachio_evt_writel(evt, 1 << ts_module_index,
-			PISTACHIO_EVT_TIMESTAMP_CLR);
+	if (id >= PISTACHIO_EVT_MAX_SOURCES)
+		return -EINVAL;
 
-	spin_unlock_irqrestore(&evt->lock, flags);
+	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_SOURCES);
+
+	*source = (reg >> (id * PISTACHIO_EVT_SOURCES_SHIFT)) &
+		PISTACHIO_EVT_SOURCES_MASK_LSB;
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(pistachio_evt_set_timestamp_source);
+EXPORT_SYMBOL_GPL(pistachio_evt_get_source);
 
-int pistachio_evt_get_timestamp(struct platform_device *pdev,
-		unsigned int ts_module_index, struct timespec *timestamp)
+static void pistachio_evt_clear_fifo(struct pistachio_evt *evt,
+			u32 fifo_offset, u32 mask, bool enable_int)
 {
-	u32 reg, cyc, ts;
-	u64 tmp;
-	struct pistachio_evt_data *evt = platform_get_drvdata(pdev);
-	unsigned long flags;
+	u32 reg;
 
-	dev_dbg(evt->dev, "Get timestamp module index %u\n", (unsigned int)ts_module_index);
+	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_ENABLE);
+	if (enable_int)
+		reg |= mask;
+	else
+		reg &= ~mask;
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_INT_ENABLE);
 
-	if (ts_module_index >= PISTACHIO_EVT_NUM_TIMESTAMP_MODULES) {
-		dev_err(evt->dev, "Set timestamp source module index %u failed (bad timestamp module index %u)\n", (unsigned int)ts_module_index, ts_module_index);
-		return -EINVAL;
+	while (1) {
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_STATUS);
+		if (!(reg & mask))
+			break;
+		reg = pistachio_evt_readl(evt, fifo_offset);
+		pistachio_evt_writel(evt, mask, PISTACHIO_EVT_INT_CLEAR);
+		pistachio_evt_writel(evt, 0, PISTACHIO_EVT_INT_CLEAR);
 	}
+}
 
-	spin_lock_irqsave(&evt->lock, flags);
+static void pistachio_evt_new_sr(struct pistachio_evt *evt, int id, u32 mask)
+{
+	u32 reg;
+	enum pistachio_evt_state new_state;
+	struct pistachio_evt_measurement *sr = &evt->sample_rates[id];
+
+	switch (sr->state) {
+	case PISTACHIO_EVT_STATE_ACTIVE_FIRST:
+		/* First sample rate measurement is always invalid */
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_SAMPLE_FIFO(id));
+		pistachio_evt_writel(evt, mask, PISTACHIO_EVT_INT_CLEAR);
+		pistachio_evt_writel(evt, 0, PISTACHIO_EVT_INT_CLEAR);
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_STATUS);
+		if (reg & mask)
+			new_state = PISTACHIO_EVT_STATE_COMPLETE;
+		else
+			new_state = PISTACHIO_EVT_STATE_ACTIVE_SECOND;
+		break;
 
-	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_TIMESTAMP_STS);
+	case PISTACHIO_EVT_STATE_ACTIVE_SECOND:
+		new_state = PISTACHIO_EVT_STATE_COMPLETE;
+		break;
 
-	/* No new timestamp available? */
-	if (!(reg & (1 << ts_module_index))) {
-		dev_dbg(evt->dev, "Get timestamp module index %u failed (no new timestamp)\n", (unsigned int)ts_module_index);
-		spin_unlock_irqrestore(&evt->lock, flags);
-		return -EBUSY;
+	default:
+		dev_err(evt->dev, "pistachio_evt_new_sr bad state (%d)\n",
+			(int)sr->state);
+		return;
+	}
+
+	if (new_state == PISTACHIO_EVT_STATE_COMPLETE) {
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_ENABLE);
+		reg &= ~mask;
+		pistachio_evt_writel(evt, reg, PISTACHIO_EVT_INT_ENABLE);
+		pistachio_evt_writel(evt, mask, PISTACHIO_EVT_INT_CLEAR);
+		pistachio_evt_writel(evt, 0, PISTACHIO_EVT_INT_CLEAR);
+		if (sr->callback)
+			sr->callback(sr->context);
+	}
+
+	sr->state = new_state;
+}
+
+static void pistachio_evt_new_pd(struct pistachio_evt *evt)
+{
+	u32 reg;
+	enum pistachio_evt_state new_state;
+	u32 mask = PISTACHIO_EVT_INT_PHASE_FNE_MASK;
+	struct pistachio_evt_measurement *pd = &evt->phase_difference;
+
+	switch (pd->state) {
+	case PISTACHIO_EVT_STATE_ACTIVE_FIRST:
+		/* First two phase measurements are always invalid */
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_PHASE_FIFO);
+		pistachio_evt_writel(evt, mask, PISTACHIO_EVT_INT_CLEAR);
+		pistachio_evt_writel(evt, 0, PISTACHIO_EVT_INT_CLEAR);
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_STATUS);
+		if (!(reg & mask)) {
+			new_state = PISTACHIO_EVT_STATE_ACTIVE_SECOND;
+			break;
+		}
+		/* Fall through */
+	case PISTACHIO_EVT_STATE_ACTIVE_SECOND:
+		/* First two phase measurements are always invalid */
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_PHASE_FIFO);
+		pistachio_evt_writel(evt, mask, PISTACHIO_EVT_INT_CLEAR);
+		pistachio_evt_writel(evt, 0, PISTACHIO_EVT_INT_CLEAR);
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_STATUS);
+		if (reg & mask)
+			new_state = PISTACHIO_EVT_STATE_COMPLETE;
+		else
+			new_state = PISTACHIO_EVT_STATE_ACTIVE_THIRD;
+		break;
+
+	case PISTACHIO_EVT_STATE_ACTIVE_THIRD:
+		new_state = PISTACHIO_EVT_STATE_COMPLETE;
+		break;
+
+	default:
+		dev_err(evt->dev, "pistachio_evt_new_pd bad state (%d)\n",
+			(int)pd->state);
+		return;
+	}
+
+	if (new_state == PISTACHIO_EVT_STATE_COMPLETE) {
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_ENABLE);
+		reg &= ~mask;
+		pistachio_evt_writel(evt, reg, PISTACHIO_EVT_INT_ENABLE);
+		pistachio_evt_writel(evt, mask, PISTACHIO_EVT_INT_CLEAR);
+		pistachio_evt_writel(evt, 0, PISTACHIO_EVT_INT_CLEAR);
+		if (pd->callback)
+			pd->callback(pd->context);
 	}
 
-	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_TIMESTAMP_START +
-		(ts_module_index * 0x4));
+	pd->state = new_state;
+}
+
+static irqreturn_t pistachio_evt_general_irq(int irq, void *dev_id)
+{
+	struct pistachio_evt *evt = (struct pistachio_evt *)dev_id;
+	unsigned long flags;
+	u32 mask, i, isr, ier;
 
-	pistachio_evt_writel(evt, 1 << ts_module_index,
-			PISTACHIO_EVT_TIMESTAMP_CLR);
+	spin_lock_irqsave(&evt->lock, flags);
 
-	tmp = _pistachio_evt_read_ns(evt, &cyc);
+	while (1) {
+		isr = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_STATUS);
+		ier = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_ENABLE);
+		isr &= ier;
 
-	ts = reg & PISTACHIO_EVT_COUNTER_MASK;
+		if (!isr)
+			break;
 
-	/*
-	 * This currently assumes that the period of time between the
-	 * timestamped event and the current time is less than the period
-	 * of the counter. Maybe timestamps should be checked in the poll
-	 * function that ensures the tc doesnt overflow...
-	 */
+		for (i = 0; i < PISTACHIO_EVT_MAX_SOURCES; i++) {
+			if (i == 0)
+				mask = PISTACHIO_EVT_INT_SAMPLE_0_FNE_MASK;
+			else
+				mask = PISTACHIO_EVT_INT_SAMPLE_1_FNE_MASK;
 
-	/* Get the cycle difference */
-	cyc = (cyc - ts) & PISTACHIO_EVT_COUNTER_MASK;
+			if (isr & mask)
+				pistachio_evt_new_sr(evt, i, mask);
+		}
 
-	/* Calculate the ns difference and the ns timestamp value */
-	tmp -= ((u64)cyc * evt->cc.mult) >> evt->cc.shift;
+		if (isr & PISTACHIO_EVT_INT_PHASE_FNE_MASK)
+			pistachio_evt_new_pd(evt);
+	}
 
 	spin_unlock_irqrestore(&evt->lock, flags);
 
-	timestamp->tv_nsec = do_div(tmp, NSEC_PER_SEC);
-	timestamp->tv_sec = tmp;
+	return IRQ_HANDLED;
+}
 
-	return 0;
+int pistachio_evt_get_sample_rate(struct pistachio_evt *evt, int id,
+			u32 *val, u32 *sys_freq,
+			void (*callback)(void *context), void *context)
+{
+	unsigned long flags;
+	u32 mask;
+	int ret;
+
+	if (id >= PISTACHIO_EVT_MAX_SOURCES)
+		return -EINVAL;
+
+	spin_lock_irqsave(&evt->lock, flags);
+
+	switch (evt->sample_rates[id].state) {
+	case PISTACHIO_EVT_STATE_IDLE:
+		if (id == 0)
+			mask = PISTACHIO_EVT_INT_SAMPLE_0_FNE_MASK;
+		else
+			mask = PISTACHIO_EVT_INT_SAMPLE_1_FNE_MASK;
+
+		pistachio_evt_clear_fifo(evt, PISTACHIO_EVT_SAMPLE_FIFO(id),
+					mask, true);
+
+		ret = -EBUSY;
+		evt->sample_rates[id].state = PISTACHIO_EVT_STATE_ACTIVE_FIRST;
+		evt->sample_rates[id].callback = callback;
+		evt->sample_rates[id].context = context;
+		break;
+
+	case PISTACHIO_EVT_STATE_COMPLETE:
+		*val = pistachio_evt_readl(evt, PISTACHIO_EVT_SAMPLE_FIFO(id));
+		*sys_freq = evt->sys_rate;
+		evt->sample_rates[id].state = PISTACHIO_EVT_STATE_IDLE;
+		ret = 0;
+		break;
+
+	default:
+		ret = -EBUSY;
+		break;
+	}
+
+	spin_unlock_irqrestore(&evt->lock, flags);
+
+	return ret;
 }
-EXPORT_SYMBOL_GPL(pistachio_evt_get_timestamp);
+EXPORT_SYMBOL_GPL(pistachio_evt_get_sample_rate);
 
-enum hrtimer_restart pistachio_evt_poll(struct hrtimer *tmr)
+extern int pistachio_evt_get_phase_difference(struct pistachio_evt *evt,
+			u32 *val, u32 *sys_freq,
+			void (*callback)(void *context), void *context)
 {
-	struct pistachio_evt_data *evt;
-	u64 tmp, nsec;
+	unsigned long flags;
+	u32 mask;
+	int ret = 0;
+
+	spin_lock_irqsave(&evt->lock, flags);
+
+	switch (evt->phase_difference.state) {
+	case PISTACHIO_EVT_STATE_IDLE:
+		mask = PISTACHIO_EVT_INT_PHASE_FNE_MASK;
 
-	evt = container_of(tmr, struct pistachio_evt_data, poll_timer);
+		pistachio_evt_clear_fifo(evt, PISTACHIO_EVT_PHASE_FIFO,
+						mask, true);
+
+		ret = -EBUSY;
+		evt->phase_difference.state = PISTACHIO_EVT_STATE_ACTIVE_FIRST;
+		evt->phase_difference.callback = callback;
+		evt->phase_difference.context = context;
+		break;
+
+	case PISTACHIO_EVT_STATE_COMPLETE:
+		*val = pistachio_evt_readl(evt, PISTACHIO_EVT_PHASE_FIFO);
+		*sys_freq = evt->sys_rate;
+		evt->phase_difference.state = PISTACHIO_EVT_STATE_IDLE;
+		break;
+
+	default:
+		ret = -EBUSY;
+		break;
+	}
 
-	tmp = pistachio_evt_read_ns(evt, NULL);
-	nsec = do_div(tmp, NSEC_PER_SEC);
+	spin_unlock_irqrestore(&evt->lock, flags);
 
-	//dev_dbg(evt->dev, "poll time = %u,%u\n", (unsigned int)tmp, (unsigned int)nsec);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_get_phase_difference);
 
-	hrtimer_forward(&evt->poll_timer,
-			hrtimer_get_expires(&evt->poll_timer),
-			evt->quarter_rollover);
+void pistachio_evt_abort_measurements(struct pistachio_evt *evt)
+{
+	unsigned long flags;
+	u32 reg;
 
-	return HRTIMER_RESTART;
+	spin_lock_irqsave(&evt->lock, flags);
+	evt->sample_rates[0].state = PISTACHIO_EVT_STATE_IDLE;
+	evt->sample_rates[1].state = PISTACHIO_EVT_STATE_IDLE;
+	evt->phase_difference.state = PISTACHIO_EVT_STATE_IDLE;
+	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_ENABLE);
+	reg &= ~PISTACHIO_EVT_INT_SAMPLE_0_FNE_MASK;
+	reg &= ~PISTACHIO_EVT_INT_SAMPLE_1_FNE_MASK;
+	reg &= ~PISTACHIO_EVT_INT_PHASE_FNE_MASK;
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_INT_ENABLE);
+	spin_unlock_irqrestore(&evt->lock, flags);
 }
+EXPORT_SYMBOL_GPL(pistachio_evt_abort_measurements);
 
-static void pistachio_evt_clk_rate_change(struct pistachio_evt_data *evt)
+static void pistachio_evt_clk_rate_change(struct pistachio_evt *evt)
 {
 	u64 tmp;
 	unsigned long flags;
@@ -618,69 +749,24 @@ static void pistachio_evt_clk_rate_change(struct pistachio_evt_data *evt)
 			NSEC_PER_SEC, DIV_ROUND_UP(mask, rate));
 
 	spin_lock_irqsave(&evt->lock, flags);
-	evt->rate = rate;
 	evt->quarter_rollover = quarter_rollover;
 	evt->cc.mult = mult;
 	evt->cc.shift = shift;
 	spin_unlock_irqrestore(&evt->lock, flags);
 
-	evt_timer_rate = rate;
-
 	dev_dbg(evt->dev, "rate %ld cc mult %u shift %u\n", rate, evt->cc.mult,
 			evt->cc.shift);
 }
 
-#ifndef	CONFIG_ATU
-static void pistachio_evt_start_poll_timer(struct pistachio_evt_data *evt)
-{
-	ktime_t ks;
-
-	dev_dbg(evt->dev, "pistachio_evt_start_poll_timer()\n");
-
-	ks = ktime_get();
-	ks = ktime_add(ks, evt->quarter_rollover);
-
-	hrtimer_start(&evt->poll_timer, ks, HRTIMER_MODE_ABS);
-}
-
-static int pistachio_evt_clk_notifier_cb(struct notifier_block *nb,
-		unsigned long event, void *data)
-{
-	struct pistachio_evt_data *evt;
-
-	evt = container_of(nb, struct pistachio_evt_data, evt_clk_notifier);
-
-	dev_dbg(evt->dev, "pistachio_evt_clk_notifier_cb()\n");
-
-	switch (event) {
-	case PRE_RATE_CHANGE:
-		pistachio_evt_read_ns(evt, NULL);
-		return NOTIFY_OK;
-	case POST_RATE_CHANGE:
-		hrtimer_cancel(&evt->poll_timer);
-		pistachio_evt_clk_rate_change(evt);
-		pistachio_evt_read_ns(evt, NULL);
-		pistachio_evt_start_poll_timer(evt);
-		return NOTIFY_OK;
-	case ABORT_RATE_CHANGE:
-		return NOTIFY_OK;
-	default:
-		return NOTIFY_DONE;
-	}
-}
-#endif
-
 static int pistachio_evt_driver_probe(struct platform_device *pdev)
 {
-	struct pistachio_evt_data *evt;
-	int ret, i, irq;
+	struct pistachio_evt *evt;
+	int ret, irq;
 	struct device_node *np = pdev->dev.of_node;
-	u32 clk_select, rate;
+	u32 clk_select, rate, ext_src_bank;
 	struct resource iomem;
 	struct device *dev = &pdev->dev;
-#ifdef CONFIG_ATU
-	struct clk *audio_pll;
-#endif
+	struct regmap *periph_regs;
 
 	evt = devm_kzalloc(&pdev->dev, sizeof(*evt), GFP_KERNEL);
 	if (!evt)
@@ -688,6 +774,7 @@ static int pistachio_evt_driver_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, evt);
 
 	evt->dev = dev;
+	evt->np = np;
 
 	spin_lock_init(&evt->lock);
 
@@ -701,6 +788,19 @@ static int pistachio_evt_driver_probe(struct platform_device *pdev)
 	if (IS_ERR(evt->base))
 		return PTR_ERR(evt->base);
 
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "can't get general irq\n");
+		return irq;
+	}
+
+	ret = devm_request_irq(&pdev->dev, irq, pistachio_evt_general_irq,
+				0, pdev->name, evt);
+	if (ret) {
+		dev_err(&pdev->dev, "can't request irq %d\n", irq);
+		return ret;
+	}
+
 	irq = platform_get_irq(pdev, 3);
 	if (irq < 0) {
 		dev_err(&pdev->dev, "can't get trigger 0 irq\n");
@@ -714,6 +814,21 @@ static int pistachio_evt_driver_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	periph_regs = syscon_regmap_lookup_by_phandle(np, "img,cr-periph");
+	if (IS_ERR(periph_regs))
+		return PTR_ERR(periph_regs);
+
+	if (of_property_read_u32(np, "img,ext-src-bank", &ext_src_bank)) {
+		dev_err(&pdev->dev, "No img,ext-src-bank property\n");
+		return -EINVAL;
+	}
+
+	if (ext_src_bank >= PISTACHIO_EVT_EXT_SRC_NUM_BANKS)
+		return -EINVAL;
+
+	regmap_update_bits(periph_regs, PISTACHIO_EVT_EXT_SRC_REG,
+			PISTACHIO_EVT_EXT_SRC_MASK, ext_src_bank);
+
 	if (of_property_read_u32(np, "img,clk-select", &clk_select)) {
 		dev_err(&pdev->dev, "No img,clk-select property\n");
 		return -EINVAL;
@@ -725,13 +840,23 @@ static int pistachio_evt_driver_probe(struct platform_device *pdev)
 	if (of_property_read_u32(np, "img,clk-rate", &rate))
 		rate = 0;
 
+	evt->audio_pll = devm_clk_get(&pdev->dev, "pll");
+	if (IS_ERR(evt->audio_pll))
+		return PTR_ERR(evt->audio_pll);
+
+	ret = clk_prepare_enable(evt->audio_pll);
+	if (ret)
+		return ret;
+
 	evt->clk_ref_a = devm_clk_get(&pdev->dev, "ref0");
-	if (IS_ERR(evt->clk_ref_a))
-		return PTR_ERR(evt->clk_ref_a);
+	if (IS_ERR(evt->clk_ref_a)) {
+		ret = PTR_ERR(evt->audio_pll);
+		goto err_pll;
+	}
 
 	ret = clk_prepare_enable(evt->clk_ref_a);
 	if (ret)
-		return ret;
+		goto err_pll;
 
 	evt->clk_ref_b = devm_clk_get(&pdev->dev, "ref1");
 	if (IS_ERR(evt->clk_ref_b)) {
@@ -753,6 +878,8 @@ static int pistachio_evt_driver_probe(struct platform_device *pdev)
 	if (ret)
 		goto err_ref_b;
 
+	evt->sys_rate = clk_get_rate(evt->clk_sys);
+
 	evt->ref_names[0] = __clk_get_name(evt->clk_ref_a);
 	evt->ref_names[1] = __clk_get_name(evt->clk_ref_b);
 
@@ -788,9 +915,6 @@ static int pistachio_evt_driver_probe(struct platform_device *pdev)
 			goto err_clkp;
 	}
 
-	hrtimer_init(&evt->poll_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
-	evt->poll_timer.function = pistachio_evt_poll;
-
 	evt->cc.mask = PISTACHIO_EVT_COUNTER_MASK;
 	evt->cc.read = pistachio_evt_cc_read;
 
@@ -801,40 +925,17 @@ static int pistachio_evt_driver_probe(struct platform_device *pdev)
 
 	pistachio_evt_clk_rate_change(evt);
 
-	timecounter_init(&evt->tc, (const struct cyclecounter *)&evt->cc, 0);
-
-#ifdef CONFIG_ATU
-	audio_pll = devm_clk_get(&pdev->dev, "pll");
-	if (IS_ERR(audio_pll))
-		audio_pll = NULL;
-	ret = atu_cyclecounter_register(&evt->cc, audio_pll);
-	if(ret)
-		goto err_count;
-#else
-	pistachio_evt_start_poll_timer(evt);
-
-	evt->evt_clk_notifier.notifier_call = pistachio_evt_clk_notifier_cb;
-	ret = clk_notifier_register(evt->clk_ref_internal,
-			&evt->evt_clk_notifier);
+	ret = pistachio_evt_init(evt);
 	if (ret)
 		goto err_count;
-#endif
 
-	/*
-	 * 2nd layer of muxing for event timer sources.
-	 * Not useful, use identity mapping
-	 */
-	for (i = 0; i < 12; i++) {
-		pistachio_evt_writel(evt, i,
-			PISTACHIO_EVT_SOURCE_INTERNAL_START + (i * 0x4));
-	}
+	spin_lock(&pistachio_evt_list_spinlock);
+	list_add(&evt->list, &pistachio_evt_list);
+	spin_unlock(&pistachio_evt_list_spinlock);
 
 	return 0;
 
 err_count:
-#ifndef	CONFIG_ATU
-	hrtimer_cancel(&evt->poll_timer);
-#endif
 	pistachio_evt_stop_count(evt);
 	pistachio_evt_writel(evt, 0, PISTACHIO_EVT_TIMER_ENABLE);
 err_clkp:
@@ -847,6 +948,8 @@ err_ref_b:
 	clk_disable_unprepare(evt->clk_ref_b);
 err_ref_a:
 	clk_disable_unprepare(evt->clk_ref_a);
+err_pll:
+	clk_disable_unprepare(evt->audio_pll);
 
 	return ret;
 }
@@ -859,21 +962,20 @@ MODULE_DEVICE_TABLE(of, pistachio_evt_of_match);
 
 static int pistachio_evt_driver_remove(struct platform_device *pdev)
 {
-	struct pistachio_evt_data *evt = platform_get_drvdata(pdev);
-
-#ifdef CONFIG_ATU
-	atu_cyclecounter_unregister(&evt->cc);
-#else
-	clk_notifier_unregister(evt->clk_ref_internal, &evt->evt_clk_notifier);
-	hrtimer_cancel(&evt->poll_timer);
-#endif
-	of_clk_del_provider(evt->dev->of_node);
+	struct pistachio_evt *evt = platform_get_drvdata(pdev);
+
+	spin_lock(&pistachio_evt_list_spinlock);
+	list_del(&evt->list);
+	spin_unlock(&pistachio_evt_list_spinlock);
+	pistachio_evt_deinit(evt);
 	pistachio_evt_stop_count(evt);
 	pistachio_evt_writel(evt, 0, PISTACHIO_EVT_TIMER_ENABLE);
+	of_clk_del_provider(evt->dev->of_node);
 	clk_unregister(evt->clk_ref_internal);
 	clk_disable_unprepare(evt->clk_sys);
 	clk_disable_unprepare(evt->clk_ref_b);
 	clk_disable_unprepare(evt->clk_ref_a);
+	clk_disable_unprepare(evt->audio_pll);
 
 	return 0;
 }
diff --git a/sound/soc/img/pistachio-event-timer.h b/sound/soc/img/pistachio-event-timer.h
index 458807f..0f0d4b6 100644
--- a/sound/soc/img/pistachio-event-timer.h
+++ b/sound/soc/img/pistachio-event-timer.h
@@ -13,6 +13,8 @@
 #ifndef __IMG_PISTACHIO_EVT_H__
 #define __IMG_PISTACHIO_EVT_H__
 
+struct pistachio_evt;
+
 enum pistachio_evt_enable {
 	PISTACHIO_EVT_ENABLE_PARALLEL_OUT = 0,
 	PISTACHIO_EVT_ENABLE_I2S_OUT,
@@ -24,31 +26,57 @@ enum pistachio_evt_enable {
 };
 
 enum pistachio_evt_type {
-	PISTACHIO_EVT_TYPE_NONE = 0,
-	PISTACHIO_EVT_TYPE_PULSE,
+	PISTACHIO_EVT_TYPE_PULSE = 1,
 	PISTACHIO_EVT_TYPE_LEVEL
 };
 
+enum pistachio_evt_source {
+	PISTACHIO_EVT_SOURCE_EXTERNAL = 0,
+	PISTACHIO_EVT_SOURCE_SPDIF_IN,
+	PISTACHIO_EVT_SOURCE_SPDIF_OUT,
+	PISTACHIO_EVT_SOURCE_I2S_IN,
+	PISTACHIO_EVT_SOURCE_I2S_OUT,
+	PISTACHIO_EVT_SOURCE_PARALLEL_OUT,
+	PISTACHIO_EVT_NUM_SOURCES
+};
+
 #define	PISTACHIO_EVT_NUM_TIMESTAMP_MODULES	12
 
-extern void pistachio_evt_read(struct platform_device *pdev,
+#define	PISTACHIO_EVT_MAX_SOURCES		2
+
+extern struct pistachio_evt *pistachio_evt_get(struct device_node *np);
+
+extern void pistachio_evt_get_time_ts(struct pistachio_evt *evt,
 				struct timespec *ts);
 
-extern void pistachio_evt_disable_event(struct platform_device *pdev,
-		enum pistachio_evt_enable event);
+/* Call this outside of an event callback */
+extern void pistachio_evt_disable_event(struct pistachio_evt *evt,
+					enum pistachio_evt_enable event);
+
+/* Call this inside of an event callback */
+extern void _pistachio_evt_disable_event(struct pistachio_evt *evt,
+					enum pistachio_evt_enable event);
+
+extern int pistachio_evt_set_event(struct pistachio_evt *evt,
+	enum pistachio_evt_enable event, enum pistachio_evt_type type,
+	struct timespec *ts,
+	void (*event_trigger_callback)(struct pistachio_evt *, void *),
+	void *context);
+
+extern int pistachio_evt_set_source(struct pistachio_evt *evt, int id,
+				enum pistachio_evt_source source);
 
-extern void _pistachio_evt_disable_event(struct platform_device *pdev,
-		enum pistachio_evt_enable event);
+extern int pistachio_evt_get_source(struct pistachio_evt *evt,
+			int id, enum pistachio_evt_source *source);
 
-extern int pistachio_evt_set_event(struct platform_device *pdev,
-		enum pistachio_evt_enable event, enum pistachio_evt_type type,
-		struct timespec *ts,
-		void (*event_trigger_callback)(void *context), void *context);
+extern int pistachio_evt_get_sample_rate(struct pistachio_evt *evt, int id,
+			u32 *val, u32 *sys_freq,
+			void (*callback)(void *), void *context);
 
-extern int pistachio_evt_set_timestamp_source(struct platform_device *pdev,
-		unsigned int ts_module_index, unsigned int interrupt_source);
+extern int pistachio_evt_get_phase_difference(struct pistachio_evt *evt,
+			u32 *val, u32 *sys_freq,
+			void (*callback)(void *), void *context);
 
-extern int pistachio_evt_get_timestamp(struct platform_device *pdev,
-		unsigned int ts_module_index, struct timespec *timestamp);
+extern void pistachio_evt_abort_measurements(struct pistachio_evt *evt);
 
 #endif
-- 
2.6.2

